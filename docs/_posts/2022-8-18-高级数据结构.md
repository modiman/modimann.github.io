目录

* 红黑树
* 

# 13-集合

## 13.1 集合接口

### 13.1.1 将集合的接口与实现分离

Java 集合类库将接口与实现分离。以队列(queue）为例介绍

一个队列的最小形式如下

```java
interface Queue<E>{
void add(E element);
E remove;
int size();
}
```

通常队列的实现有两种方法，分别是循环数组和链表



### 13.1.2 Java 类库中的集合接口和迭代器接口

在Java类库中，集合类的基本接口是Collection接口。

这个接口有两个基本方法

```java
public interface Collection<E>{
    boolean add(E element);
    Iterator <E> iterator();
    ...
}
```

add方法用于向集合添加元素。如果添加元素成功返回true，失败（例如集合中已经存在要添加的元素）返回false

iterator方法返回一个实现了Iterator接口的对象，可以用这个迭代器对象遍历集合中的元素

**迭代器**：Iterator接口包含三个方法

```java
public interface Iterator<E>{
    E next();
    boolean hasNext();
    void remove();
}
```

通过反复调用next（）方法，可以逐个访问集合的每个元素

## 13.2 具体的集合

1. 链表  List 、LinkedList
2. 数组列表 ArrayList 实现了List
3. 散列集 HashSet 
4. 树集 TreeSet
5. 

散列



## 线程安全

Collection 是对象集合， Collection 有两个子接口 List 和 Set,

**有且只有Vector和HashTable线程安全**

Vector和Hashtable中的方法有synchronized修饰

两者虽然线程安全，但是性能变差，因为线程加锁需要监控时间

------

List 可以通过下标 (1,2..) 来取得值，值可以重复,而 Set 只能通过游标来取值，并且值是不能重复的

ArrayList ， Vector ， LinkedList 是 List 的实现类

ArrayList 是线程不安全的， Vector 是线程安全的，这两个类底层都是由数组实现的

LinkedList 是线程不安全的，底层是由链表实现的



Map 是键值对集合

HashTable 和 HashMap 是 Map 的实现类

HashTable 是线程安全的，不能存储 null 值

HashMap 不是线程安全的，可以存储 null 值



## 集合collection



![image-20220622170357493](https://github.com/modiman/modiman.github.io/blob/gh-pages/docs/_posts/imgs/image-20220622170357493.png?raw=true)两大集合类接口

众所周知，Java 集合框架拥有两大接口 `Collection` 和 `Map`，其中，`Collection` 麾下三生子 `List`、`Set` 和 `Queue`。

## ArrayList 

1. **基本定义**

* `ArrayList` 就实现了 `List` 接口，其实就是一个数组列表，
* 只能存储对象引用类型

`ArrayList` 的底层实现是一个 `Object` 数组：

* 查找 O(1)
* 增删o(n)

另外，和 `ArrayList` 一样同样实现了 `List` 接口的、我们比较常用的还有 `LinkedList`。`LinkedList` 比较特殊，它不仅实现了 `List` 接口，还实现了 `Queue` 接口，所以你可以看见 `LinkedList` 经常被当作队列使用：

```java
Queue<Integer> queue = new LinkedList<>();
```

* `LinkedList` 人如其名，它的底层自然是基于[链表](https://www.nowcoder.com/jump/super-jump/word?word=链表)的，而且还是个双向[链表](https://www.nowcoder.com/jump/super-jump/word?word=链表)。
* 
* 
* **ArrayList 如何指定底层数组大小的？**

OK，首先，既然咱真正存储数据的地方是数组，那我们初始化 `ArrayList` 的时候自然要给数组分配一个大小，开辟一个内存空间。我们先来看看 `ArrayList` 的无参构造函数：

* 默认为0
* 第一次add时分配为0
* 通过构造函数指定大小

3. **数组的大小一旦被规定就无法改变，那 ArrayList 是怎么对底层数组进行扩容的？**

`ArrayList` 的底层实现是 `Object` 数组，我们知道，数组的大小一旦被规定就无法改变。那如果我们不断的往里面添加数据的话，`ArrayList` 是如何进行扩容的呢？或者说 ArrayList 是如何实现存放任意数量对象的呢？

OK，扩容发生在啥时候？那肯定是我们往数组中新加入一个元素但是发现数组满了的时候。没错，我们去 `add` 方法中看看 `ArrayList` 是怎么做扩容的：

`ensureExplicitCapacity` 判断是否需要进行扩容，很显然，`grow` 方法是扩容的关键：

说实话，别的都不用看了，看上面图中的黄色框框就知道 `ArrayList` 是怎么扩容的了：扩容后的数组长度 = 当前数组长度 + 当前数组长度 / 2。最后使用 `Arrays.copyOf` 方法直接把原数组中的数组 copy 过来，需要注意的是，`Arrays.copyOf` 方***创建一个**新数组**然后再进行拷贝。



4. **既然扩容发生在添加数据的时候**，**讲讲** **ArrayList** **具体是怎么添加数据的**

OK，`add` 方法我们刚刚讲了一半，添加数据前会先判断一下是否需要扩容，真正的添加数据的操作在下半部分：

先讲下 `add(int index, E element)` 这个方法的含义，就是在指定索引 index 处插入元素 element。比如说 `ArrayList.add(0, 3)`，意思就是在头部插入元素 3。

再来看看 `add` 方法的核心 `System.arraycopy`，这个方法有 5 个参数：

- elementData：源数组
- index：从源数组中的哪个位置开始复制
- elementData：目标数组
- index + 1：复制到目标数组中的哪个位置
- size - index：要复制的源数组中数组元素的数量

解释一下上面代码中 `arraycopy` 的意思，举个例子，我们想要在 index = 5 的位置插入元素，首先，我们会复制一遍源数组 elementData（这里我们称复制的数组为新数组吧），然后把源数组中从 index = 5 的位置开始到数组末尾的元素，放到新数组的 index + 1 = 6 的位置上：

于是，这就给我们要新增的元素腾出了位置，然后在新数组 index = 5 的位置放入元素 element 就完成了添加的操作：

显然，不用多说，ArrayList 的将数据插入到指定位置的操作性能非常低下，因为要开辟新数组复制元素啊，要是涉及到扩容那就更慢了。

另外，`ArrayList` 还内置了一个直接在末尾添加元素的 `add` 方法，不用复制数组，直接 size ++ 就好，这个方法应该是我们最常使用的：



5. ArrayList 又是如何删除数据的呢？

Ctrl + F 找到 `remove` 方法，就这？和添加一个道理，也是复制数组

举个例子，假设我们要删除数组的 index = 5 的元素，首先，我们会复制一遍源数组，然后把源数组中从 index + 1 = 6 的位置开始到数组末尾的元素，放到新数组的 index = 5 的位置上：



也就是说 index = 5 的元素直接被覆盖掉了，给了你被删除的感觉。同样的，它的效率自然也是十分低下的

6. ArrayList 是线程安全的吗？不安全的表现

`ArrayList` 和 `LinkedList` 都不是线程安全的，我们以在末尾添加元素的 `add` 方法为例，来看看 `ArrayList` 线程不安全的表现是啥：

黄色框里的并不是一个原子操作，它由两步操作构成：

```java
elementData[size] = e
size = size + 1;
```

在单线程执行这两条代码时，那当然没有任何问题，但是当多线程环境下执行时，可能就会发生**一个线程添加的值覆盖另一个线程添加的值**。!

`ArrayList` 的线程安全版本是 `Vector`，它的实现很简单，就是把所有的方法统统加上 `synchronized`：

既然它需要额外的开销来维持同步锁，所以理论上来说它要比 `ArrayList` 要慢。

7. **为什么线程不安全还要用它呢？**

因为在大多数场景中，查询的情况居多，不会涉及太频繁的增删。那如果真的涉及频繁的增删，可以使用`LinkedList`，底层[链表](https://www.nowcoder.com/jump/super-jump/word?word=链表)实现，为增删而生。而如果你非得保证线程安全那就使用 `Vector`。当然实际开发中使用最多的还是 `ArrayList`，虽然线程不安全、增删效率





## HashMap

| JDK版本 | 实现方式             | 节点数>=8     | 节点数<=6     |
| ------- | -------------------- | ------------- | ------------- |
| 1.8以前 | 数组+单向链表        | 数组+单向链表 | 数组+单向链表 |
| 1.8以后 | 数组+单向链表+红黑树 | 数组+红黑树   | 数组+单向链表 |

### 重要变量

| 变量名              | 变量解释         | 值    |
| ------------------- | ---------------- | ----- |
| TREEIFY_THRESHOLD   | 变为红黑树临界值 | 8     |
| UNTREEIFY_THRESHOLD | 变为链表临界值   | 6     |
| MIN_TREEIFY_CAPACI  | 红黑树最小长度   | 64    |
| MAXIMUM_CAPACITY    | HashMap最大容量  | 1<<30 |
| DEFAULT_LOAD_FACTOR | 默认负载因子，   | 0.75f |
|                     |                  |       |

### 构造函数四个

* 无参构造，使用默认参数

* ```
  HashMap(int initialCapacity, float loadFactor)
  ```

* ```
  HashMap(int initialCapacity)
  ```

* ```
  HashMap(Map<? extends K, ? extends V> m)
  ```

* 实际上链表转为红黑树的阈值取决于 TREEIFY_THRESHOLD  * DEFAULT_LOAD_FACTOR

### 方法

1. hash()得到hash值

   ```java
   //null默人是0 
   static final int hash(Object key) {
           int h;
           return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
       //返回键的hashcode高16位与低16位的异或值
       //主要从性能、哈希碰撞角度考虑，减少系统开销，不会造成因为高位没有参与下标计算从而引起的碰撞。
       }
   ```

2. 插入方法 put

   ```java
   public V put(K key, V value) {
       return putVal(hash(key), key, value, false, true);
   }
   //
   final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                  boolean evict) {
       Node<K,V>[] tab; Node<K,V> p; int n, i;
       //
       if ((tab = table) == null || (n = tab.length) == 0)
           n = (tab = resize()).length;
       if ((p = tab[i = (n - 1) & hash]) == null)
           tab[i] = newNode(hash, key, value, null);
       else {
           Node<K,V> e; K k;
           if (p.hash == hash &&
               ((k = p.key) == key || (key != null && key.equals(k))))
               e = p;
           else if (p instanceof TreeNode)
               e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
           else {
               for (int binCount = 0; ; ++binCount) {
                   if ((e = p.next) == null) {
                       p.next = newNode(hash, key, value, null);
                       if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                           treeifyBin(tab, hash);
                       break;
                   }
                   if (e.hash == hash &&
                       ((k = e.key) == key || (key != null && key.equals(k))))
                       break;
                   p = e;
               }
           }
           if (e != null) { // existing mapping for key
               V oldValue = e.value;
               if (!onlyIfAbsent || oldValue == null)
                   e.value = value;
               afterNodeAccess(e);
               return oldValue;
           }
       }
       ++modCount;
       if (++size > threshold)
           resize();
       afterNodeInsertion(evict);
       return null;
   }
   
   ```

   * 当桶数组 table 为空时，通过扩容的方式初始化 table
   * 计算key在tab数组的索引`i = (n - 1) & hash]`,n为数组长度。`（n-1）&hash`等价于`hash%n`
   * 数组中对应位置结点不存在则生成新节点，并放入数组
   * 否则，生成新节点
   * 查找要插入的键值对是否已经存在，存在的话根据条件判断是否用新值替换旧值
   * 如果不存在，则将键值对链入链表中，并根据链表长度决定是否将链表转为红黑树
   * 判断键值对数量是否大于阈值，大于的话则进行扩容操作

3. **查找方法** get

   * 得到key的hash值
   * 定位key对应的数组索引
   * 判断数组对应索引的第一个结点是否满足条件，是则返回结点
   * 如果first是树节点，使用红黑树查找方法，返回结点
   * 否则在链表中查找对应结点 
   * 从结点中取出value返回

### 扩容

当频繁发生碰撞时，说明数组长度（桶数量太少），先考虑调用resize()方法进行扩容

### 线程不安全

```java
 if ((p = tab[i = (n - 1) & hash]) == null) //判断是否出现hash碰撞,如果没有hash碰撞则直接插入元素，此处线程不安全
            tab[i] = newNode(hash, key, value, null);
```

在使用put插入数据时会发生数据覆盖的情况

假设线程A与B哈希值相同，当A判断后没来得及插入数据被阻塞了，当B插入数据完成后A又插入就导致了数据覆盖

## TreeMap

一个有序的map,按键的大小排序

排序规则取决于成员变量`comparator`

```java
private final Comparator<? super K> comparator;
```



### 三个构造函数

* 无参构造函数，将`comparator`初始化为null，默认键为可排序的，比如int,char等

* 以一个`Comparator`型变量作为参数，允许用户自定义键的排序规则。适用于自定义的实体作为键的情况

  * ```java
    public TreeMap(Comparator<? super K> comparator) {
        this.comparator = comparator;
    }
    ```

* 使用一个同样的map构造

* ```
  public TreeMap(SortedMap<K, ? extends V> m) {
  ```

### put

插入数据时的注意事项,如果自定义了comparator,要警惕`compare`方法返回值为0的情况

根据以下代码可以看出，按照compare的返回值

1. 如果大于0，插入左边
2. 如果小于0，插入右边
3. 等于零则直接修改值

这就意味着如果比较规则定义不好会导致插入失败



```java
Comparator<? super K> cpr = comparator;

        if (cpr != null) {
            do {
                parent = t;
                cmp = cpr.compare(key, t.key);
                if (cmp < 0)
                    t = t.left;
                else if (cmp > 0)
                    t = t.right;
                else
                    return t.setValue(value);
            } while (t != null);
        }
```

### Comparator

* 一个接口
* 核心是compare方法
* 大多数排序实现自定义比较的基础

## 红黑树

* [维基百科](https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91)

需要满足性质

1. 节点是红色或黑色。
2. 根是黑色。
3. 所有叶子都是黑色（叶子是NIL节点）。
4. 每个红色节点必须有两个黑色的子节点。（或者说从每个叶子到根的所有路径上不能有两个连续的红色节点。）（或者说不存在两个相邻的红色节点，相邻指两个节点是父子关系。）（或者说红色节点的父节点和子节点均是黑色的。）
5. 从任一节点到其每个叶子的所有[简单路径](https://zh.wikipedia.org/wiki/道路_(图论))都包含相同数目的黑色节点。

用意：

**最短的可能路径都是黑色节点，最长的可能路径有交替的红色和黑色节点。因为根据性质5所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。**



仍然发生很多碰撞，导致链表超过长度阈值，需要将链表转为红黑树

链表节点

```java
final int hash;
final K key;
V value;
Node<K,V> next;
```

红黑树节点,继承自LinkedHashMap.Entry，而LinkedHashMap.Entry继承自 HashMap.Node

```java
static final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {}
static class Entry<K,V> extends HashMap.Node<K,V> {}
```



```java
TreeNode<K,V> parent;  // red-black tree links
TreeNode<K,V> left;
TreeNode<K,V> right;
TreeNode<K,V> prev;    // needed to unlink next upon deletion
boolean red;
```

转换流程

1. 将链表节点转换为树节点，此时变成了一条树节点构成的链表
2. 将链表转换成红黑树

**红黑树查找**：与二叉查找树相同

**红黑树插入**：

1. 按二叉查找书的方式插入一个红节点（如果插入黑结点，很可能违反性质5）

2. 上一步有可能违背性质4，所以需要换颜色和旋转操作替换

   - 性质1和性质3总是保持着。
   - 性质4只在增加红色节点、重绘黑色节点为红色，或做旋转时受到威胁。
   - 性质5只在增加黑色节点、重绘红色节点为黑色，或做旋转时受到威胁。

3. 下面考虑5中插入情形

   * **情形1**：新节点N位于树的根上，没有父节点。在这种情形下，我们把它重绘为黑色以满足性质2。因为它在每个路径上对黑节点数目增加一，性质5符合。
   * **情形2**：新节点的父节点P是黑色，所以性质4没有失效（新节点是红色的）。在这种情形下，树仍是有效的。性质5也未受到威胁，尽管新节点N有两个黑色叶子子节点；但由于新节点N是红色，通过它的每个子节点的路径就都有同通过它所取代的黑色的叶子的路径同样数目的黑色节点，所以依然满足这个性质。
   * **情形3**:如果父节点P和叔父节点U二者都是红色，（此时新插入节点N做为P的左子节点或右子节点都属于情形3，这里右图仅显示N做为P左子的情形）则我们可以将它们两个重绘为黑色并重绘祖父节点G为红色（用来保持性质5）。现在我们的新节点N有了一个黑色的父节点P。因为通过父节点P或叔父节点U的任何路径都必定通过祖父节点G，在这些路径上的黑节点数目没有改变。但是，红色的祖父节点G可能是根节点，这就违反了性质2，也有可能祖父节点G的父节点是红色的，这就违反了性质4。为了解决这个问题，我们在祖父节点G上递归地进行**情形1**的整个过程。（把G当成是新加入的节点进行各种情形的检查）
   * ![情形3示意图](https://upload.wikimedia.org/wikipedia/commons/c/c8/Red-black_tree_insert_case_3.png)
   * **情形4**:父节点P是红色而叔父节点U是黑色或缺少，并且新节点N是其父节点P的右子节点而父节点P又是其父节点的左子节点。在这种情形下，我们进行一次[左旋转](https://zh.wikipedia.org/wiki/树旋转)调换新节点和其父节点的角色;接着，我们按**情形5**处理以前的父节点P以解决仍然失效的性质4。注意这个改变会导致某些路径通过它们以前不通过的新节点N（比如图中1号叶子节点）或不通过节点P（比如图中3号叶子节点），但由于这两个节点都是红色的，所以性质5仍有效。![情形4示意图](https://upload.wikimedia.org/wikipedia/commons/5/56/Red-black_tree_insert_case_4.png)
   * **情形5**：父节点P是红色而叔父节点U是黑色或缺少，新节点N是其父节点的左子节点，而父节点P又是其父节点G的左子节点。在这种情形下，我们进行针对祖父节点G的一次[右旋转](https://zh.wikipedia.org/wiki/树旋转)；在旋转产生的树中，以前的父节点P现在是新节点N和以前的祖父节点G的父节点。我们知道以前的祖父节点G是黑色，否则父节点P就不可能是红色（如果P和G都是红色就违反了性质4，所以G必须是黑色）。我们切换以前的父节点P和祖父节点G的颜色，结果的树满足性质4。性质5也仍然保持满足，因为通过这三个节点中任何一个的所有路径以前都通过祖父节点G，现在它们都通过以前的父节点P。在各自的情形下，这都是三个节点中唯一的黑色节点。
   * ![情形5示意图](https://upload.wikimedia.org/wikipedia/commons/6/66/Red-black_tree_insert_case_5.png)

   

   

   

   

   **红黑树删除**：

   

### 特色

* 位移运算加快计算速度
* 默认负载因子0.75兼顾时间和空间



## B+树

* 作者：孤独烟
* 链接：https://zhuanlan.zhihu.com/p/107228878
* 来源：知乎
* 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#### B+树的两个明显特点

1. 数据只出现在叶子节点
2. 所有叶子节点增加了一个链指针

#### 针对上面的B+树和B树的特点，我们做一个总结

**(1)**B树的树内存储数据，因此查询单条数据的时候，B树的查询效率不固定，最好的情况是O(1)。我们可以认为在做单一数据查询的时候，使用B树平均性能更好。但是，由于B树中各节点之间没有指针相邻，因此B树不适合做一些数据遍历操作。

**(2)**B+树的数据只出现在叶子节点上，因此在查询单条数据的时候，查询速度非常稳定。因此，在做单一数据的查询上，其平均性能并不如B树。但是，B+树的叶子节点上有指针进行相连，因此在做数据遍历的时候，只需要对叶子节点进行遍历即可，这个特性使得B+树非常适合做[范围查询](https://www.zhihu.com/search?q=范围查询&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"107228878"})。

​         因此，我们可以做一个推论:没准是Mysql中数据遍历操作比较多，所以用B+树作为索引结构。而Mongodb是做单一查询比较多，数据遍历操作比较少，所以用B树作为索引结构。

***那么为什么Mysql做数据遍历操作多？而Mongodb做数据遍历操作少呢？***

 因为Mysql是关系型数据库，而Mongodb是非关系型数据。

#### B+ Tree索引和Hash索引区别

* [哈希索引](https://www.zhihu.com/search?q=哈希索引&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"73204847"})适合等值查询，但是无法进行范围查询 
* 哈希索引没办法利用索引完成排序

* 哈希索引不支持多列联合索引的最左匹配规则
* 如果有大量重复键值得情况下，哈希索引的效率会很低，因为存在哈希碰撞问题

* 

## 跳表

利用多层索引机制，以空间换时间，查询Logn

**结点晋升机制**：

1. 新节点和各层索引节点逐一比较，确定原链表的插入位置。O（logN）
2. 把索引插入到原链表。O（1）
3. 利用抛硬币的随机方式，决定新节点是否提升为上一级索引。结果为“正”则提升并继续抛硬币，结果为“负”则停止。O（logN）

# 3布隆过滤器

作者：飞天小牛肉
链接：https://www.nowcoder.com/discuss/965563?source_id=profile_create_nctrack&channel=-1
来源：牛客网

现在想要实现一个网页过滤系统，利用该系统可以根据网页的 URL 判断该网页是否在黑名单上，黑名单现在已经包含 100 亿个不安全网页的 URL，每个网页的 URL 最多占用 64B（字节） 大小。

请设计该系统， 要求：

1. 该系统允许有万分之一以下的判断失误率 
2. 使用的额外空间不要超过 30GB

### 参考链接

* 详解布隆过滤器的原理，使用场景和注意事项 - 陈蔚澜的文章 - 知乎 https://zhuanlan.zhihu.com/p/43263751
* https://baike.baidu.com/item/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/5384697?fr=aladdin

### 思路

反向排除法，一定能判断不存在，不一定能判断存在

1. 定义一个长度为m的bitmap
2. 定义k个哈希函数
3. 计算上述url在k个哈希函数下的哈希值，将哈希值对应索引下的bitmap设置为1
4. 对于新来的url，要判断它是否已经存在，只需要计算这个url在k个哈希函数下的哈希值，然后查看bitmap中对应位置是否为1，如果都为1,说明该url可能存在，如果有一个为0，说明一定不存在

