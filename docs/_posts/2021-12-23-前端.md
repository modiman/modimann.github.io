# PageHelper分页

**使用PageHelper实现的分页，可以直接在地址栏中输入`http://localhost:8080/xxx?page=5&size=5`访问**

后续的页面跳转也是通过拼接出这样的字符串实现（全局刷新）

## 前端

```html
<table class="layui-table">
            <thead>
            <tr>
                <td>序号</td>
                <td>单词</td>
                <td>中文</td>
                <td>补充</td>
                <td>操作</td>
            </tr>
            </thead>
            <tbody>
            <tr th:each="word,stat:${pageInfo.list}">
                <td th:text="${word.getWid()}"></td>
                <td th:text="${word.getWname()}"></td>
                <td th:text="${word.getWmeaning()}"></td>
                <td th:text="${word.getWbuchong()}"></td>
            </tr>
            </tbody>
        </table>

<!--           跳转部分   >-->
<button class="layui-btn"><a th:href="@{/word-manage/pagehelper} " class="btn">首页</a></button>
        <button class="layui-btn"><a th:href="@{'/word-manage/pagehelper?page='+${pageInfo.getPrePage()}+'&size=4'} " class="btn">上一页</a></button>
  

        <button class="layui-btn"><a th:href="@{'/word-manage/pagehelper?page='+${pageInfo.getNextPage()}+'&size=4'}" >下一页</a></button>

        <button class="layui-btn"><a th:href="@{'/word-manage/pagehelper?page='+${pageInfo.getTotal()/4}+'&size=4'} " class="btn">末页</a></button>

        <button class="layui-btn" th:text="'当前为第'+${pageInfo.getPageNum()}+'页'" ></span></button>

```
## Controller

```java
@RequestMapping("/pagehelper")
public ModelAndView findAll(@RequestParam(name = "page",required = true,defaultValue = "1") int page,
                            @RequestParam(name = "size",required = true,defaultValue = "4") int size) throws Exception {
    ModelAndView mv=new ModelAndView("/word-manage/pagehelper");

    PageInfo pageInfo = wordService.findAllWordByPage(page,size);
    //PageInfo就是一个分页Bean

    mv.addObject("pageInfo",pageInfo);
    return mv;
}
```

## Service

```java
    PageInfo<Word>  findAllWordByPage(int pageNum, int pageSize);

```

### impl

```java
    @Override
    public PageInfo<Word> findAllWordByPage(int pageNum, int pageSize) {

        PageHelper.startPage(pageNum, pageSize);
        List<Word> lists = wordMapper.getAllWords();
        PageInfo<Word> pageInfo = new PageInfo<>(lists);
        return pageInfo;
    }
```

# Thymeleaf

## 循环numbers.sequence

```html
<option  th:each="pagenum:${#numbers.sequence(0,pageInfo.getTotal()/4)}" th:text="${pagenum}" th:value="${pagenum}"></option>
```

# 1. 选择器

## 1.1 .class	.intro	选择所有class="intro"的元素

* 例1：

```css
  .intro
      {
      background-color:yellow;
      }
```
* 例2：Style all p elements with class="hometown":  
```css
p.hometown
    {
      background-color:yellow;
    }
```
## 1.2 #firstname	选择所有id="firstname"的元素

* 例:为 id="firstname" 元素添加指定样式:  
  #firstname
  {
  background-color:yellow;
  }

## 1.3 选择所有<p>元素   

  例：


```css
 p
  { 
      background-color:yellow;
  }
```

# mybatis 参数

### 标签

![img](https://img-blog.csdn.net/20171128150418927?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzQwOTUwNzc4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

##  1. parameterType 

**输入参数  可以为java基本数据类型如Integer,String[]等，也可以是自定义的数据类型   **  


例1：

```mysql 
<select id="getTagByEmployee" parameterType="String" resultMap="tag_employee">       
        select *
        from tag
        where employee_id = #{employee_id}
</select> 
```

其中employee_id是函数的形参变量名  
对应接口函数：  
Tag getTagByEmployee(String employee_id);

### 例2：

```mysql
        <insert id="addTag" parameterType="Tag">  
        
        INSERT INTO `vishishtadvaita`.`tag`  
        
        (`id`, `last_known_x`, `last_known_y`, `name`, `last_known_area_id`, `isknown`, isonline, `type`, tag_employee)  
        
        VALUES (UUID(), #{lastKnownX}, #{lastKnownY}, #{name}, #{lastKnownArea.name}, #{isknown}, #{isonline}, #{type},  
        
        #{tagEmployee.employee_id});  
</insert>  
```

这里的parameType就是自定义的Tag型数据，包含name等属性，这种输入类型常用于插入和修改操作  

对应接口函数：

void addTag(Tag tag);  

## 2.  resultType
查询结果类型参数 resultType ,resultType可以包含java基本数据类型List等，也可以是自定义的数据类型，如之前的Tag

例1.  java基本数据类型String 这一类型常见于查询数据表中的某一列，比如查询tag表的属性（type）

```mysql
<select id="selectTagType" resultType="java.lang.String">
        
  SELECT DISTINCT `type`
  
  FROM tag
  
</select>
```

虽然其返回结果是一个由字符串String组成的List，但在resultType中写的是String而非List

对应的接口函数为：  List<String> selectTagType()
        

例2.自定义的数据类型Tag

  如果查询结果为一整张表或表的多个属性，不能像只查询一个属性那样用String就可以表示，resultType就要用与数据库表对应的实体类，也就是自定义

  的数据类型了

  首先要在命名空间标签中标注对应的数据类型，
```mysql
<mapper namespace="cn.edu.bjut.vishishtadvaita.mapper.mockloceng.TagMapper">
```
  之后再写查询语句

```mysql      
<select id="selectTags" resultMap="tag">
  
    select*
    
    from tag        

</select>
```

*  这里跟上例相同，虽然返回的结果是一个由Tag组成的标签，但resultType对应的仍然是tag
* 对应的接口函数：
* List<Tag> selectTags();

# 3. resultMap
查询结果类型参数 resultMap，这一参数扩大了数据库的可操作性，经常用于多表查询

使用resultMap是因为现有的数据类型不足以表示数据库查询结果，需要自定义返回值的数据类型 ，或者数据表中的属性名与自定义数据类型中属性名不同时

例如tag的name属性,在tag.java 中为 name,在数据表中却为tag_name,这时如果把返回值设置成resultType = "tag"，就会查不出结果       

例1. 多表查询

假设有Tag和Employee，Area三个实体类，三张表，Tag有外键tag_enployee用来表示tag 与employee之间一对一的关系
tag有外键last_known_area_id 用来表示与area之间一对一的关系

* 这里给出 Tag.java Employee.java  Area.java 以及三张表的建议表示
  Tag.java:

```Java
@Entity
@Table(name = "tag")
public class Tag extends BaseModel {
@Column(name = "name")
private String name;

@OneToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "tag_employee")
private Employee tagEmployee;

@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "last_known_area_id")
private Area lastKnownArea;}
```

tag表
id    name   tag_employee last_known_area_id  
首先从这里就可以看出查询tags时要用resultMap而非resultType的原因了，
即java类中的属性与数据表中对应的属性不同名

当只需要tag的信息时自然简单，但是有时候需要知道三张表之间对应的关系

比如想知道每个标签对应的员工是谁，属于哪个区域，这就需要三表连接查询，这样得到的结果既不能用tag,也不能用employee,area表示

因此需要用到reultMap. 下面给出三表连接查询的一个例子      

## 3.1. 首先 准备employee_as_member 和 area_as_member，注意这两个标签卸载其各自的.xml文件中而非tag.xml中

```mysql
<resultMap id="employee_as_member" type="Employee">
<id column="employee_id" property="employee_id"/>
<result column="employee_name" property="employee_name"/>
</resultMap>   
<resultMap id="area_as_member" type="Area">
<id column="area_id" property="id"/>
<result column="area_name" property="name"/>
</resultMap>
```

注意：column属性对应的是数据库表中的属性名，property对应的则是java类中的属性名  

在sql语句中用到的是column属性，例如select area_id 而非id

## 3.2. 写tag自己的resultMap

```mysql
<resultMap id="tag" type="Tag">
<id column="tag_id" property="id"/> 
<result column="tag_name" property="name"/> 

<association property="tagemployee"
               resultMap="cn.edu.bjut.vishishtadvaita.mapper.employee.EmployeeMapper.employee_as_member"/>
<association property="lastKnownArea"
            resultMap="cn.edu.bjut.vishishtadvaita.mapper.mockloceng.AreaMapper.area_as_member"/>
</resultMap>
```



注意：上述resultMap中涉及四个属性，分别是tag自身的id、name以及外键tagemployee,lastKnownArea(对应tag.java中的tagEmployee和tagEmployee)


resultMap="cn.edu.bjut.vishishtadvaita.mapper.mockloceng.AreaMapper.area_as_member"则对应第一步写的两个标签



## 3.3. 查询语句

```mysql
<select id="selectTagsAndEmployee" resultMap="tag_employee">
SELECT  * FROM
(SELECT tag.id AS tag_id,

    tag.name AS tag_name,

    employee.employee_name AS employee_name,
    employee.employee_id AS employee_id
        FROM tag
        LEFT JOIN employee ON employee.employee_id = tag.tag_employee) AS t1
LEFT JOIN (SELECT area.id AS area_id,area.name AS area_name,  FROM `area`)AS t2 ON t1.last_known_area_id = t2.area_id

    </select>
```

注意：这里的select tag.name AS tag_name和SELECT area.id AS area_id等是有必要的，不把area.id表示为数据表中的area_id查询不到结果

# Vue+ElementUI

* 2022-6-28

## 根据进度条控制svg

```vue
<template>
 	<div style="text-align:center;position:relative;">
        <svg :width="svgWidth" :height="svgHeight" style="margin-left:100px;margin-bottom:-40px;" id="svg1">		</svg>
        <el-slider id="jjj"
                   v-model="svgProgress"
                   show-input
                   style="width: 500px"
        >
        </el-slider>
    </div>
</template>
<script>
    import * as d3 from 'd3'
    import $ from 'jquery'

    const axios = require('axios');

    // const axios = require('axios')


    export default {

        data() {
            return {
                svgHeight: 660,
                svgWidth: 960,
                svgProgress: 50
            }
        }
    },
    //监听进度条变化
    watch: {
            svgProgress() {

                this.svgHeight = 660 + this.svgProgress - 50;
                this.svgWidth = 960 + this.svgProgress - 50;


            }

        }

</script>

```

## vue部署

需要注意的是如果vue项目中有ajax请求，需要将路径改为相对路径

**命令行输入**

```
npm run build
```

项目主目录下出现一个名为dist的文件夹

### 方式一 nginx

将dist直接放在nginx的html目录下，一般路径为`/usr/shared/nginx/html/dist`

### 方式二 SpringBoot

直接将dist下的所有文件放到SpringBoot项目的static文件夹中即可



3. 

## 侧边栏根据页面高亮

​        注意到layui侧边栏的高亮是通过`class="layui-nav-item layui-this"`实现的，给每个侧边栏设置一个特定的id，在页面内使用setAttribute方法给该页面对应的li标签设置高亮

```javascript
 document.getElementById("user").setAttribute("class","layui-nav-item layui-this");
```

该语句要出现在标签的下方，否则无法找到
