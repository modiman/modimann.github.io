## [155. 最小栈](https://leetcode-cn.com/problems/min-stack/)

设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

```push(x)``` —— 将元素 x 推入栈中。
```pop() ```—— 删除栈顶的元素。
```top() ```—— 获取栈顶元素。
```getMin()``` —— 检索栈中的最小元素。

示例:

```
输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```

### 思路

* 使用两个栈，一个stackData存放数据，另一个stackMin存放当前时刻数据栈最小值

### 入栈规则

对于新数据val

* 如果stackMin为空，val入栈，否则比较val与stackMin栈顶元素，如果val更小或者相等，val入stackMin，这样能保证stackMin的栈顶元素永远是数据栈最小值，**相等也入栈是为了处理重复的最小值**
* val入stackData

### 出栈规则

* val==stackMin.peek

### 代码

```java
class MinStack {
    private Stack<Integer> stackData;
    private Stack<Integer> stackMin;


    public MinStack() {
        this.stackData = new Stack<Integer>();
        this.stackMin = new Stack<Integer>();
    }
    
    public void push(int val) {
        if (this.stackMin.isEmpty()){
            this.stackMin.push(val);
        }
        else if(val <= this.getMin()){
             this.stackMin.push(val);

        }
        this.stackData.push(val);

    }
    
    public void pop() {
        if(this.stackData.isEmpty()){
            throw new RuntimeException("Empty");
        }
        int val = this.stackData.pop();
        if (val == this.getMin()){
            this.stackMin.pop();
        }

    }
    
    public int top() {
        return stackData.peek();

    }
    
    public int getMin() {
        if(this.stackMin.isEmpty()){
            throw new RuntimeException("Empty");
        }
        return this.stackMin.peek();


    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(val);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
```

#### [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)

难度简单512收藏分享切换为英文接收动态反馈

请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（`push`、`pop`、`peek`、`empty`）：

实现 `MyQueue` 类：

- `void push(int x)` 将元素 x 推到队列的末尾
- `int pop()` 从队列的开头移除并返回元素
- `int peek()` 返回队列开头的元素
- `boolean empty()` 如果队列为空，返回 `true` ；否则，返回 `false`

 

**说明：**

- 你只能使用标准的栈操作 —— 也就是只有 `push to top`, `peek/pop from top`, `size`, 和 `is empty` 操作是合法的。
- 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。

 

**进阶：**

- 你能否实现每个操作均摊时间复杂度为 `O(1)` 的队列？换句话说，执行 `n` 个操作的总时间复杂度为 `O(n)` ，即使其中一个操作可能花费较长时间。

 

**示例：**

```
输入：
["MyQueue", "push", "push", "peek", "pop", "empty"]
[[], [1], [2], [], [], []]
输出：
[null, null, null, 1, 1, false]

解释：
MyQueue myQueue = new MyQueue();
myQueue.push(1); // queue is: [1]
myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)
myQueue.peek(); // return 1
myQueue.pop(); // return 1, queue is [2]
myQueue.empty(); // return false
```

### 思路

* 准备两个栈stackPush ，stackPop
* 当需要push时，将数据压入stackPush
* 当需要pop时，为了将数逆序处理，全部弹出到stackPop,此时stackPop中数的顺序即为先进的在栈顶，符合队列的先进先出
* 当需要peek时，与pop做相同处理
* 当stackPush与stackPop都为空时，队列为空

### 代码

```java
class MyQueue {
    private Stack<Integer> stackPush;
    private Stack<Integer> stackPop;

    public MyQueue() {
        stackPush = new Stack<Integer> ();
        stackPop = new Stack<Integer>() ;
    }
    
    public void push(int x) {
        stackPush.push(x);

    }
    
    public int pop() {
        if (stackPush.empty()&&stackPop.empty()){
            throw new RuntimeException("Empty");
        }
        else if(stackPop.empty()){
            while(!stackPush.empty()){
                stackPop.push(stackPush.pop());
            }
            
        }
        return stackPop.pop();
    }
    
    public int peek() {
        if (stackPush.empty()&&stackPop.empty()){
            throw new RuntimeException("Empty");
        }
        else if(stackPop.empty()){
            while(!stackPush.empty()){
                stackPop.push(stackPush.pop());
            }
            
        }
        return stackPop.peek();

    }
    
    public boolean empty() {
        return stackPop.empty()&&stackPush.empty();
    }
}

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue obj = new MyQueue();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.peek();
 * boolean param_4 = obj.empty();
 */
```

#### [面试题 03.05. 栈排序](https://leetcode-cn.com/problems/sort-of-stacks-lcci/)

难度中等46收藏分享切换为英文接收动态反馈

栈排序。 编写程序，对栈进行排序使最小元素位于栈顶。最多只能使用一个其他的临时栈存放数据，但不得将元素复制到别的数据结构（如数组）中。该栈支持如下操作：`push`、`pop`、`peek` 和 `isEmpty`。当栈为空时，`peek` 返回 -1。

**示例1:**

```
 输入：
["SortedStack", "push", "push", "peek", "pop", "peek"]
[[], [1], [2], [], [], []]
 输出：
[null,null,null,1,null,2]
```

**示例2:**

```
 输入： 
["SortedStack", "pop", "pop", "push", "pop", "isEmpty"]
[[], [], [], [1], [], []]
 输出：
[null,null,null,null,null,true]
```

**说明:**

1. 栈中的元素数目在[0, 5000]范围内。

### 思路

* 两个栈，一个数据栈stack，一个临时栈assist
* **保证任意时刻数据栈中的数字从上到下非递减**
* 如果新来的数字大于数据栈栈顶元素，数据栈出站，放到临时栈，直到数据栈栈顶元素不大于新来的元素
* 新元素入数据栈
* 将临时栈中元素弹出到数据栈中

### 代码

```java
class SortedStack {
    private Stack<Integer> stack;
    private Stack<Integer> assist;


    public SortedStack() {
        stack = new Stack<>();
        assist = new Stack<>();
    }

    public void push(int val) {
        while (!stack.empty()){
            if (val>stack.peek()){
                assist.push(stack.pop());
            }
            else break;
        }
        stack.push(val);
        while (!assist.empty()){
            stack.push(assist.pop());
        }
    }

    public void pop() {
        if (!stack.empty())  stack.pop();
        else return;
    }

    public int peek() {
        if (!stack.empty())       return stack.peek();
         else return -1;
    }

    public boolean isEmpty() {
        return stack.empty()&&assist.empty();
    }
}
```

#### [剑指 Offer 59 - I. 滑动窗口的最大值](https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/)

难度困难346收藏分享切换为英文接收动态反馈

给定一个数组 `nums` 和滑动窗口的大小 `k`，请找出所有滑动窗口里的最大值。

**示例:**

```
输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7] 
解释: 

  滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

 

**提示：**

你可以假设 *k* 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。

注意：本题与主站 239 题相同：https://leetcode-cn.com/problems/sliding-window-maximum/

### 思路

**维护一个双端队列qmax，队列用来存放数组元素的下标,它需要满足以下条件**

1. 队内元素都在窗口中
2. 以队首元素为下标的数组元素为当前窗口最大值
3. 以队列中元素为下标的数组从队首到队尾满足递减

之后做如下处理

* 当队首下标等于当前遍历元素下标-窗口大小时，队首下标已被滑出窗口，需要将队首元素移出队列
* 当遍历到i-w,时，窗口已经形成，每次遍历需要将队首元素指向的数字放入结果数组中，表示当前小窗口最大值

### 思考

* 为什么双端队列存放的是数组下标而非数字本身？

无法知道队内元素的下标，也就无法判断是否还在窗口内

### 代码

```java
public class MaxSlidingWindow {

    public int[] maxSlidingWindow(int[] nums, int k) {
        if(nums == null || k<1 || nums.length<k){
            return null;
        }
        LinkedList<Integer> qmax = new LinkedList();
        int []res = new int[nums.length-k+1];
        int index  = 0;
        for (int i=0;i<nums.length;i++){
            /**
             * 以队中元素为下标的数字需要保证比即将要来的数字大，不然无法保证队中只存放极大元素的下标
             * 因为双端队列qmax中存放的是窗口最大或候补最大元素下标，此时来了个更大的数，那qmax中比此数小的数字都没希望了

             * 换句话说，双端队列中从队头到队尾是递减的
             */
            while (!qmax.isEmpty() && nums[qmax.peekLast()]<=nums[i]){
                qmax.pollLast();
        }
            /**
             * 在上一步的作用下，此时来的下标必定是队中最大的数字的下标
             */
            qmax.addLast(i);

            /**
             * 当前最大值出窗口后要及时清理出qmax
             * 比如当前来到了i=3，即第四个元素，但队首（即窗口最大值下标）为3-3=0，
             * 此时下标为0的数字已经不在窗口中，需要清理
             */
            if(qmax.peekFirst() == i-k){
                qmax.pollFirst();
            }
            /**
             *  //当窗口装满后开始向结果数组中输入当前窗口最大值
             *  //当前窗口最大值的下标为双端队列qmax的队首
             */
            if(i>=k-1){
                res[index++] = nums[qmax.peekFirst()];
            }
        }
        return res;
    }
}

```



## MaxTree

```java
package com.example.book.leetcode;

import java.util.HashMap;
import java.util.Stack;

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class MaxTree{
   class TreeNode {
     int val;
      TreeNode left;
      TreeNode right;
      TreeNode() {}
      TreeNode(int val) { this.val = val; }
      TreeNode(int val, TreeNode left, TreeNode right) {
          this.val = val;
          this.left = left;
          this.right = right;
      }
  }


    public TreeNode constructMaximumBinaryTree(int[] nums) {

        TreeNode []nArr = new TreeNode[nums.length];
        //将数字数组初始化为结点数组
        for (int i=0;i<nums.length;i++){
            nArr[i] = new TreeNode(nums[i]);
        }

        Stack<TreeNode> stack = new Stack<>();
        //存放（结点-左边第一个比它大的结点）键值对
        HashMap<TreeNode,TreeNode> lBigMap = new HashMap<>();
        //存放（结点-右边第一个比它大的结点）键值对
        HashMap<TreeNode,TreeNode> rBigMap = new HashMap<>();

        for(int i=0;i!=nArr.length;i++){
            //遍历数组，找到每个结点左边第一个比它大的数
            //同时要维持栈中元素从顶到底递减
            TreeNode curNode = nArr[i];
            while((!stack.isEmpty()) && stack.peek().val <curNode.val){
                popStackSetMap(stack,lBigMap);
            }
            stack.push(curNode);
        }
        //保证每个元素都遍历到
        while(!stack.isEmpty()){
            popStackSetMap(stack,lBigMap);
        }
        //从右到左进行同样的操作
        for(int i=nArr.length-1;i>=0;i--){
            TreeNode curNode = nArr[i];
            while((!stack.isEmpty()) && stack.peek().val <curNode.val){
                popStackSetMap(stack,rBigMap);
            }
            stack.push(curNode);
        }
        while(!stack.isEmpty()){
            popStackSetMap(stack,rBigMap);
        }

        //二叉树的建立

        TreeNode head = null;
        for(int i=0;i<nArr.length;i++){
            TreeNode curNode = nArr[i];
            TreeNode left = lBigMap.get(curNode);
            TreeNode right = rBigMap.get(curNode);
            if(left==null && right==null)//左右没有比它大的数
            {
                head = curNode;
            }
            else if(left==null){//左边没有更大的数
                if(right.left==null){//没有左子树就放左子树上
                    right.left = curNode;
                }
                else{//否则放在右子树上
                    right.right = curNode;
                }
            }
            else if(right==null){//左边没有更大的数
                if(left.left==null){//没有左子树就放左子树上
                    left.left = curNode;
                }
                else{//否则放在右子树上
                    left.right = curNode;
                }
            }


            else{
                TreeNode parent = left.val <right.val? left:right;

                if(parent.left == null){
                    parent.left=curNode;
                }
                else{
                    parent.right=curNode;
                }
            }

        }
        return head;

    }




    public void popStackSetMap(Stack<TreeNode> stack,HashMap<TreeNode,TreeNode> map){
        TreeNode popNode = stack.pop();
        //如果栈空了，说明左边/右边没有比它大的数
        if(stack.isEmpty()){
            map.put(popNode,null);
        }
        //否则，栈顶就是离它最近的比它大的数
        else{
            map.put(popNode,stack.peek());
        }
    }
}
```





