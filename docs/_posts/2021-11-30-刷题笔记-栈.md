

# 栈

## [155. 最小栈](https://leetcode-cn.com/problems/min-stack/)

设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

```push(x)``` —— 将元素 x 推入栈中。
```pop() ```—— 删除栈顶的元素。
```top() ```—— 获取栈顶元素。
```getMin()``` —— 检索栈中的最小元素。

示例:

```
输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```

**思路**

* 使用两个栈，一个stackData存放数据，另一个stackMin存放当前时刻数据栈最小值

**入栈规则**

对于新数据val

* 如果stackMin为空，val入栈，否则比较val与stackMin栈顶元素，如果val更小或者相等，val入stackMin，这样能保证stackMin的栈顶元素永远是数据栈最小值，**相等也入栈是为了处理重复的最小值**
* val入stackData

**出栈规则**

* val==stackMin.peek

**代码**

```java
class MinStack {
    private Stack<Integer> stackData;
    private Stack<Integer> stackMin;


    public MinStack() {
        this.stackData = new Stack<Integer>();
        this.stackMin = new Stack<Integer>();
    }
    
    public void push(int val) {
        if (this.stackMin.isEmpty()){
            this.stackMin.push(val);
        }
        else if(val <= this.getMin()){
             this.stackMin.push(val);

        }
        this.stackData.push(val);

    }
    
    public void pop() {
        if(this.stackData.isEmpty()){
            throw new RuntimeException("Empty");
        }
        int val = this.stackData.pop();
        if (val == this.getMin()){
            this.stackMin.pop();
        }

    }
    
    public int top() {
        return stackData.peek();

    }
    
    public int getMin() {
        if(this.stackMin.isEmpty()){
            throw new RuntimeException("Empty");
        }
        return this.stackMin.peek();


    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(val);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
```

## [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)

难度简单512收藏分享切换为英文接收动态反馈

请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（`push`、`pop`、`peek`、`empty`）：

实现 `MyQueue` 类：

- `void push(int x)` 将元素 x 推到队列的末尾
- `int pop()` 从队列的开头移除并返回元素
- `int peek()` 返回队列开头的元素
- `boolean empty()` 如果队列为空，返回 `true` ；否则，返回 `false`

 

**说明：**

- 你只能使用标准的栈操作 —— 也就是只有 `push to top`, `peek/pop from top`, `size`, 和 `is empty` 操作是合法的。
- 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。

 

**进阶：**

- 你能否实现每个操作均摊时间复杂度为 `O(1)` 的队列？换句话说，执行 `n` 个操作的总时间复杂度为 `O(n)` ，即使其中一个操作可能花费较长时间。

 

**示例：**

```
输入：
["MyQueue", "push", "push", "peek", "pop", "empty"]
[[], [1], [2], [], [], []]
输出：
[null, null, null, 1, 1, false]

解释：
MyQueue myQueue = new MyQueue();
myQueue.push(1); // queue is: [1]
myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)
myQueue.peek(); // return 1
myQueue.pop(); // return 1, queue is [2]
myQueue.empty(); // return false
```

**思路**

* 准备两个栈stackPush ，stackPop
* 当需要push时，将数据压入stackPush
* 当需要pop时，为了将数逆序处理，全部弹出到stackPop,此时stackPop中数的顺序即为先进的在栈顶，符合队列的先进先出
* 当需要peek时，与pop做相同处理
* 当stackPush与stackPop都为空时，队列为空

**代码**

```java
class MyQueue {
    private Stack<Integer> stackPush;
    private Stack<Integer> stackPop;

    public MyQueue() {
        stackPush = new Stack<Integer> ();
        stackPop = new Stack<Integer>() ;
    }
    
    public void push(int x) {
        stackPush.push(x);

    }
    
    public int pop() {
        if (stackPush.empty()&&stackPop.empty()){
            throw new RuntimeException("Empty");
        }
        else if(stackPop.empty()){
            while(!stackPush.empty()){
                stackPop.push(stackPush.pop());
            }
            
        }
        return stackPop.pop();
    }
    
    public int peek() {
        if (stackPush.empty()&&stackPop.empty()){
            throw new RuntimeException("Empty");
        }
        else if(stackPop.empty()){
            while(!stackPush.empty()){
                stackPop.push(stackPush.pop());
            }
            
        }
        return stackPop.peek();

    }
    
    public boolean empty() {
        return stackPop.empty()&&stackPush.empty();
    }
}

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue obj = new MyQueue();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.peek();
 * boolean param_4 = obj.empty();
 */
```

## [面试题 03.05. 栈排序](https://leetcode-cn.com/problems/sort-of-stacks-lcci/)

难度中等46收藏分享切换为英文接收动态反馈

栈排序。 编写程序，对栈进行排序使最小元素位于栈顶。最多只能使用一个其他的临时栈存放数据，但不得将元素复制到别的数据结构（如数组）中。该栈支持如下操作：`push`、`pop`、`peek` 和 `isEmpty`。当栈为空时，`peek` 返回 -1。

**示例1:**

```
 输入：
["SortedStack", "push", "push", "peek", "pop", "peek"]
[[], [1], [2], [], [], []]
 输出：
[null,null,null,1,null,2]
```

**示例2:**

```
 输入： 
["SortedStack", "pop", "pop", "push", "pop", "isEmpty"]
[[], [], [], [1], [], []]
 输出：
[null,null,null,null,null,true]
```

**说明:**

1. 栈中的元素数目在[0, 5000]范围内。

**思路**

* 两个栈，一个数据栈stack，一个临时栈assist
* **保证任意时刻数据栈中的数字从上到下非递减**
* 如果新来的数字大于数据栈栈顶元素，数据栈出站，放到临时栈，直到数据栈栈顶元素不大于新来的元素
* 新元素入数据栈
* 将临时栈中元素弹出到数据栈中

**代码**

```java
class SortedStack {
    private Stack<Integer> stack;
    private Stack<Integer> assist;


    public SortedStack() {
        stack = new Stack<>();
        assist = new Stack<>();
    }

    public void push(int val) {
        while (!stack.empty()){
            if (val>stack.peek()){
                assist.push(stack.pop());
            }
            else break;
        }
        stack.push(val);
        while (!assist.empty()){
            stack.push(assist.pop());
        }
    }

    public void pop() {
        if (!stack.empty())  stack.pop();
        else return;
    }

    public int peek() {
        if (!stack.empty())       return stack.peek();
         else return -1;
    }

    public boolean isEmpty() {
        return stack.empty()&&assist.empty();
    }
}
```

## [滑动窗口的最大值](https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/)

难度困难346收藏分享切换为英文接收动态反馈

给定一个数组 `nums` 和滑动窗口的大小 `k`，请找出所有滑动窗口里的最大值。

**示例:**

```
输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7] 
解释: 

  滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

 

**提示：**

你可以假设 *k* 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。

注意：本题与主站 239 题相同：https://leetcode-cn.com/problems/sliding-window-maximum/

**思路**

**维护一个双端队列qmax，队列用来存放数组元素的下标,它需要满足以下条件**

1. 队内元素都在窗口中
2. 以队首元素为下标的数组元素为当前窗口最大值
3. 以队列中元素为下标的数组从队首到队尾满足递减

之后做如下处理

* 当队首下标等于当前遍历元素下标-窗口大小时，队首下标已被滑出窗口，需要将队首元素移出队列
* 当遍历到i-w,时，窗口已经形成，每次遍历需要将队首元素指向的数字放入结果数组中，表示当前小窗口最大值

**思考**

* 为什么双端队列存放的是数组下标而非数字本身？

无法知道队内元素的下标，也就无法判断是否还在窗口内

**代码**

```java
public class MaxSlidingWindow {

    public int[] maxSlidingWindow(int[] nums, int k) {
        if(nums == null || k<1 || nums.length<k){
            return null;
        }
        LinkedList<Integer> qmax = new LinkedList();
        int []res = new int[nums.length-k+1];
        int index  = 0;
        for (int i=0;i<nums.length;i++){
            /**
             * 以队中元素为下标的数字需要保证比即将要来的数字大，不然无法保证队中只存放极大元素的下标
             * 因为双端队列qmax中存放的是窗口最大或候补最大元素下标，此时来了个更大的数，那qmax中比此数小的数字都没希望了

             * 换句话说，双端队列中从队头到队尾是递减的
             */
            while (!qmax.isEmpty() && nums[qmax.peekLast()]<=nums[i]){
                qmax.pollLast();
        }
            /**
             * 在上一步的作用下，此时来的下标必定是队中最大的数字的下标
             */
            qmax.addLast(i);

            /**
             * 当前最大值出窗口后要及时清理出qmax
             * 比如当前来到了i=3，即第四个元素，但队首（即窗口最大值下标）为3-3=0，
             * 此时下标为0的数字已经不在窗口中，需要清理
             */
            if(qmax.peekFirst() == i-k){
                qmax.pollFirst();
            }
            /**
             *  //当窗口装满后开始向结果数组中输入当前窗口最大值
             *  //当前窗口最大值的下标为双端队列qmax的队首
             */
            if(i>=k-1){
                res[index++] = nums[qmax.peekFirst()];
            }
        }
        return res;
    }
}

```



## MaxTree

```java
package com.example.book.leetcode;

import java.util.HashMap;
import java.util.Stack;

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class MaxTree{
   class TreeNode {
     int val;
      TreeNode left;
      TreeNode right;
      TreeNode() {}
      TreeNode(int val) { this.val = val; }
      TreeNode(int val, TreeNode left, TreeNode right) {
          this.val = val;
          this.left = left;
          this.right = right;
      }
  }


    public TreeNode constructMaximumBinaryTree(int[] nums) {

        TreeNode []nArr = new TreeNode[nums.length];
        //将数字数组初始化为结点数组
        for (int i=0;i<nums.length;i++){
            nArr[i] = new TreeNode(nums[i]);
        }

        Stack<TreeNode> stack = new Stack<>();
        //存放（结点-左边第一个比它大的结点）键值对
        HashMap<TreeNode,TreeNode> lBigMap = new HashMap<>();
        //存放（结点-右边第一个比它大的结点）键值对
        HashMap<TreeNode,TreeNode> rBigMap = new HashMap<>();

        for(int i=0;i!=nArr.length;i++){
            //遍历数组，找到每个结点左边第一个比它大的数
            //同时要维持栈中元素从顶到底递减
            TreeNode curNode = nArr[i];
            while((!stack.isEmpty()) && stack.peek().val <curNode.val){
                popStackSetMap(stack,lBigMap);
            }
            stack.push(curNode);
        }
        //保证每个元素都遍历到
        while(!stack.isEmpty()){
            popStackSetMap(stack,lBigMap);
        }
        //从右到左进行同样的操作
        for(int i=nArr.length-1;i>=0;i--){
            TreeNode curNode = nArr[i];
            while((!stack.isEmpty()) && stack.peek().val <curNode.val){
                popStackSetMap(stack,rBigMap);
            }
            stack.push(curNode);
        }
        while(!stack.isEmpty()){
            popStackSetMap(stack,rBigMap);
        }

        //二叉树的建立

        TreeNode head = null;
        for(int i=0;i<nArr.length;i++){
            TreeNode curNode = nArr[i];
            TreeNode left = lBigMap.get(curNode);
            TreeNode right = rBigMap.get(curNode);
            if(left==null && right==null)//左右没有比它大的数
            {
                head = curNode;
            }
            else if(left==null){//左边没有更大的数
                if(right.left==null){//没有左子树就放左子树上
                    right.left = curNode;
                }
                else{//否则放在右子树上
                    right.right = curNode;
                }
            }
            else if(right==null){//左边没有更大的数
                if(left.left==null){//没有左子树就放左子树上
                    left.left = curNode;
                }
                else{//否则放在右子树上
                    left.right = curNode;
                }
            }


            else{
                TreeNode parent = left.val <right.val? left:right;

                if(parent.left == null){
                    parent.left=curNode;
                }
                else{
                    parent.right=curNode;
                }
            }

        }
        return head;

    }




    public void popStackSetMap(Stack<TreeNode> stack,HashMap<TreeNode,TreeNode> map){
        TreeNode popNode = stack.pop();
        //如果栈空了，说明左边/右边没有比它大的数
        if(stack.isEmpty()){
            map.put(popNode,null);
        }
        //否则，栈顶就是离它最近的比它大的数
        else{
            map.put(popNode,stack.peek());
        }
    }
}
```



# 链表



## 递归处理链表

2. 两数相加
   给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

 

示例 1：


输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
示例 2：

输入：l1 = [0], l2 = [0]
输出：[0]
示例 3：

输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]


提示：

每个链表中的节点数在范围 [1, 100] 内
0 <= Node.val <= 9
题目数据保证列表表示的数字不含前导零

**思路**

原地相加，相加后的结果存放在l1，最后返回l1

1. 如果当前l1和l2都是尾结点
   * 如果存在进位，新增一个结点添加到l1末尾，val为1
   * 如果不存在进位，直接返回

2. 如果只有l2是末尾结点
   * 如果存在进位，继续处理l1.next,l2尾结点置为0，不移动
   * 如果不存在进位，直接返回
3. 如果只有l1是末尾结点
   * 将l2的后续结点接到l1上
   * 如果存在进位，继续处理l1.next,l2尾结点置为0，不移动
   * 如果不存在进位，直接返回   
4. 两个都不是尾结点，计算之后集体后移，继续处理

**代码**

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode p1 = l1,p2 = l2;
        int flag = 0;
        addN(l1,l2,0);
        return l1; 
    }
    public void addN(ListNode l1,ListNode l2,int flag){
        int currentFlag = flag;
        flag  = (l1.val + l2.val + currentFlag)>9?1:0;
        l1.val = (l1.val + l2.val + currentFlag) % 10;

        if(l1.next==null && l2.next==null){
            if(flag!=0){
                ListNode l = new ListNode();
                l.next = null;
                l.val = flag;
                l1.next = l;
            }
        }
        else if(l1.next==null){
            l1.next = l2.next;
            if(flag==0) return ;
            l2.val = 0;
            l2.next = null;
            addN(l1.next,l2,flag);
            }

        else if(l2.next==null){
            if(flag==0) return;
            l2.val = 0;
            addN(l1.next,l2,flag);

        }
        else{
            addN(l1.next,l2.next,flag);
        }
        
    }
}
```

**递归边界条件**

## [反转链表](https://leetcode-cn.com/problems/UHnkqh/)

难度简单34

给定单链表的头节点 `head` ，请反转链表，并返回反转后的链表的头节点。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)

```
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg)

**思路**

* 准备两个中间变量next和pre
* next永远指向原始链表中头结点的后一个节点，目的是记录原始链表位置
* pre永远指向新链表头节点，目的是记录新链表位置
* 新链表的构造采用**头插法**

**代码**

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        
        ListNode pre = null;
        ListNode next = null;
        while(head!=null){
            next = head.next;
            head.next = pre;
            pre = head;
            head = next;
        }
        return pre;

    }
}
```



## [92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

难度中等1092

给你单链表的头指针 `head` 和两个整数 `left` 和 `right` ，其中 `left <= right` 。请你反转从位置 `left` 到位置 `right` 的链表节点，返回 **反转后的链表** 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg)

```
输入：head = [1,2,3,4,5], left = 2, right = 4
输出：[1,4,3,2,5]
```

**示例 2：**

```
输入：head = [5], left = 1, right = 1
输出：[5]
```

 

**提示：**

- 链表中节点数目为 `n`
- `1 <= n <= 500`
- `-500 <= Node.val <= 500`
- `1 <= left <= right <= n`

**思路**

* 用leftpre记录left的前一个节点，用rightnext记录right的下一个节点

* 切割链表，将待翻转的部分独立处理

* 切割的方法是将leftpre和right指向null

      ```java
      leftpre.next = null;
      rightnode.next = null;
      ```

* 重新连接被反转后的链表

```java
leftpre.next = right;
rightnode.next = rightnext;
```

* 为了避免判断链表边界，以便确定leftpre的位置，定义一个虚拟头结点,这个节点永远指向链表头节点

```java
ListNode leftpre = new ListNode(-1);
leftpre.next = head;
```

* 这个虚拟头结点的位置也需要记录下来，作为最后的返回值
* 待翻转链表部分的结尾不必记录，反转之后的leftnode就是尾节点，rightnode则是头结点
* **如果把头结点位置记录下来作为返回值会出错，因为如果头结点包含在待翻转的部分，再返回这一节点有可能不是完整的原链表**

**代码**

```java
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        
        ListNode list = head;
        //添加一个虚拟头结点，避免边界判断

        ListNode leftpre = new ListNode(-1);
      
        leftpre.next = head;
        ListNode res = leftpre;
        //找到left的前面一个节点
        for(int i=1;i<left;i++){
            leftpre = leftpre.next;
        }
        //记录开始节点
        ListNode leftnode = leftpre.next;
        ListNode rightnode = leftpre;
        //寻找结束节点
        for(int i=0;i<right-left+1;i++){
            rightnode = rightnode.next;
        }

        ListNode rightnext = rightnode.next;
        
        //切断联系,将待反转的部分独立出来
        rightnode.next = null;
        leftpre.next = null;

        reverseList(leftnode);
        //接回链表
        leftpre.next = rightnode;
        leftnode.next = rightnext;
        return res.next;
    }

    void reverseList(ListNode head){

        ListNode pre = null;
        ListNode cur = head;
        while(cur!=null){
            ListNode next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
    }
}
```

## [剑指 Offer II 027. 回文链表](https://leetcode-cn.com/problems/aMhZSa/)

难度简单19

给定一个链表的 **头节点** `head` **，**请判断其是否为回文链表。

如果一个链表是回文，那么链表节点序列从前往后看和从后往前看是相同的。

 

**示例 1：**

**![img](https://github.com/modiman/modiman.github.io/blob/gh-pages/docs/_posts/imgs/1626421737-LjXceN-image.png?raw=true)**

```
输入: head = [1,2,3,3,2,1]
输出: true
```

**示例 2：**

**![img](https://github.com/modiman/modiman.github.io/blob/gh-pages/docs/_posts/imgs/1626422231-wgvnWh-image.png?raw=true)**

```
输入: head = [1,2]
输出: false
```

 

**提示：**

- 链表 L 的长度范围为 `[1, 105]`
- `0 <= node.val <= 9`

**思路**

* 快慢指针找到链表的中间节点（若为偶数则定为左边最后一个）
* 将链表右半部分逆置
* 比较左右两部分是否完全相同
* 恢复链表
* 返回结果

**代码**

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public boolean isPalindrome(ListNode head) {

        //将链表后半部分逆置后与前半部分比较
        if(head.next==null) return true;
        ListNode fast=head,slow=head;
        int len = 1;
        //快慢指针查找链表中间节点
        //快指针走两步慢指针走一步
        //快指针走不满两步说明链表长度为偶数，慢指针停在左半部分最后一位
        while(fast.next!=null&&fast.next.next!=null){
               fast = fast.next.next;
               slow = slow.next;
        }
        //记录右半部分第一位，即左半部分最后一位的后一位    
        ListNode right= slow.next;
        //将左右两部分切割
        slow.next = null;

        //ListNode pre = null;
        ListNode next = null;

        //翻转右半部分，反转后的头结点指向左半部分最后一位
        while(right!=null){
            next = right.next;
            right.next =slow;
            slow = right;
            right = next;

        }

        next = slow;
        right = head;
        boolean res = true;
        while(slow!=null&&right!=null){
            if(slow.val!=right.val){
                res = false;
                break;
            }
            slow = slow.next;
            right = right.next;
        }

//回复链表
        slow = next;
        next.next = null;

        
        while(slow!=null){
            right = slow.next;
            slow.next = next;
            next = slow;
            slow = right;
        }
        return res;

    }
}
```

## [138. 复制带随机指针的链表](https://leetcode-cn.com/problems/copy-list-with-random-pointer/)

难度中等

给你一个长度为 `n` 的链表，每个节点包含一个额外增加的随机指针 `random` ，该指针可以指向链表中的任何节点或空节点。

构造这个链表的 **[深拷贝](https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin)**。 深拷贝应该正好由 `n` 个 **全新** 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 `next` 指针和 `random` 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。**复制链表中的指针都不应指向原链表中的节点** 。

例如，如果原链表中有 `X` 和 `Y` 两个节点，其中 `X.random --> Y` 。那么在复制链表中对应的两个节点 `x` 和 `y` ，同样有 `x.random --> y` 。

返回复制链表的头节点。

用一个由 `n` 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 `[val, random_index]` 表示：

- `val`：一个表示 `Node.val` 的整数。
- `random_index`：随机指针指向的节点索引（范围从 `0` 到 `n-1`）；如果不指向任何节点，则为 `null` 。

你的代码 **只** 接受原链表的头节点 `head` 作为传入参数。

 

**示例 1：**

![img](https://github.com/modiman/modiman.github.io/blob/gh-pages/docs/_posts/imgs/e1.png?raw=true)

```
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
```

**示例 2：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e2.png)

```
输入：head = [[1,1],[2,1]]
输出：[[1,1],[2,1]]
```

**示例 3：**

**![img](https://github.com/modiman/modiman.github.io/blob/gh-pages/docs/_posts/imgs/e3.png/?raw=true)**

```
输入：head = [[3,null],[3,0],[3,null]]
输出：[[3,null],[3,0],[3,null]]
```

**示例 4：**

```
输入：head = []
输出：[]
解释：给定的链表为空（空指针），因此返回 null。
```

 

**提示：**

- `0 <= n <= 1000`
- `-10000 <= Node.val <= 10000`
- `Node.random` 为空（null）或指向链表中的节点。

**思路（方法一）**

空间复杂度：O(N) ，一个哈希表；  时间复杂度O（N）两次遍历

* 第一次遍历，引入一个哈希表，存放新旧节点的对应关系，新生成的节点next和random指针指向null
* 第二次遍历，穿针引线，将新生成的节点连接起来

**代码**

```java
/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/

class Solution {
    public Node copyRandomList(Node head) {
        if (head==null) return null;
        Node flag = head;       
        HashMap<Node,Node> map = new HashMap<>();
        while(head!=null){
            Node newNode = new Node(head.val);
            map.put(head,newNode);
            head = head.next; 
        }
        head = flag;
        while(head!=null){
            map.get(head).next = map.get(head.next);
            map.get(head).random = map.get(head.random);
            head = head.next;
        }
        return map.get(flag);
    }
}
```

**方法二，原地添加****

* 为了保留新旧节点之间一一对应的关系，将每个新生成的节点放在原始节点之后，这样任然能根据原始节点查找新节点，与hashmap效果相同
* 即  1--2---3---null 变成1--1‘--2--2’--3--3’--null;
* 第二次遍历负责穿针引线，主要负责random指针的修改
* 第三遍负责将链表分割成新旧两个链表



**代码**

```java
/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/

class Solution {
    public Node copyRandomList(Node head) {
        if (head==null) return null;

        Node cur = head;
        Node next =  head;
      //生成新节点，并插入到原始节点之后
        //这样能保证在穿针引线时每个新节点对应的新节点都是原始节点的下一个节点或者null
        while(head!=null){
            Node newNode = new Node(head.val);
            newNode.next =  head.next;
            head.next = newNode;
            head = newNode.next; 
        }
       
        head = cur;
       //设置新节点的random指针
        while(head!=null){
            //需要注意的是判断原始节点的random是否为null,
            head.next.random = head.random==null?null:head.random.next;     
            head =head.next.next;
        }

        head = cur;
        Node res = head.next;
        Node curCopy = res;

    //切割链表，分解成原始链表与副本链表
        while(head!=null){
            next = head.next.next;  
            curCopy = head.next;
            head.next = next;
            curCopy.next =next==null?null:next.next; 
            head = next;
            
        }

            return res;  
    }
}
```

## [面试题 02.07. 链表相交](https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/)

难度简单123收藏分享切换为英文接收动态反馈

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 `null` 。

图示两个链表在节点 `c1` 开始相交**：**

[![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)

题目数据 **保证** 整个链式结构中不存在环。

**注意**，函数返回结果后，链表必须 **保持其原始结构** 。

 

**示例 1：**

[![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png)

```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Intersected at '8'
解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
```

**示例 2：**

[![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png)

```
输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Intersected at '2'
解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。
在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
```

**示例 3：**

[![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png)

```
输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。
由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
这两个链表不相交，因此返回 null 。
```

 

**提示：**

- `listA` 中节点数目为 `m`
- `listB` 中节点数目为 `n`
- `0 <= m, n <= 3 * 104`
- `1 <= Node.val <= 100000`
- `0 <= skipA <= m`
- `0 <= skipB <= n`
- 如果 `listA` 和 `listB` 没有交点，`intersectVal` 为 `0`
- 如果 `listA` 和 `listB` 有交点，`intersectVal == listA[skipA + 1] == listB[skipB + 1]`

**思路（遍历两次A一次B）时间复杂度O(N)**

* 利用链表值都大于1的条件，先遍历一次A，把链表值都取反，代表访问过了
* 遍历B,如果有负值，只可能是同时出现在A中的结点，即相交结点，因为原始链表值不可能为负（1 <= Node.val <= 10<sup>5</sup>）
* 最后遍历一次A,将值修改为正
* 返回相交结点

**代码**

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode curA = headA,curB=headB;
        ListNode flag = null;
        while(headA!=null){
            headA.val = headA.val*(-1);
            headA = headA.next;
        }
  
        headA = curA;
        while(headB!=null){
            if(headB.val<0){
                flag = headB;
                break;
            }
            headB = headB.next;
        }

         while(headA!=null){
            headA.val = headA.val*(-1);
            headA = headA.next;
        }
        return flag;
    }

}
```



## [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

难度中等1161收藏分享切换为英文接收动态反馈

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg)

```
输入：head = [1,2,3,4]
输出：[2,1,4,3]
```

**示例 2：**

```
输入：head = []
输出：[]
```

**示例 3：**

```
输入：head = [1]
输出：[1]
```

**思路**

* 翻转链表变种
* 思路还是切割链表，翻转链表，接回链表
* 对于待交换的两个结点， 设置pre和next两个指针分别保留其前趋与后继结点，将两者交换后再接回原链表

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode swapPairs(ListNode head) {
        //pre和next分别记录前驱和后继结点
        ListNode cur = head,next = null,pre = new ListNode();
        pre.next = head;
        ListNode res = pre;

        while(cur!=null&&cur.next!=null){
            //记录后继节点
            next = cur.next.next;
            
            //翻转两个结点并接回原链表
            pre.next = cur.next;
            cur.next.next = cur;
            cur.next = next;
            //指针后移
            pre = pre.next.next;
            cur = next;
        }
        return res.next;
    }
}
```

## [61. 旋转链表](https://leetcode-cn.com/problems/rotate-list/)

难度中等678收藏分享切换为英文接收动态反馈

给你一个链表的头节点 `head` ，旋转链表，将链表每个节点向右移动 `k` 个位置。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg)

```
输入：head = [1,2,3,4,5], k = 2
输出：[4,5,1,2,3]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/11/13/roate2.jpg)

```
输入：head = [0,1,2], k = 4
输出：[2,0,1]
```

 

**提示：**

- 链表中节点的数目在范围 `[0, 500]` 内
- `-100 <= Node.val <= 100`
- `0 <= k <= 2 * 109`

**思路**

* 找到链表倒数第k-1个结点
* 找到链表尾结点
* 将原来的尾结点指向头结点
* 记录第k个结点
* 将第k-1个结点设为尾结点

以1--2--3--4--5，右移两位为例

1. 找到结点3
2. 找到尾结点5
3. 让5指向1
4. 记录3的下一个节点4
5. 将3指向null
6. 返回4



**代码**

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode rotateRight(ListNode head, int k) {
        if(head==null) return head;
        int length = 1;
        ListNode cur = head;
        ListNode tail = null;
        while(cur.next!=null){
            cur = cur.next;
            length++;
        }
        if(length<=1||k==0) return head;
        tail = cur;      
        k = k % length;
        cur = head;
        int index = 1;

        while(index<length-k){
            cur = cur.next;
            index++;
        }  
        tail.next = head;
        tail = cur.next;
        cur.next = null;
        return tail;
    }
}
```

## [剑指 Offer 36. 二叉搜索树与双向链表](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)

难度中等358

输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。

 

为了让您更好地理解问题，以下面的二叉搜索树为例：

 

![img](https://assets.leetcode.com/uploads/2018/10/12/bstdlloriginalbst.png)

 

我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。

下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。

 

![img](https://assets.leetcode.com/uploads/2018/10/12/bstdllreturndll.png)

 

特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。

 

**注意：**本题与主站 426 题相同：https://leetcode-cn.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/

**思路**

- 中序遍历搜索二叉树，使用队列存放结点

- 取出队列中的结点，构建双向链表

**代码**

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val,Node _left,Node _right) {
        val = _val;
        left = _left;
        right = _right;
    }
};
*/
class Solution {
    public Node treeToDoublyList(Node root) {
        if(root==null) return root;
        Node pre = new Node(-1);
        Node a = pre;
        Queue <Node> q = new LinkedList<>();
        InOrderTraverse(root,q);
        for(Node n:q){
            pre.right = n;
            n.left = pre;
            pre = n;
        }
        pre.right = a.right;
        a.right.left = pre;
        return a.right;
    }

    void InOrderTraverse(Node root,Queue<Node> q){
        if(root!=null){
            InOrderTraverse(root.left,q);
            q.offer(root);
            InOrderTraverse(root.right,q);
        }
    }

    
}
```

## 86. 分隔链表

给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。

你应当 保留 两个分区中每个节点的初始相对位置。

 

示例 1：
<img style="width: 662px; height: 222px;" src="https://assets.leetcode.com/uploads/2021/01/04/partition.jpg" alt="">

输入：head = [1,4,3,2,5,2], x = 3
输出：[1,2,2,4,3,5]
示例 2：

输入：head = [2,1], x = 2
输出：[1,2]


提示：

链表中节点的数目在范围 [0, 200] 内
-100 <= Node.val <= 100
-200 <= x <= 200

**思路**

* 遍历链表，将小于指定数的节点从链表删除并构成新的链表newHead
* 记录删除小节点之后的原始链表表头flag，即第一个大于等于x的节点
* 将原始链表flag连接到新链表末尾newhead

**代码**

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode partition(ListNode head, int x) {
        ListNode cur = head;
        ListNode newHead = new ListNode(),pre = new ListNode();
        ListNode ans = newHead,next = null;
        pre.next = head;
       
        ListNode flag = null;
         //查找第一个大于等于x的节点作为后续的链表头节点，默认不存在
        while(cur!=null){
            if(cur.val>=x){
                flag = cur;
                break;
            }
            cur = cur.next;
        }
    
        cur = head;
        //删除原始链表中小于x的节点，并将这些被删除的节点组建成新的链表newHead
        while(cur!=null){
            next = cur.next;           
            if(cur.val<x){
                newHead.next = cur;
                newHead = cur;
                //删除接点
                pre.next = next;
                
            }
            else{
              
                pre = pre.next;

            }
            cur = next;       
        }
        newHead.next = flag;
        return ans.next;

    }
}
```

# 其他

## 蛇形矩阵

输入一个整数n,生成一个以如下形式的矩阵并输出

以n = 4为例

```
[1, 2, 6, 7]
[3, 5, 8, 13]
[4, 9, 12, 14]
[10, 11, 15, 16]
```

### 思路 

矩阵以一上一下的形式赋值

先从左下角往右上角走，到了矩阵边界之后再从右上角往左下角走。**但这只是半边矩阵的规律**，所以需要分别画出两个半边矩阵最后再合并

1. 用一个标志step,step∈{-1,1}判断当前是往上走还是往下走
2. 用line表示行下标，row表示列下标
3. 用i表示当前值
4. arr_line_row = i++
5. 如果是往下走，下标变化为line+1,row-1
6. 走到最后一行之后，下标变化为line-1，row+1

```python
n = 4
ans = []
for i in range(n):ans.append([0]*n)
i = 1
step = - 1
line,row = 0,0
while i <= (n+1)*n/2:
    while line > -1 and row > -1 and line < n and row < n:
        ans [line][row] = i
        i += 1
        line += step
        row -= step
    if step == -1:
        line = 0
    else:
        row = 0
    step = step * (-1)
i = n*n   

res = [[0]*4,[0]*4,[0]*4,[0]*4]
step = - 1
line,row = 0,0
while i > (n+1)*n/2:
    while line>-1 and row > -1 and line < n and row < n:
        res [line][row] = i
        i -= 1
        line += step
        row -= step
    if step==-1:
        line = 0
    else:
        row = 0
    step = step * (-1)
for i in range(n-1):
    for j in range(n-i-1):
        ans[n-i-1][n-j-1] = res [i][j]
for i in ans:
    print(i)
```
