# 类的加载

类的加载指将类的class文件读入内存并为之创建一个java.lang.Class对象。

**类是真实事物的抽象，它可以有自己的实例，换个角度，类本身也可以说是一个实例，它们都是java.lang.Class的实例**

# IO流

输入源包括键盘、文件、网络连接等

* 输入流：Inputstream(字节)/reader(字符)
* 输出流：Outstream（字节）/writer(字符)

### 字节流字符流一般应用场景

如果输入输出文本内容，考虑使用字符流，如果是二进制文件，考虑使用字节流。这样能避免字节字符之间相互转换带来的复杂度

## BIO

* BIO全称是Blocking IO，是JDK1.4之前的传统IO模型，本身是同步阻塞模式。
*  线程发起IO请求后，一直阻塞IO，直到缓冲区数据就绪后，再进入下一步操作。
* 针对网络通信都是一请求一应答的方式，虽然简化了上层的应用开发，但在性能和可靠性方面存在着巨大瓶颈，试想一下如果每个请求都需要新建一个线程来专门处理，那么在高并发的场景下，机器资源很快就会被耗尽。

## NIO

* NIO也叫Non-Blocking IO 是同步非阻塞的IO模型。
* 线程发起io请求后，立即返回（非阻塞io）。
* 同步指的是必须等待IO缓冲区内的数据就绪，
* 而非阻塞指的是，用户线程不原地等待IO缓冲区，可以先做一些其他操作，但是要定时轮询检查IO缓冲区数据是否就绪。
* Java中的NIO 是new IO的意思。其实是NIO加上IO多路复用技术。
* 普通的NIO是线程轮询查看一个IO缓冲区是否就绪，而Java中的new IO指的是线程轮询地去查看一堆IO缓冲区中哪些就绪，
* 这是一种IO多路复用的思想。
* IO多路复用模型中，将检查IO数据是否就绪的任务，交给系统级别的select或epoll模型，由系统进行监控，减轻用户线程负担。

* NIO主要有buffer、channel、selector三种技术的整合，通过零拷贝的buffer取得数据，
* 每一个客户端通过channel在selector（多路复用器）上进行注册。
* 服务端不断轮询channel来获取客户端的信息。
* channel上有connect,accept（阻塞）、read（可读）、write(可写)四种状态标识。
* 根据标识来进行后续操作。所以一个服务端可接收无限多的channel。不需要新开一个线程。大大提升了性能。

## AIO

AIO是真正意义上的异步非阻塞IO模型。 上述NIO实现中，需要用户线程定时轮询，去检查IO缓冲区数据是否就绪，占用应用程序线程资源，其实轮询相当于还是阻塞的，并非真正解放当前线程，因为它还是需要去查询哪些IO就绪。而真正的理想的异步非阻塞IO应该让内核系统完成，用户线程只需要告诉内核，当缓冲区就绪后，通知我或者执行我交给你的回调函数。

AIO可以做到真正的异步的操作，但实现起来比较复杂，支持纯异步IO的操作系统非常少，目前也就windows是IOCP技术实现了，而在Linux上，底层还是是使用的epoll实现的。

低，但是查询效率高啊。

## 多路复用

* [彻底理解 IO 多路复用实现机制](https://juejin.cn/post/6882984260672847879)

### 什么是IO多路复用？

- IO 多路复用是一种同步IO模型，实现一个线程可以监视多个文件句柄；
- 一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；
- 没有文件句柄就绪就会阻塞应用程序，交出CPU。

> 多路是指网络连接，复用指的是同一个线程

|                      | **select**                                         | **poll**                                         | **epoll**                                                    |
| -------------------- | -------------------------------------------------- | ------------------------------------------------ | ------------------------------------------------------------ |
| 操作方式             | 遍历                                               | 遍历                                             | 回调                                                         |
| 数据结构             | bitmap                                             | 数组                                             | 红黑树                                                       |
| 最大连接数           | 1024（x86）或 2048（x64）                          | 无上限                                           | 无上限                                                       |
| 最大支持文件描述符数 | 一般有最大值限制                                   | 65535                                            | 65535                                                        |
| fd拷贝               | 每次调用select，都需要把fd集合从用户态拷贝到内核态 | 每次调用poll，都需要把fd集合从用户态拷贝到内核态 | fd首次调用epoll_ctl拷贝，每次调用epoll_wait不拷贝            |
| 工作模式             | LT                                                 | LT                                               | 支持ET高效模式                                               |
| 工作效率             | 每次调用都进行线性遍历，时间复杂度为O(n)           | 每次调用都进行线性遍历，时间复杂度为O(n)         | 事件通知方式，每当fd就绪，系统注册的回调函数就会被调用，将就绪fd放到readyList里面，时间复杂度O(1) |

## 卫语句

如果条件语句极其复杂，就应该将条件语句拆解开，然后逐个检查，并在条件为真时立刻从函数中返回，这样的单独检查通常被称之为“卫语句”（guard clauses）



1.什么是卫语句

        卫语句就是把复杂的条件表达式拆分成多个条件表达式，减少嵌套。嵌套了好几层的if - then-else语句，转换为多个if语句，实现它的逻辑，这多条的if语句就是卫语句。
    
        卫语句将某些关键条件优先判断，简化程序流程走向。卫语句往往用于对 if 条件嵌套代码的优化。
    
        在《阿里巴巴Java开发手册》中强制规定：超过 3 层的 if-else 的逻辑判断代码可以使用卫语句、策略模式、状态模式等来实现，其中卫语句即代码逻辑先考虑失败、异常、中断、退出等直接返回的情况，以方法多个出口的方式，解决代码中判断分支嵌套的问题，这是逆向思维的体现。

2.举例

嵌套的话语句很繁琐，可读性差。

```java
public void get(int t) {
    if (t == 1) {
        return;
    } else {
        if (t == 2) {
            return;
        } else {
            if (t == 3) {
                return;
            } else {
                set();
            }
        }
    }
}   


```

使用卫语句：



    public void get(int t) {
    if (t == 1) {
        return;
    }
    if (t == 2) {
        return;
    }
    if (t == 3) {
        return;
    }
    set();
    }

# 1-3 知识点

# 1.javac

javac 把java 程序编译成字节码，java 运行javac产生的.class

* 在命令行使用javac之后，如果源代码有package会报无法加载主类的错误
* javac执行成功后会生成.class文件，之后通过java执行时不加.class后缀

正例 java HelloJava

反例：java HelloJava.class

##  main方法须声明为public,必须为静态

# 2.基本数据类型（8种）

## 2.1 整型

| 名称   | long（L） | int  | short | byte |
| ------ | --------- | ---- | ----- | ---- |
| 字节数 | 8         | 4    | 2     | 1    |

十六进制有前缀0x、八进制有前缀0

| 名称   | float       | double                  |
| ------ | ----------- | ----------------------- |
| 字节数 | 4   有后缀F | 8  默认为无后缀的浮点数 |

## 2.2char

单个字符

## 2.3boolean

## 2.4常量

* java 利用关键字final声明常量

* 例如

```java
final int AGE = 30 ;
```

* 关键字final表示这个变量只能被赋值一次，一旦被赋值就不能更改了，习惯上常量名使用大写
* java中经常希望在一个类的多个方法中使用某个常量，通常讲这些常量称为类常量，例

```java
public static final double CCC = 3.3 
```

* 类常量的定义位于main方法的外部，因此，在同一个类的其他方法也可以使用，而且如果被声明为public,其他类也可以使用

## 位运算

| 名称 | &                                                            | \|     | ^    | ~    | >>   | <<   | >>>         |
| ---- | ------------------------------------------------------------ | ------ | ---- | ---- | ---- | ---- | ----------- |
| 解释 | 与运算可以利用2的幂进行位屏蔽，例如n&8可以屏蔽除了右数第四位以外的位 | 或运算 | 异或 | 非   | 右移 | 左移 | 高位用0填充 |



## 数学函数

Math类中的方法

| 方法 | sqrt() | pow(x,a)  | 三角函数       | 指数函数 | 对数函数 | PI   |
| ---- | ------ | --------- | -------------- | -------- | -------- | ---- |
|      | 平方根 | x 的a次幂 | sin cos tan... | exp（）  | log()    | π    |

## 类型转换

* double + 其他 = double
* 否则 float + 其他 = float
* 否则 long + 其他 = long
* 否则两者都转为int

## 强制类型转换

强制将一个数值转换为另一种，又超出了目标类型的表示范围就会截断为一个完全不同的制如  （byte ）300 = 40

## 优先级

+=右优先

a+=b+=c  = a+=(b+=c)

## 枚举类型

有时候，变量的取值只在一个有限的集合内，例如披萨只有大中小三种尺寸，如果使用普通变量，可能会保存一个错误的值，这时可以使用枚举类型

枚举类型包含有限个命名的值

例如：

```java
enum Size{SMALL,MEDIUM,LARGE};
//现在可以声明一个这种变量
Size s = Size.MEDIUM;
```

## 数组

### 定义

两种方法

* int[]a
* int a []

### 初始化



#### 动态初始化

  只指定初始长度，系统分配初始值

  int [] arr = new int [5];

  [] 说明只是一个数组

  new :为数组声明把内存

  

#### 静态初始化

  指定数组元素，系统决定长度

  int　［］　arr = new int []{1,2,3}

  简化

  int [] arr = {1,2,3}

### 匿名数组

new int[]{1}

### 数组拷贝

int  [] b =Arrays.copyOf(a,a.length) 





## 命令行参数

main函数有一个字符串数组的形参

在命令行运行程序时可以传参

java Test -hello world



# 3. 权限修饰符

##　private

* 权限修饰符
* 可以修饰成员（变量和方法）
* 保护成员不被别的类使用

如果想让别的类访问，可以声明get 和set方法，方法用public修饰


![img](https://2468732199.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F2O7gJns9kXvSQmqxeoqU%2Fuploads%2FSl6lm6zhR4MSfLq6RzVX%2Fimage.png?alt=media&token=ad65f958-5fcf-4e80-a177-28ca603a7137)

## 跨平台原理

平台指操作系统平台 如Windows Macos等

通过JVM（Java Virtual Machine）实现

一个平台对应一种JVM

## 标识符命名约定

### 小驼峰（方法变量）

第一个单词首字母小写，其余大写

### 大驼峰（类）

所有单词首字母大写

# 4. 关键字


## static

1. 静态变量

- **静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。**

实例;

```java
public class Test{ 
    private static int i=1;
    public int getNext(){ 
         return i++;
    } 
    public static void main(String [] args){ 
        Test test=new Test(); 
        Test testObject=new Test(); 
        test.getNext(); 
        testObject.getNext(); 
        System.out.println(testObject.getNext()); 
    } 
}
```

这段代码输出结果是3

如果i没被static修饰，那么调用两次test的getnext方法，i的值应该是2

可由于i是类变量，所以objtest的一次调用也要算进去

该题主要考察的是static属性和i++操作。

因为i是static的，是类属性，所以不管有多少对象，都共用的一个变量。这里getNext()方法被调用了三次，所以进行了三次i++操作。

但是由于getNext()操作的返回是：return i++; i++是先返回，后++，所以在println是，已经返回了i(此时i为3)，再进行自增的，所以这里结果为3



- 实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。

2. 静态方法

   静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。

## final

1. 类 

   当final修饰一个类时，表明其为最终类，它不能被继承，并且类中所有的属性和方法都默认是final类型，如String，Integer等包装类均为final类。

2. 方法
   被final修饰的方法不可被重写。它可以防止任何继承类修改方法的意义和实现，而且，使用
   final修饰方法的执行效率一般高于普通方法

3. 变量

   使用final修饰的变量称为常量（大写字母表示），只能被赋值一次，且赋值之后无法改变，这里的变量又可以分为基本类型变量和引用类型变量，final修饰基本类型变量时，变量的值不可改变；修饰引用变量时，变量指向的对象地址不可改变。

4. 成员变量  只有定义时赋值和构造函数赋值两种方式

4. 



##  this

* 修饰成员变量
* 不带this指代形参
* 解决局部变量隐藏成员变量的问题
* 方法被哪个对象调用，this就指代那个变量

## Transient

java 的transient关键字的作用是需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。



# 6. 判断

Java中判别式必须为布尔值，不能为整形

if（5）×

if（True) √

# 7 JVM 



jvm堆分为：新生代（一般是一个Eden区，两个Survivor区），老年代（old区）。

常量池属于 PermGen（方法区）

# 8.字符串

| 名称          | 是否可变 | 线程安全 |
| ------------- | -------- | -------- |
| String        | 否       | 否       |
| StringBuffer  | 是       | 是       |
| StringBuilder | 是       | 否       |

## 成员方法

* hashCode()方法和equals()方法的作用其实是一样的，在Java里都是用来对比两个对象是否相等一致。

  ***那么equals()既然已\******经\******能\******实现\******对\******比的功能了，为什么还要hashCode()呢？\***因为重写的equals()里一般比较的比较全面比较复杂，这样效率就比较低，而利用hashCode()进行对比，则只要生成一个hash值进行比较就可以了，效率很高。*
  *

  ***那么hashCode()既然效率这么高为什么还要equals()呢******？*** 因为hashCode()并不是完全可靠，有时候不同的对象他们生成的hashcode也会一样（生成hash值得公式可能存在的问题），所以hashCode()只能说是大部分时候可靠，并不是绝对可靠，

  **所以我们可以得出：**

  **1.equals()相等的两个对象他们的hashCode()肯定相等，也就是用equals()对比是绝对可靠的。**

  **2.hashCode()相等的两个对象他们的equal()不一定相等，也就是hashCode()不是绝对可靠的。**

  所有对于需要大量并且快速的对比的话如果都用equals()去做显然效率太低，所以解决方式是，每当需要对比的时候，首先用hashCode()去对比，如果hashCode()不一样，则表示这两个对象肯定不相等（也就是不必再用equal()去再对比了）,如果hashCode()相同，此时再对比他们的equals()，如果equals()也相同，则表示这两个对象是真的相同了，这样既能大大提高了效率也保证了对比的绝对正确性！

* **java程序的种类**

  1.Application：Java应用程序，是可以由Java解释器直接运行的程序。

  2.Applet：即Java小应用程序，是可随网页下载到客户端由浏览器解释执行的Java程序。
  3.Servlet：Java服务器端小程序，由Web服务器(容器)中配置运行的Java程序。

* 父类new直接执行构造方法

* 子类new，先执行父类的构造方法，再执行自己的构造方法

```Java
package niuke;

public class ttt { public static void main(String[] args) {
    Father a = new Father();
    Father b = new Child();
}
}
class Father {
    public Father() {
        System.out.println("我是父类");
    }
}
class Child extends Father { public Child() {
    System.out.println("我是子类");
}
}
//程序执行结果
我是父类
我是父类
我是子类

Father a = new Father(); //执行结果为   我是父类
Father b = new Child(); //执行结果为   我是父类   我是子类


    
```

* 在JVM调用mian方法之前先用进行静态内容的初始化。                                                                                                                                   顺序为：父类的静态变量， 父类的静态代码块 ，子类的静态变量，子类的静态代码块。

```java
public class Test{
    static int cnt = 6;
    static{
        cnt += 9;
    }
	public static void main(String[] args）{
    System.out.println（“cnt =” + cnt);
	}
static{
    cnt /=3;
    };
}
//输出cnt=5
```

* **Java一个源程序只能有一个public类存在，且类名与文件名相同。**Java程序是从main方法开始执行的，public为类加载器提供入口，然后找到public类中的main方法开始执行。如果存在多个public类，程序将不知道该从哪里执行。
  **注意**，内部类可以是public的，因为内部类是作为外部类的成员存在的。

```Java
package niuke;
/*
 * Java一个源程序只能有一个public类存在，且类名与文件名相同。
 * Java程序是从main方法开始执行的，public为类加载器提供入口，然后找到public类中的main方法开始执行。
 * 如果存在多个public类，程序将不知道该从哪里执行。
 * 注意，内部类可以是public的，因为内部类是作为外部类的成员存在的。
 * */
public class MultiClass {

    public MultiClass(){
        System.out.println("这是主类的构造函数");
    }

    //因为是内部类，所以使用public修饰也未报错
    public static class World {

        public World() {
            System.out.println("这是内部public类构造函数");
        }
        public static void main(String[] args) {
            MultiClass mc = new MultiClass();
            World w = new World();
            Hello h = new Hello();
        }
    }
}

//因为此类未用public 修饰，因此不会报错
    class Hello {
        public Hello() {
            System.out.println("这是外部类构造函数");
        }
    }

```

```java
	int a = 10;
    double b=3.14;
    //转换为double
    System.out.println('A'+a+b);
    //单引号是字符，转换为整数
    System.out.println('A'+10);
    //双引号是字符串，表示字符串拼接
    System.out.println("A"+10);
```

- 编译器将Java源代码编译成字节码class文件
- 类加载到JVM里面后，执行引擎把字节码转为可执行代码
- 执行的过程，再把可执行代码转为机器码，由底层的操作系统完成执行。

<table border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse;">
  <tbody>
    <tr>
      <td style="" valign="top" width="166"><p>
          <span>&nbsp;</span>
        </p>
      </td><td style="" valign="top" width="166"><p>
          <span>private</span>
        </p>
      </td><td style="" valign="top" width="166"><p>
          <span>default</span>
        </p>
      </td><td style="" valign="top" width="166"><p>
          <span>protected</span>
        </p>
      </td><td style="" valign="top" width="166"><p>
          <span>public</span>
        </p>
      </td></tr>
    <tr>
      <td style="" valign="top" width="166"><p>
          <span>同一个类中</span>
        </p>
      </td><td valign="top" width="166"><p>
          <span>√</span>
        </p>
      </td><td valign="top" width="166"><p>
          <span>√</span>
        </p>
      </td><td valign="top" width="166"><p>
          <span>√</span>
        </p>
      </td><td valign="top" width="166"><p>
          <span>√</span>
        </p>
      </td></tr>
    <tr>
      <td style="" valign="top" width="166"><p>
          <span>同一个包中</span>
        </p>
      </td><td valign="top" width="166"><p>
          <span>&nbsp;</span>
        </p>
      </td><td valign="top" width="166"><p>
          <span>√</span>
        </p>
      </td><td valign="top" width="166"><p>
          <span>√</span>
        </p>
      </td><td valign="top" width="166"><p>
          <span>√</span>
        </p>
      </td></tr>
    <tr>
      <td style="" valign="top" width="166"><p>
          <span>子类中</span>
        </p>
      </td><td valign="top" width="166"><p>
          <span>&nbsp;</span>
        </p>
      </td><td valign="top" width="166"><p>
          <span>&nbsp;</span>
        </p>
      </td><td valign="top" width="166"><p>
          <span>√</span>
        </p>
      </td><td valign="top" width="166"><p>
          <span>√</span>
        </p>
      </td></tr>
    <tr>
      <td style="" valign="top" width="166"><p>
          <span>全局范围内</span>
        </p>
      </td><td valign="top" width="166"><p>
          <span>&nbsp;</span>
        </p>
      </td><td valign="top" width="166"><p>
          <span>&nbsp;</span>
        </p>
      </td><td valign="top" width="166"><p>
          <span>&nbsp;</span>
        </p>
      </td><td valign="top" width="166"><p>
          <span>√</span>
        </p>
      </td></tr>
  </tbody>
</table>




* javac将源程序编译成.class文件，字节码；java将字节码转为机器码，.exe程序



# 4-类与对象

## 类

**要想创建一个完整的程序，应该将若干类组合在一起，其中只有一个类有main方法**

* **类与对象可以类比为饼干切割机和饼干**

* **由对象创建类的过程称为后创建类的实例**

###  1. 类之间的关系

* 依赖（uses-a）类A需要访问B
* 聚合 类A的对象包含类B的对象
* 继承

###  2.用户自定义类

Java最简单的类形式为

```java
class ClassName{
        constuctor1
        construct2
        ...
        method1
        method2
        .....
        filed1
        filed2
            //即变量
        ...
}
```

### 3.访问实例

对于类中的实例,如果将其采用public修饰，那么对于它的访问会更加便捷，但一般不会这么做，而是采用以下做法

* 一个私有的数据域（使用private修饰）
* 一个共有的域访问方法（get函数）
* 一个共有的与修改方法（set函数）

这么做明显更加复杂，但有明显的好处

1. 可以改变内部实现，只需修改方法

   比如，如果将name实例修改为String firstName和String lastName,那么getName方法可以改为返回firstName + " " + lastName;	

2. 更改器方法可以执行错误检查，而直接对类中实例赋值则不会

   例如：setSalary（）方法可以检查工资是否小于0




# 对象

## 1.对象与对象变量

在

```java 
Date a = new Date()
```

中，new Date()表示一个变量，a 表示一个对象变量

对象变量没有包含变量，只是引用变量



## 封装

**封装**：面向对象三大特征之一（封装 继承 多态）

是面向对象编程语言对客观世界的模拟

* 封装原则

将类的某些信息隐藏在类的内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏i洗脑洗的访问

* 好处

通过方法来控制变量的操作，提高了代码的安全性

把代码用方法封装，提高的代码的复用性

## 4.6 对象构造

### 4.6.1 方法重载

多个方法具有相同的名字,不同的参数的特征叫**重载**。（这些方法在同一个类中。）

**重写**是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。**即外壳不变，核心重写！**（方法分别在子类和父类）

## 构造方法

一种特殊的方法，作用是创建对象

* 默认无参构造

Student s = new **Student()**;

* 有参数的构造方法

# 5-继承

### 5.1.1继承层次

继承并非只有一个层次

例如 子类 manager可以派生出executive类

![类对象](C:%5CUsers%5Cmodige%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211003111913690.png)

### 5.1.2 多态

在Java中，对象变量是**多态**的，一个对象既可以引用自己类对象，也可以引用子类对象

```java
 //多态
        //正确写法 (超类可以引用子类)
        Employee employee = new Manager("modige",1000.0,new Date());
        //错误写法（子类不能引用   超类）
        //Manager manager1 = new Employee("modige",1000.0,new Date());
        //这是因为如果manage1调用bonus会报错
        //这可以理解为所有的经理都是员工，但并非所有的员工都是经理

```



### 5.1.3动态绑定

对象方法调用过程详细描述

1. 假设调用x.f(name),编译器会调用类中所有名为f 以及 超类中 属性为public 且名为 f的方法 如 f(int a) f(String a)等
2. 接着检查候选方法的参数类型，选择一个与提供的参数类型相同的方法，例如如果是x.f("modige"),编译器会选择f(String a),如果没有匹配的类型，则检查参数类型转换之后是否有满足的，都没有则报错，这个过程称为**重载解析**
3. 如果是private static final修饰的方法，或者构造器，那么编译器将可以准确地知道改运行哪个方法，这种调用方式称为**静态绑定**，**与此对应的是动态绑定**，上述例子则是动态绑定
4. 当程序运行并采用动态绑定的方法，虚拟机每次都要按照12进行寻找，时间开销较大，因此虚拟机为每个类预设一个方法表，因此调用时虚拟机只需查表即可

### 5.1.4 阻止继承：final类和方法

* 不允许被继承的类称为final类，使用final修饰
* 使用final修饰的方法不能被覆盖
* 如果一个方法没有被覆盖且很短，编译器能够优化处理，这个过程称为**内联**，

### 5.1.5 强制类型转换

将超类转换成子类

### 5.1.6 抽象类

* 包含一个或多个抽象方法的类必须被声明为抽象类
* 除了抽象方法，抽象类也可以包含具体的方法和数据
* 抽象方法充当着占位的角色

宏观地说，每个人都有姓名性别之类的属性，所以之前提到的父类Employee也可以有自己的父类Person,![image-20211003152218735](C:%5CUsers%5Cmodige%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211003152218735.png)

由于person的子类太多，所以很多方法不方便具体写出，比如如果有一个getDescription方法用来返回对每个类的简短，那么对于额employee,可以返回“这是一个工资为1000的员工”，对于student,可以返回“这是一个成绩不错的学生”，如此一来该方法就不适合返回具体内容了

此时我们可以把它声明为抽象方法，这样就不需要实现这个方法，只是占个位子，把实现的任务交给各个子类

```java
public abstract class Person {
    public abstract String getDescription();
}
```

扩展抽象方法可以有两种选择

* 在子类中定义部分抽象方法或者抽象方法也不定义，这样就必须将子类也定义为抽象类
* 定义全部的抽象方法，这样子类就不是抽象的了

**抽象类不能被实例化**，但可以引用一个非抽象子类的对象

```java
new Person()    //错误
Person p = new Employee()   //正确
```

### 5.1.7 受保护访问

当需要允许子类访问超类中的某个方法或数据时，可以用protected修饰

* 仅对本类可见 private
* 对所有类可见 public
* 对本包和所有子类可见 protected
* 对本包可见 默认（即没有修饰符）

## 5.2 Object：所有类的超类

由于Java中所有类都是这个类的子类，所以学习它的所有服务非常重要

### 5.2.1 Equals方法

判断两个对象是否具有相同的引用

```java
    public boolean equals(Object otherObject){
        if (this == otherObject) return true;
        if (otherObject == null) return false;
        if (getClass()!=otherObject.getClass()) return false;
        Employee other = (Employee) otherObject;
        return name.equals(other.name) && salary==other.salary && hireDay.equals(other.hireDay);
    }
```

### 5.2.2 相等测试与继承

### 5.2.3 HashCode方法

* 散列码是由对象导出的一个整型值，散列码是没有规律的
* 由于hashCode方法定义在Object方法中，所以每个对象都有一个默认的散列码--其存储地址

```java
		String s = "OK";
        StringBuffer sb = new StringBuffer(s);
        System.out.println(s.hashCode() + "  "+ sb.hashCode());

        String t = new String("OK");
        StringBuffer tb = new StringBuffer(t);
        System.out.println(t.hashCode()  + "  "+ tb.hashCode());
```

| 值   | hashCode  |
| ---- | --------- |
| s    | 2524      |
| sb   | 284720968 |
| t    | 2524      |
| tb   | 214126413 |

* s与t的hashCode相同是因为字符串的散列码是根据字符串内容生成的

* sb与tb不同是因为StringBuffer类没有定义hashCode方法，所以输出的是他们的存储地址

* 定义hashCode方法时需要合理地组合实例域的散列码

  ```java
   public int hashCode(){
          return 7+name.hashCode()+11+new Double(salary).hashCode() + 13 + new Date().hashCode();
      }
  ```

  **由上述例子可见，两个实例域对应相等的对象会返回相同的hashCode()值**

  **两个实例域不同的对象也可能返回相等的hashcode值**

  **hashCode 与 Equals的定义必须一致，如果x.equals(y)返回true,那么x.hashCode()就必须返回与y.hashCode()相同的值**

  例如，如果equal比较员工id，hashCode必须散列id，而不是姓名或存储地址

  #### 5.2.4 ToString方法

* 它用于返回表示对象值的字符串

* 当对象与一个字符串通过+ 连接时，编译器会调用toString方法

* 输出对象时，编译器会调用toStrong方法

* 也可以在调试时使用toString方法以此观察类的状态

  *

  例如，Employee类的可以这样写

  ```java
   public String toString(){
          return getClass().getName()+" "
                  +"[name=" +name +",Salary="
                  +salary + ",hireDay="
                  +hireDay + "]";
      }
  
  //输出：Employee [name=modige,Salary=1000.0,hireDay=Sun Oct 03 16:16:34 CST 2021]
  ```

  子类可以改写父类的toString方法

  ```java
    public String toString(){
          return super.toString()+"[bonus="+bonus+"]";
      }
  
  //Manager [name=modige,Salary=1000.0,hireDay=Sun Oct 03 16:19:34 CST 2021][bonus=0.0]
  ```

## 5.3 泛型数组列表ArrayList

* ArrayList是一个采用类型参数的泛型类
* 定义一个长度未知的数组
* 当提前定义的空间用完后，系统会自动创建一个更大的数组，并将之前的数据复制到新数组中
* 如果提前知道长度，可以使用ensureCapacity指定长度

## 5.4 对象包装器与自动打包

有时候需要将int这类基本数据类型转换为对象。所有的基本数据类型都有对应的类 例如Integer对应int。通常这种类称为包装器（wrapper）

* Integer
* Long
* Short
* Byte
* Double
* Float
* Character
* Void
* Boolean

其中前六个派生于超类Number

在ArrayList<>的尖括号中不允许出现基本数据类型，就是说不允许写成ArrayList，这时就需要Integer包装器

在实际编程中，编译器会将list.add(3)自动转换成list.add(new Integer(3))

这种变换称为**自动打包**，对应的是自动拆包

## 5.5参数数量可变的方法

例如

```java
System.out.println(a);
System.out.println("%a %b"a,b);
```

这里的print方法分别有一个和两个参数

```java
//可变参数
        public  double max(double... values){
        double largest = Double.MIN_VALUE;
        for (Double v:values){
            if (v>largest) largest = v;
        }
        return largest;
        }
```

形参里的省略号...表示可以传入任意数量的对象

## 5.6 枚举类

枚举数据类型本身就是一个类

```java
public enum Size{
    SMALL,MEDIUM,LARGE;
}
```

## 5.7 反射

能够分析类能力的程序被称为反射(reflective),反射的功能包括

* [掘金](https://juejin.cn/post/6864324335654404104)

* 在运行中分析类的能力
* 在运行中查看对象，例如，编写一个toString
* 实现数组的操作代码
* 利用Method对象

#### **反射的应用场景**

通过上面的讲解，我们可以回味总结下：

反射常见的应用场景这里介绍3个：

- **Spring 实例化对象：当程序启动时，Spring 会读取配置文件applicationContext.xml并解析出里面所有的标签实例化到IOC容器中。**
- **反射 + 工厂模式：通过反射消除工厂中的多个分支，如果需要生产新的类，无需关注工厂类，工厂类可以应对各种新增的类，反射可以使得程序更加健壮。**
- **JDBC连接数据库：使用JDBC连接数据库时，指定连接数据库的驱动类时用到反射加载驱动类**


作者：苏世_
链接：https://juejin.cn/post/7082713148607856654
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

### 5.7.1 Class类

### 5.7.2 捕获异常

### 5.7.3分析类

## 5.8 继承设计的技巧

* 将公共操作和域放在超类
* 不要使用受保护的类
* 使用继承实现 is-a 关系
* 除非所有继承的方法都有意义，否则不要使用继承
* 覆盖方法时不要改变预期的行为
* 使用多态而非类型信息
* 不要过多地使用反射
  *

## 方法

### 注意事项

* 不能嵌套定义
* void可以不写return ,也可以写return ,但后面不加数据

## 方法重载

同一个类中定义的多个方法满足以下条件

* 同一个类中
* 方法名相同
* 参数不同（数量或类型不同）

出现原因：需要对不同数据类型的元素实现相同的功能

以求和函数为例

* 对两个整数求和
  int sum(int a,int b){return a+b}

* 对两个浮点数求和

  float sum(float a,float b){return a+b}

* 对三个整数求和

  int sum(int a,int b，int c){return a+b+c}

###  调用方法

  int result = sum(10,20)

  float result2 = sum(1.0,2.0)

  int result3 = sum(10,20,30)

## **方法的重写（override）两同两小一大原则**：

方法名相同，参数类型相同

子类返回类型小于等于父类方法返回类型，

子类抛出异常小于等于父类方法抛出异常，

子类访问权限大于等于父类方法访问权限。

# 6-接口与内部类

* **接口**技术主要描述类具有什么功能，而不用具体实现
* 一个类可以实现（implement）一个或多个接口 
* 克隆对象（深拷贝）是指新创建一个对象，新对象的状态与原始对象相同，对新对象的修改不影响原始对象
* 内部类指定义在另外一个类内部的类，他的方法可以访问外部类的域

## 6.1 接口

* 在java中，接口不是类，而是对类的一组需求描述
* 接口中的方法自动属于public,因此可以省略public，但在类中实现这个方法时需要提供public修饰
* 接口中不能含有实例域，也不能实现方法

为了让类实现一个接口，通常需要两个步骤

1. 将类声明为实现给定的接口
2. 对接口的所有方法进行定义

### 6.1.1 接口的特性

* 接口不是类，尤其不能使用new运算符实例化一个接口

* 可以声明接口的变量

  ```java
  comparable x
      //变量必须引用实现了接口的类
  x = new Employee()
  ```

* 可以使用instanceof 检查一个类是否实现了某个接口

```java
if (Employee instanceof compatable)
```

* 接口也可以被继承
* 接口中不能包含实例域或静态方法，但可以有常量

```java
    @Override
            public int compareTo(Employee employee) {
                if (salary<employee.salary) return -1;
                if (salary>employee.salary) return 1;
                return 0;
            }
```



### 6.1.2 接口与抽象类

|          | 接口                        | 抽象类                           |
| -------- | --------------------------- | -------------------------------- |
| 变量     | 静态变量                    | 普通成员变量+静态变量            |
| 方法     | 抽象、静态、默认(可以实现） | 可以有普通方法，可以没有抽象方法 |
| 实例化   | 不能                        | 不能                             |
| 定义     | 行为规范                    | 一种模板化设计                   |
| 构造器   | 不包含                      | 包含（只是为了给子类调用）       |
| 初始化块 | 不能包含                    | 可以包含                         |
| 继承     | 多继承                      | 单继承                           |
| 场景     |                             |                                  |

抽象类的通用属性存在的问题：**每个类只能扩展于一个类**，**而接口可以实现多个接口**

#### Java8

* 接口可以有默认方法，默认方法可以提供实现
* 

#### 1.抽象类的使用场景

既想约束子类具有共同的行为（但不再乎其如何实现），又想拥有缺省的方法，又能拥有实例变量

如：模板方法设计模式，模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中某些步骤的具体实现。

#### 2.接口的应用场景

① 约束多个实现类具有统一的行为，但是不在乎每个实现类如何具体实现

② 作为能够实现特定功能的标识存在，也可以是什么接口方法都没有的纯粹标识。

③ 实现类需要具备很多不同的功能，但各个功能之间可能没有任何联系。

④ 使用接口的引用调用具体实现类中实现的方法（多态）
————————————————
版权声明：本文为CSDN博主「IT阿豪」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_2662385590/article/details/125311664

## 6.2 对象克隆

当拷贝一个对象时，新对象与原始对象引用的是同一个对象，对新对象修改时原始对象也会改变

```java
Employee e = new Employee("John",1000.0);
Employee copy = e;
copy.raiseSalary(10);
//这时两个对象的薪水都改变了
```

如果要创建一个新的对象，对它的操作不影响原始变量，就需要使用克隆clone

```java
Employee copy = e.clone();
```

**克隆又分为深拷贝和浅拷贝两种，默认使用浅拷贝**

1. 浅拷贝 

   如果原始对象中的实例都为基本数据类型，不会有问题，如果原始对象中存在对子对象的引用，那么新对象仍会引用相同的子对象，这样来说并没有完全解决问题

2. 深拷贝

重新对clone进行定义，以实现克隆子对象的深拷贝

对于每一个类，需要做出以下判断

* 默认的clone方法是否满足要求
* 默认的clone方法是否可以通过调用子对象的clone得到修补
* 是否不应该使用clone

```java
   public Employee clone() throws CloneNotSupportedException{
            Employee cloned = (Employee)super.clone();
            cloned.hireDay = (Date)hireDay.clone();
            return cloned;
                }
```

## 6.3 接口与回调

回调指发生某个特定事件时应该采取的动作

这里以一个定时器为例

```java
public class MyTimer implements ActionListener {
    @Override
    public void actionPerformed(ActionEvent actionEvent) {
        Date now = new Date();
        System.out.println("at the tone,the time is "+now);
        Toolkit.getDefaultToolkit().beep();
    }
}

```

## 6.4 内部类

内部类指定义在另外一个类内部的类，他的方法可以访问外部类的域，使用内部类的原因

*  内部类可以访问所在类的数据，包括私有类型
*  内部类能够对同一个包中的其他类隐藏起来
*  想要写一个回调函数且不想写大量代码时，用匿名内部类比较便捷

1.静态内部类才可以声明静态方法

2.静态方法不可以使用非静态变量

3.抽象方法不可以有函数体

1.为什么使用内部类?
使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，
对于内部类都没有影响
1.1.使用内部类最大的优点就在于它能够非常好的解决多重继承的问题,使用内部类还能够为我们带来如下特性:
(1)、内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独。
(2)、在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。
(3)、创建内部类对象的时刻并不依赖于外围类对象的创建。
(4)、内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。
(5)、内部类提供了更好的封装，除了该外围类，其他类都不能访问。





# 11-异常

# 异常 日志 断言 调试

## 11.1 处理异常

  如果出现错误，程序应该

* 返回到一种安全状态，并能够让用户执行一些命令，或者
* 允许用户保存所有操作的结果，并以适当的方式终止程序

**常见错误**

1. 用户输入错误
2. 设备错误
3. 物理限制
4. 代码错误

### 11.1.1 异常分类

![image-20211008205504453](C:\Users\modige\AppData\Roaming\Typora\typora-user-images\image-20211008205504453.png)

所有的异常都继承自Throwable，但在下一层分为Error和Exception

* Error类层次结构描述了Java运行时系统的内部错误和资源耗尽错误。
* 系统主要关注Exception层次结构

**Exception又分为两个分支，一个分支派生于RuntimeException,另一个分支包含其他异常**

派生于RuntimeException的异常包含以下几种情况

* 错误的类型转换
* 数组访问越界
* 访问空指针

**其他异常包括**

* 试图在文件尾部读取数据
* 试图打开一个错误格式的URL、
* 试图根据给定的字符串查找Class对象，而这个字符串表示的类不存在

**Java语言规范将所有派生于Error和Exception的异常称为未检查异常，其他异常称为已检查异常**、

### 11.1.2 声明已检查异常

方法应该在其首部声明所有可能出现的已检查异常、



### 11.1.3如何抛出异常

 对于一个已经存在的异常类，将其抛出非常容易，在这种情况下

1. 找到一个合适的异常类
2. 创建这个类的一个对象
3. 将对象抛出

一旦方法抛出了异常，这个方法就不可能返回到调用者，也就是说不用为返回的默认值或错误代码担忧

### 11.1.4 创建异常类

* 当标准异常类不能充分描述问题时，需要创建自己的异常类

* 需要做的是定义一个派生于Exception或者其子类的类
* 习惯上定义的类应该包含两个构造器，一个是默认的构造器，另一个是带有详细描述信息的构造器

## 11.2 捕获异常

 到目前为止，已经知道如何抛出一个异常

要想捕获一个异常，必须设置try/catch语句块，最简单的try语句块如下所示



```java
try{
    code;
}
catch(Exception e){
    handler for this type
}
```

如果在try语句块抛出了任何一个在catch中说明的异常类，那么

1.  程序将跳过try语句块中的其他代码
2.  程序将执行catch字句中的处理器代码

如果没有出现异常，程序将跳过catch字句

### 11.2.1捕获多个异常

在一个try字句中可以捕获多个异常类型，并对不同类型的异常做出不同的处理

```java
try{
    
}
catch(Exception e1){
}
catch(Exception e2){
    
}
```

### 11.2.2 再次抛出异常

在catch字句中可以抛出一个异常，这是为了改变异常类型

### 11.2.3 finally字句



根据官方的JVM规范：
**如果try语句里有return，返回的是try语句块中变量值。**
详细执行过程如下：

1. 如果有返回值，就把返回值保存到局部变量中；
2. 执行jsr指令跳到finally语句里执行；
3. 执行完finally语句后，返回之前保存在局部变量表里的值。



![img](https://uploadfiles.nowcoder.com/images/20211028/348470426_1635431780619/6479D7BB01736CCC61B8270D41F00B17)



## throw&throws

* [Java中throw和throws有什么区别？](https://blog.csdn.net/weixin_46511008/article/details/118770337)

### 一、说明：

> 1. **throw 在方法体内使用，throws 在方法声明上使用；**
>
> 2. throw 后面接的是异常对象，只能接一个。throws 后面接的是异常类型，可以接多个，多个异常类型用逗号隔开；
>
> 3. throw 是在方法中出现不正确情况时，手动来抛出异常，结束方法的，执行了 throw 语句一定会出现异常。而 throws 是用来声明当前方法有可能会出现某种异常的，如果出现了相应的异常，将由调用者来处理，声明了异常不一定会出现异常。
>
>    

### 二、相关解析

throw 和 throws 都是用来进行 Java 异常处理的。

1、其中，throw 是用在某个方法的方法体内的，当我们认定某种情况不合理时，就可以创建异常对象，封装好异常信息，然后通过 throw 来抛出异常并终止该方法。

```java
public class CustomerLevel {
    // 性别
    private String level;
    public String getLevel() {
    	return level;
	}

	public void setLevel(String level) {
        if (!("会员".equals(level) || "普通用户".equals(level))) {
            //throw用在setLevel(String level)方法的方法体内
            throw new IllegalArgumentException("非法用户：" + level);
        }
   	 this.level = level;
	}
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
```

2、而 throws 是用在某个方法的方法声明上的，表示当前方法如果抛出了某些异常，将由调用者来进行异常处理。这种方式也可以让调用者知晓该对哪些异常进行处理。throws 声明的异常不一定会出现，只是一种可能。

```JAVA
public class FileInputStream extends InputStream {
    //throws用在FileInputStream(String namwe)方法的方法声明上的
    public FileInputStream(String name) throws FileNotFoundException {
        this(name != null ? new File(name) : null);
    }
}
```



# 12-泛型

## 12.2 简单泛型的定义

**一个泛型类**就是具有一个或多个类型变量的类

换句话说，泛型类可以看成普通类的工厂

```java
package Generic;

import lombok.Data;

/**
 * @description :一个简单的泛型类例子
 * 引入了一个类型变量T
 * 
 * @author      :modige
 * @date        :2021-10-9
 * */
@Data
public class Pair<T> {
    //实例域
    private T first;
    private T secend;

     //构造方法
     public Pair(){first = null;secend=null;}
     public Pair(T first,T secend){
         this.first = first;
         this.secend = secend;
     }

     public T getFirst(){return first;}
     public T getSecond(){return secend;}
     public void setFirst(T newValue){first = newValue;}
     public void setSecond(T newValue){secend = newValue;}
     /**
      * 已有*/

}

```

在java库中，使用

* E表示集合的元素类型

* K和V表示表的关键字与值的类型
* T（必要时还可以用邻近的字母U和S）表示任意类型

## 12.3 泛型方法

```java
public static <T> T gerMiddle(T[] a){
         return a[a.length/2];
     }
```

泛型方法可以定义在普通类中，也可以定义在泛型类中

## 12.4 类型方法的限定

## 12.5 泛型代码与虚拟机

虚拟机没有泛型类型对象，所有对象都属于普通类。

# 13-集合

## 13.1 集合接口

### 13.1.1 将集合的接口与实现分离

Java 集合类库将接口与实现分离。以队列(queue）为例介绍

一个队列的最小形式如下

```java
interface Queue<E>{
void add(E element);
E remove;
int size();
}
```

通常队列的实现有两种方法，分别是循环数组和链表



### 13.1.2 Java 类库中的集合接口和迭代器接口

在Java类库中，集合类的基本接口是Collection接口。

这个接口有两个基本方法

```java
public interface Collection<E>{
    boolean add(E element);
    Iterator <E> iterator();
    ...
}
```

add方法用于向集合添加元素。如果添加元素成功返回true，失败（例如集合中已经存在要添加的元素）返回false

iterator方法返回一个实现了Iterator接口的对象，可以用这个迭代器对象遍历集合中的元素

**迭代器**：Iterator接口包含三个方法

```java
public interface Iterator<E>{
    E next();
    boolean hasNext();
    void remove();
}
```

通过反复调用next（）方法，可以逐个访问集合的每个元素

## 13.2 具体的集合

1. 链表  List 、LinkedList
2. 数组列表 ArrayList 实现了List
3. 散列集 HashSet 
4. 树集 TreeSet
5. 

散列



## 线程安全

Collection 是对象集合， Collection 有两个子接口 List 和 Set,

**有且只有Vector和HashTable线程安全**

Vector和Hashtable中的方法有synchronized修饰

两者虽然线程安全，但是性能变差，因为线程加锁需要监控时间

------

List 可以通过下标 (1,2..) 来取得值，值可以重复,而 Set 只能通过游标来取值，并且值是不能重复的

ArrayList ， Vector ， LinkedList 是 List 的实现类

ArrayList 是线程不安全的， Vector 是线程安全的，这两个类底层都是由数组实现的

LinkedList 是线程不安全的，底层是由链表实现的



Map 是键值对集合

HashTable 和 HashMap 是 Map 的实现类

HashTable 是线程安全的，不能存储 null 值

HashMap 不是线程安全的，可以存储 null 值

