# 类的加载

类的加载指将类的class文件读入内存并为之创建一个java.lang.Class对象。

**类是真实事物的抽象，它可以有自己的实例，换个角度，类本身也可以说是一个实例，它们都是java.lang.Class的实例**

# IO流

输入源包括键盘、文件、网络连接等

* 输入流：Inputstream(字节)/reader(字符)
* 输出流：Outstream（字节）/writer(字符)

### 字节流字符流一般应用场景

如果输入输出文本内容，考虑使用字符流，如果是二进制文件，考虑使用字节流。这样能避免字节字符之间相互转换带来的复杂度

# 集合collection



![image-20220622170357493](E:\gitfile\modiman.github.io\docs\_posts\imgs\image-20220622170357493.png)两大集合类接口

众所周知，Java 集合框架拥有两大接口 `Collection` 和 `Map`，其中，`Collection` 麾下三生子 `List`、`Set` 和 `Queue`。

## ArrayList 

1. **基本定义**

`ArrayList` 就实现了 `List` 接口，其实就是一个数组列表，不过作为 Java 的集合框架，它只能存储对象引用类型，也就是说当我们需要装载的数据是诸如 `int`、`float` 等基本数据类型的时候，必须把它们转换成对应的包装类。

`ArrayList` 的底层实现是一个 `Object` 数组：

* 查找 O(1)
* 增删o(n)

另外，和 `ArrayList` 一样同样实现了 `List` 接口的、我们比较常用的还有 `LinkedList`。`LinkedList` 比较特殊，它不仅实现了 `List` 接口，还实现了 `Queue` 接口，所以你可以看见 `LinkedList` 经常被当作队列使用：

```java
Queue<Integer> queue = new LinkedList<>();
```

`LinkedList` 人如其名，它的底层自然是基于[链表](https://www.nowcoder.com/jump/super-jump/word?word=链表)的，而且还是个双向[链表](https://www.nowcoder.com/jump/super-jump/word?word=链表)。[链表](https://www.nowcoder.com/jump/super-jump/word?word=链表)的特性和数组正好是反的，由于没有索引，所以查询效率低，但是增删速度快。

2.  **ArrayList 如何指定底层数组大小的？**

OK，首先，既然咱真正存储数据的地方是数组，那我们初始化 `ArrayList` 的时候自然要给数组分配一个大小，开辟一个内存空间。我们先来看看 `ArrayList` 的无参构造函数：

* 默认为0
* 第一次add时分配为0
* 通过构造函数指定大小

3. **数组的大小一旦被规定就无法改变，那 ArrayList 是怎么对底层数组进行扩容的？**

`ArrayList` 的底层实现是 `Object` 数组，我们知道，数组的大小一旦被规定就无法改变。那如果我们不断的往里面添加数据的话，`ArrayList` 是如何进行扩容的呢？或者说 ArrayList 是如何实现存放任意数量对象的呢？

OK，扩容发生在啥时候？那肯定是我们往数组中新加入一个元素但是发现数组满了的时候。没错，我们去 `add` 方法中看看 `ArrayList` 是怎么做扩容的：

`ensureExplicitCapacity` 判断是否需要进行扩容，很显然，`grow` 方法是扩容的关键：

说实话，别的都不用看了，看上面图中的黄色框框就知道 `ArrayList` 是怎么扩容的了：扩容后的数组长度 = 当前数组长度 + 当前数组长度 / 2。最后使用 `Arrays.copyOf` 方法直接把原数组中的数组 copy 过来，需要注意的是，`Arrays.copyOf` 方***创建一个**新数组**然后再进行拷贝。



4. **既然扩容发生在添加数据的时候**，**讲讲** **ArrayList** **具体是怎么添加数据的**

OK，`add` 方法我们刚刚讲了一半，添加数据前会先判断一下是否需要扩容，真正的添加数据的操作在下半部分：

先讲下 `add(int index, E element)` 这个方法的含义，就是在指定索引 index 处插入元素 element。比如说 `ArrayList.add(0, 3)`，意思就是在头部插入元素 3。

再来看看 `add` 方法的核心 `System.arraycopy`，这个方法有 5 个参数：

- elementData：源数组
- index：从源数组中的哪个位置开始复制
- elementData：目标数组
- index + 1：复制到目标数组中的哪个位置
- size - index：要复制的源数组中数组元素的数量

解释一下上面代码中 `arraycopy` 的意思，举个例子，我们想要在 index = 5 的位置插入元素，首先，我们会复制一遍源数组 elementData（这里我们称复制的数组为新数组吧），然后把源数组中从 index = 5 的位置开始到数组末尾的元素，放到新数组的 index + 1 = 6 的位置上：

于是，这就给我们要新增的元素腾出了位置，然后在新数组 index = 5 的位置放入元素 element 就完成了添加的操作：

显然，不用多说，ArrayList 的将数据插入到指定位置的操作性能非常低下，因为要开辟新数组复制元素啊，要是涉及到扩容那就更慢了。

另外，`ArrayList` 还内置了一个直接在末尾添加元素的 `add` 方法，不用复制数组，直接 size ++ 就好，这个方法应该是我们最常使用的：



5. ArrayList 又是如何删除数据的呢？

Ctrl + F 找到 `remove` 方法，就这？和添加一个道理，也是复制数组

举个例子，假设我们要删除数组的 index = 5 的元素，首先，我们会复制一遍源数组，然后把源数组中从 index + 1 = 6 的位置开始到数组末尾的元素，放到新数组的 index = 5 的位置上：



也就是说 index = 5 的元素直接被覆盖掉了，给了你被删除的感觉。同样的，它的效率自然也是十分低下的

6. ArrayList 是线程安全的吗？不安全的表现

`ArrayList` 和 `LinkedList` 都不是线程安全的，我们以在末尾添加元素的 `add` 方法为例，来看看 `ArrayList` 线程不安全的表现是啥：

黄色框里的并不是一个原子操作，它由两步操作构成：

```java
elementData[size] = e
size = size + 1;
```

在单线程执行这两条代码时，那当然没有任何问题，但是当多线程环境下执行时，可能就会发生**一个线程添加的值覆盖另一个线程添加的值**。!

`ArrayList` 的线程安全版本是 `Vector`，它的实现很简单，就是把所有的方法统统加上 `synchronized`：

既然它需要额外的开销来维持同步锁，所以理论上来说它要比 `ArrayList` 要慢。

7. **为什么线程不安全还要用它呢？**

因为在大多数场景中，查询的情况居多，不会涉及太频繁的增删。那如果真的涉及频繁的增删，可以使用`LinkedList`，底层[链表](https://www.nowcoder.com/jump/super-jump/word?word=链表)实现，为增删而生。而如果你非得保证线程安全那就使用 `Vector`。当然实际开发中使用最多的还是 `ArrayList`，虽然线程不安全、增删效率低，但是查询效率高啊。

## 卫语句

如果条件语句极其复杂，就应该将条件语句拆解开，然后逐个检查，并在条件为真时立刻从函数中返回，这样的单独检查通常被称之为“卫语句”（guard clauses）



1.什么是卫语句

        卫语句就是把复杂的条件表达式拆分成多个条件表达式，减少嵌套。嵌套了好几层的if - then-else语句，转换为多个if语句，实现它的逻辑，这多条的if语句就是卫语句。
    
        卫语句将某些关键条件优先判断，简化程序流程走向。卫语句往往用于对 if 条件嵌套代码的优化。
    
        在《阿里巴巴Java开发手册》中强制规定：超过 3 层的 if-else 的逻辑判断代码可以使用卫语句、策略模式、状态模式等来实现，其中卫语句即代码逻辑先考虑失败、异常、中断、退出等直接返回的情况，以方法多个出口的方式，解决代码中判断分支嵌套的问题，这是逆向思维的体现。

2.举例

嵌套的话语句很繁琐，可读性差。

```java
public void get(int t) {
    if (t == 1) {
        return;
    } else {
        if (t == 2) {
            return;
        } else {
            if (t == 3) {
                return;
            } else {
                set();
            }
        }
    }
}   


```

使用卫语句：



    public void get(int t) {
    if (t == 1) {
        return;
    }
    if (t == 2) {
        return;
    }
    if (t == 3) {
        return;
    }
    set();
    }

# 1-3 知识点

# 1.javac

javac 把java 程序编译成字节码，java 运行javac产生的.class

* 在命令行使用javac之后，如果源代码有package会报无法加载主类的错误
* javac执行成功后会生成.class文件，之后通过java执行时不加.class后缀

正例 java HelloJava

反例：java HelloJava.class

##  main方法须声明为public,必须为静态

# 2.基本数据类型（8种）

## 2.1 整型

| 名称   | long（L） | int  | short | byte |
| ------ | --------- | ---- | ----- | ---- |
| 字节数 | 8         | 4    | 2     | 1    |

十六进制有前缀0x、八进制有前缀0

| 名称   | float       | double                  |
| ------ | ----------- | ----------------------- |
| 字节数 | 4   有后缀F | 8  默认为无后缀的浮点数 |

## 2.2char

单个字符

## 2.3boolean

## 2.4常量

* java 利用关键字final声明常量

* 例如

```java
final int AGE = 30 ;
```

* 关键字final表示这个变量只能被赋值一次，一旦被赋值就不能更改了，习惯上常量名使用大写
* java中经常希望在一个类的多个方法中使用某个常量，通常讲这些常量称为类常量，例

```java
public static final double CCC = 3.3 
```

* 类常量的定义位于main方法的外部，因此，在同一个类的其他方法也可以使用，而且如果被声明为public,其他类也可以使用

## 位运算

| 名称 | &                                                            | \|     | ^    | ~    | >>   | <<   | >>>         |
| ---- | ------------------------------------------------------------ | ------ | ---- | ---- | ---- | ---- | ----------- |
| 解释 | 与运算可以利用2的幂进行位屏蔽，例如n&8可以屏蔽除了右数第四位以外的位 | 或运算 | 异或 | 非   | 右移 | 左移 | 高位用0填充 |



## 数学函数

Math类中的方法

| 方法 | sqrt() | pow(x,a)  | 三角函数       | 指数函数 | 对数函数 | PI   |
| ---- | ------ | --------- | -------------- | -------- | -------- | ---- |
|      | 平方根 | x 的a次幂 | sin cos tan... | exp（）  | log()    | π    |

## 类型转换

* double + 其他 = double
* 否则 float + 其他 = float
* 否则 long + 其他 = long
* 否则两者都转为int

## 强制类型转换

强制将一个数值转换为另一种，又超出了目标类型的表示范围就会截断为一个完全不同的制如  （byte ）300 = 40

## 优先级

+=右优先

a+=b+=c  = a+=(b+=c)

## 枚举类型

有时候，变量的取值只在一个有限的集合内，例如披萨只有大中小三种尺寸，如果使用普通变量，可能会保存一个错误的值，这时可以使用枚举类型

枚举类型包含有限个命名的值

例如：

```java
enum Size{SMALL,MEDIUM,LARGE};
//现在可以声明一个这种变量
Size s = Size.MEDIUM;
```

## 数组

### 定义

两种方法

* int[]a
* int a []

### 初始化



#### 动态初始化

  只指定初始长度，系统分配初始值

  int [] arr = new int [5];

  [] 说明只是一个数组

  new :为数组声明把内存

  

#### 静态初始化

  指定数组元素，系统决定长度

  int　［］　arr = new int []{1,2,3}

  简化

  int [] arr = {1,2,3}

### 匿名数组

new int[]{1}

### 数组拷贝

int  [] b =Arrays.copyOf(a,a.length) 





## 命令行参数

main函数有一个字符串数组的形参

在命令行运行程序时可以传参

java Test -hello world



# 3. 权限修饰符

##　private

* 权限修饰符
* 可以修饰成员（变量和方法）
* 保护成员不被别的类使用

如果想让别的类访问，可以声明get 和set方法，方法用public修饰


![img](https://2468732199.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F2O7gJns9kXvSQmqxeoqU%2Fuploads%2FSl6lm6zhR4MSfLq6RzVX%2Fimage.png?alt=media&token=ad65f958-5fcf-4e80-a177-28ca603a7137)

## 跨平台原理

平台指操作系统平台 如Windows Macos等

通过JVM（Java Virtual Machine）实现

一个平台对应一种JVM

## 标识符命名约定

### 小驼峰（方法变量）

第一个单词首字母小写，其余大写

### 大驼峰（类）

所有单词首字母大写

# 4. 关键字


## static

1. 静态变量

- **静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。**

实例;

```java
public class Test{ 
    private static int i=1;
    public int getNext(){ 
         return i++;
    } 
    public static void main(String [] args){ 
        Test test=new Test(); 
        Test testObject=new Test(); 
        test.getNext(); 
        testObject.getNext(); 
        System.out.println(testObject.getNext()); 
    } 
}
```

这段代码输出结果是3

如果i没被static修饰，那么调用两次test的getnext方法，i的值应该是2

可由于i是类变量，所以objtest的一次调用也要算进去

该题主要考察的是static属性和i++操作。

因为i是static的，是类属性，所以不管有多少对象，都共用的一个变量。这里getNext()方法被调用了三次，所以进行了三次i++操作。

但是由于getNext()操作的返回是：return i++; i++是先返回，后++，所以在println是，已经返回了i(此时i为3)，再进行自增的，所以这里结果为3



- 实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。

2. 静态方法

   静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。

## final

1. 类 

   当final修饰一个类时，表明其为最终类，它不能被继承，并且类中所有的属性和方法都默认是final类型，如String，Integer等包装类均为final类。

2. 方法
   被final修饰的方法不可被重写。它可以防止任何继承类修改方法的意义和实现，而且，使用
   final修饰方法的执行效率一般高于普通方法

3. 变量

   使用final修饰的变量称为常量（大写字母表示），只能被赋值一次，且赋值之后无法改变，这里的变量又可以分为基本类型变量和引用类型变量，final修饰基本类型变量时，变量的值不可改变；修饰引用变量时，变量指向的对象地址不可改变。

4. 成员变量  只有定义时赋值和构造函数赋值两种方式

4. 



##  this

* 修饰成员变量
* 不带this指代形参
* 解决局部变量隐藏成员变量的问题
* 方法被哪个对象调用，this就指代那个变量

## Transient

java 的transient关键字的作用是需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。



# 6. 判断

Java中判别式必须为布尔值，不能为整形

if（5）×

if（True) √

# 7 JVM 



jvm堆分为：新生代（一般是一个Eden区，两个Survivor区），老年代（old区）。

常量池属于 PermGen（方法区）

# 8.字符串

| 名称          | 是否可变 | 线程安全 |
| ------------- | -------- | -------- |
| String        | 否       | 否       |
| StringBuffer  | 是       | 是       |
| StringBuilder | 是       | 否       |

## 成员方法

* hashCode()方法和equals()方法的作用其实是一样的，在Java里都是用来对比两个对象是否相等一致。

  ***那么equals()既然已\******经\******能\******实现\******对\******比的功能了，为什么还要hashCode()呢？\***因为重写的equals()里一般比较的比较全面比较复杂，这样效率就比较低，而利用hashCode()进行对比，则只要生成一个hash值进行比较就可以了，效率很高。*
  *

  ***那么hashCode()既然效率这么高为什么还要equals()呢******？*** 因为hashCode()并不是完全可靠，有时候不同的对象他们生成的hashcode也会一样（生成hash值得公式可能存在的问题），所以hashCode()只能说是大部分时候可靠，并不是绝对可靠，

  **所以我们可以得出：**

  **1.equals()相等的两个对象他们的hashCode()肯定相等，也就是用equals()对比是绝对可靠的。**

  **2.hashCode()相等的两个对象他们的equal()不一定相等，也就是hashCode()不是绝对可靠的。**

  所有对于需要大量并且快速的对比的话如果都用equals()去做显然效率太低，所以解决方式是，每当需要对比的时候，首先用hashCode()去对比，如果hashCode()不一样，则表示这两个对象肯定不相等（也就是不必再用equal()去再对比了）,如果hashCode()相同，此时再对比他们的equals()，如果equals()也相同，则表示这两个对象是真的相同了，这样既能大大提高了效率也保证了对比的绝对正确性！

* **java程序的种类**

  1.Application：Java应用程序，是可以由Java解释器直接运行的程序。

  2.Applet：即Java小应用程序，是可随网页下载到客户端由浏览器解释执行的Java程序。
  3.Servlet：Java服务器端小程序，由Web服务器(容器)中配置运行的Java程序。

* 父类new直接执行构造方法

* 子类new，先执行父类的构造方法，再执行自己的构造方法

```Java
package niuke;

public class ttt { public static void main(String[] args) {
    Father a = new Father();
    Father b = new Child();
}
}
class Father {
    public Father() {
        System.out.println("我是父类");
    }
}
class Child extends Father { public Child() {
    System.out.println("我是子类");
}
}
//程序执行结果
我是父类
我是父类
我是子类

Father a = new Father(); //执行结果为   我是父类
Father b = new Child(); //执行结果为   我是父类   我是子类


    
```

* 在JVM调用mian方法之前先用进行静态内容的初始化。                                                                                                                                   顺序为：父类的静态变量， 父类的静态代码块 ，子类的静态变量，子类的静态代码块。

```java
public class Test{
    static int cnt = 6;
    static{
        cnt += 9;
    }
	public static void main(String[] args）{
    System.out.println（“cnt =” + cnt);
	}
static{
    cnt /=3;
    };
}
//输出cnt=5
```

* **Java一个源程序只能有一个public类存在，且类名与文件名相同。**Java程序是从main方法开始执行的，public为类加载器提供入口，然后找到public类中的main方法开始执行。如果存在多个public类，程序将不知道该从哪里执行。
  **注意**，内部类可以是public的，因为内部类是作为外部类的成员存在的。

```Java
package niuke;
/*
 * Java一个源程序只能有一个public类存在，且类名与文件名相同。
 * Java程序是从main方法开始执行的，public为类加载器提供入口，然后找到public类中的main方法开始执行。
 * 如果存在多个public类，程序将不知道该从哪里执行。
 * 注意，内部类可以是public的，因为内部类是作为外部类的成员存在的。
 * */
public class MultiClass {

    public MultiClass(){
        System.out.println("这是主类的构造函数");
    }

    //因为是内部类，所以使用public修饰也未报错
    public static class World {

        public World() {
            System.out.println("这是内部public类构造函数");
        }
        public static void main(String[] args) {
            MultiClass mc = new MultiClass();
            World w = new World();
            Hello h = new Hello();
        }
    }
}

//因为此类未用public 修饰，因此不会报错
    class Hello {
        public Hello() {
            System.out.println("这是外部类构造函数");
        }
    }

```

```java
	int a = 10;
    double b=3.14;
    //转换为double
    System.out.println('A'+a+b);
    //单引号是字符，转换为整数
    System.out.println('A'+10);
    //双引号是字符串，表示字符串拼接
    System.out.println("A"+10);
```

- 编译器将Java源代码编译成字节码class文件
- 类加载到JVM里面后，执行引擎把字节码转为可执行代码
- 执行的过程，再把可执行代码转为机器码，由底层的操作系统完成执行。

<table border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse;">
  <tbody>
    <tr>
      <td style="" valign="top" width="166"><p>
          <span>&nbsp;</span>
        </p>
      </td><td style="" valign="top" width="166"><p>
          <span>private</span>
        </p>
      </td><td style="" valign="top" width="166"><p>
          <span>default</span>
        </p>
      </td><td style="" valign="top" width="166"><p>
          <span>protected</span>
        </p>
      </td><td style="" valign="top" width="166"><p>
          <span>public</span>
        </p>
      </td></tr>
    <tr>
      <td style="" valign="top" width="166"><p>
          <span>同一个类中</span>
        </p>
      </td><td valign="top" width="166"><p>
          <span>√</span>
        </p>
      </td><td valign="top" width="166"><p>
          <span>√</span>
        </p>
      </td><td valign="top" width="166"><p>
          <span>√</span>
        </p>
      </td><td valign="top" width="166"><p>
          <span>√</span>
        </p>
      </td></tr>
    <tr>
      <td style="" valign="top" width="166"><p>
          <span>同一个包中</span>
        </p>
      </td><td valign="top" width="166"><p>
          <span>&nbsp;</span>
        </p>
      </td><td valign="top" width="166"><p>
          <span>√</span>
        </p>
      </td><td valign="top" width="166"><p>
          <span>√</span>
        </p>
      </td><td valign="top" width="166"><p>
          <span>√</span>
        </p>
      </td></tr>
    <tr>
      <td style="" valign="top" width="166"><p>
          <span>子类中</span>
        </p>
      </td><td valign="top" width="166"><p>
          <span>&nbsp;</span>
        </p>
      </td><td valign="top" width="166"><p>
          <span>&nbsp;</span>
        </p>
      </td><td valign="top" width="166"><p>
          <span>√</span>
        </p>
      </td><td valign="top" width="166"><p>
          <span>√</span>
        </p>
      </td></tr>
    <tr>
      <td style="" valign="top" width="166"><p>
          <span>全局范围内</span>
        </p>
      </td><td valign="top" width="166"><p>
          <span>&nbsp;</span>
        </p>
      </td><td valign="top" width="166"><p>
          <span>&nbsp;</span>
        </p>
      </td><td valign="top" width="166"><p>
          <span>&nbsp;</span>
        </p>
      </td><td valign="top" width="166"><p>
          <span>√</span>
        </p>
      </td></tr>
  </tbody>
</table>




* javac将源程序编译成.class文件，字节码；java将字节码转为机器码，.exe程序



# 4-类与对象

## 类

**要想创建一个完整的程序，应该将若干类组合在一起，其中只有一个类有main方法**

* **类与对象可以类比为饼干切割机和饼干**

* **由对象创建类的过程称为后创建类的实例**

###  1. 类之间的关系

* 依赖（uses-a）类A需要访问B
* 聚合 类A的对象包含类B的对象
* 继承

###  2.用户自定义类

Java最简单的类形式为

```java
class ClassName{
        constuctor1
        construct2
        ...
        method1
        method2
        .....
        filed1
        filed2
            //即变量
        ...
}
```

### 3.访问实例

对于类中的实例,如果将其采用public修饰，那么对于它的访问会更加便捷，但一般不会这么做，而是采用以下做法

* 一个私有的数据域（使用private修饰）
* 一个共有的域访问方法（get函数）
* 一个共有的与修改方法（set函数）

这么做明显更加复杂，但有明显的好处

1. 可以改变内部实现，只需修改方法

   比如，如果将name实例修改为String firstName和String lastName,那么getName方法可以改为返回firstName + " " + lastName;	

2. 更改器方法可以执行错误检查，而直接对类中实例赋值则不会

   例如：setSalary（）方法可以检查工资是否小于0




# 对象

## 1.对象与对象变量

在

```java 
Date a = new Date()
```

中，new Date()表示一个变量，a 表示一个对象变量

对象变量没有包含变量，只是引用变量



## 封装

**封装**：面向对象三大特征之一（封装 继承 多态）

是面向对象编程语言对客观世界的模拟

* 封装原则

将类的某些信息隐藏在类的内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏i洗脑洗的访问

* 好处

通过方法来控制变量的操作，提高了代码的安全性

把代码用方法封装，提高的代码的复用性

## 4.6 对象构造

### 4.6.1 方法重载

多个方法具有相同的名字,不同的参数的特征叫**重载**。（这些方法在同一个类中。）

**重写**是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。**即外壳不变，核心重写！**（方法分别在子类和父类）

## 构造方法

一种特殊的方法，作用是创建对象

* 默认无参构造

Student s = new **Student()**;

* 有参数的构造方法

# 5-继承

### 5.1.1继承层次

继承并非只有一个层次

例如 子类 manager可以派生出executive类

![类对象](C:%5CUsers%5Cmodige%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211003111913690.png)

### 5.1.2 多态

在Java中，对象变量是**多态**的，一个对象既可以引用自己类对象，也可以引用子类对象

```java
 //多态
        //正确写法 (超类可以引用子类)
        Employee employee = new Manager("modige",1000.0,new Date());
        //错误写法（子类不能引用   超类）
        //Manager manager1 = new Employee("modige",1000.0,new Date());
        //这是因为如果manage1调用bonus会报错
        //这可以理解为所有的经理都是员工，但并非所有的员工都是经理

```



### 5.1.3动态绑定

对象方法调用过程详细描述

1. 假设调用x.f(name),编译器会调用类中所有名为f 以及 超类中 属性为public 且名为 f的方法 如 f(int a) f(String a)等
2. 接着检查候选方法的参数类型，选择一个与提供的参数类型相同的方法，例如如果是x.f("modige"),编译器会选择f(String a),如果没有匹配的类型，则检查参数类型转换之后是否有满足的，都没有则报错，这个过程称为**重载解析**
3. 如果是private static final修饰的方法，或者构造器，那么编译器将可以准确地知道改运行哪个方法，这种调用方式称为**静态绑定**，**与此对应的是动态绑定**，上述例子则是动态绑定
4. 当程序运行并采用动态绑定的方法，虚拟机每次都要按照12进行寻找，时间开销较大，因此虚拟机为每个类预设一个方法表，因此调用时虚拟机只需查表即可

### 5.1.4 阻止继承：final类和方法

* 不允许被继承的类称为final类，使用final修饰
* 使用final修饰的方法不能被覆盖
* 如果一个方法没有被覆盖且很短，编译器能够优化处理，这个过程称为**内联**，

### 5.1.5 强制类型转换

将超类转换成子类

### 5.1.6 抽象类

* 包含一个或多个抽象方法的类必须被声明为抽象类
* 除了抽象方法，抽象类也可以包含具体的方法和数据
* 抽象方法充当着占位的角色

宏观地说，每个人都有姓名性别之类的属性，所以之前提到的父类Employee也可以有自己的父类Person,![image-20211003152218735](C:%5CUsers%5Cmodige%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211003152218735.png)

由于person的子类太多，所以很多方法不方便具体写出，比如如果有一个getDescription方法用来返回对每个类的简短，那么对于额employee,可以返回“这是一个工资为1000的员工”，对于student,可以返回“这是一个成绩不错的学生”，如此一来该方法就不适合返回具体内容了

此时我们可以把它声明为抽象方法，这样就不需要实现这个方法，只是占个位子，把实现的任务交给各个子类

```java
public abstract class Person {
    public abstract String getDescription();
}
```

扩展抽象方法可以有两种选择

* 在子类中定义部分抽象方法或者抽象方法也不定义，这样就必须将子类也定义为抽象类
* 定义全部的抽象方法，这样子类就不是抽象的了

**抽象类不能被实例化**，但可以引用一个非抽象子类的对象

```java
new Person()    //错误
Person p = new Employee()   //正确
```

### 5.1.7 受保护访问

当需要允许子类访问超类中的某个方法或数据时，可以用protected修饰

* 仅对本类可见 private
* 对所有类可见 public
* 对本包和所有子类可见 protected
* 对本包可见 默认（即没有修饰符）

## 5.2 Object：所有类的超类

由于Java中所有类都是这个类的子类，所以学习它的所有服务非常重要

### 5.2.1 Equals方法

判断两个对象是否具有相同的引用

```java
    public boolean equals(Object otherObject){
        if (this == otherObject) return true;
        if (otherObject == null) return false;
        if (getClass()!=otherObject.getClass()) return false;
        Employee other = (Employee) otherObject;
        return name.equals(other.name) && salary==other.salary && hireDay.equals(other.hireDay);
    }
```

### 5.2.2 相等测试与继承

### 5.2.3 HashCode方法

* 散列码是由对象导出的一个整型值，散列码是没有规律的
* 由于hashCode方法定义在Object方法中，所以每个对象都有一个默认的散列码--其存储地址

```java
		String s = "OK";
        StringBuffer sb = new StringBuffer(s);
        System.out.println(s.hashCode() + "  "+ sb.hashCode());

        String t = new String("OK");
        StringBuffer tb = new StringBuffer(t);
        System.out.println(t.hashCode()  + "  "+ tb.hashCode());
```

| 值   | hashCode  |
| ---- | --------- |
| s    | 2524      |
| sb   | 284720968 |
| t    | 2524      |
| tb   | 214126413 |

* s与t的hashCode相同是因为字符串的散列码是根据字符串内容生成的

* sb与tb不同是因为StringBuffer类没有定义hashCode方法，所以输出的是他们的存储地址

* 定义hashCode方法时需要合理地组合实例域的散列码

  ```java
   public int hashCode(){
          return 7+name.hashCode()+11+new Double(salary).hashCode() + 13 + new Date().hashCode();
      }
  ```

  **由上述例子可见，两个实例域对应相等的对象会返回相同的hashCode()值**

  **两个实例域不同的对象也可能返回相等的hashcode值**

  **hashCode 与 Equals的定义必须一致，如果x.equals(y)返回true,那么x.hashCode()就必须返回与y.hashCode()相同的值**

  例如，如果equal比较员工id，hashCode必须散列id，而不是姓名或存储地址

  #### 5.2.4 ToString方法

* 它用于返回表示对象值的字符串

* 当对象与一个字符串通过+ 连接时，编译器会调用toString方法

* 输出对象时，编译器会调用toStrong方法

* 也可以在调试时使用toString方法以此观察类的状态

  *

  例如，Employee类的可以这样写

  ```java
   public String toString(){
          return getClass().getName()+" "
                  +"[name=" +name +",Salary="
                  +salary + ",hireDay="
                  +hireDay + "]";
      }
  
  //输出：Employee [name=modige,Salary=1000.0,hireDay=Sun Oct 03 16:16:34 CST 2021]
  ```

  子类可以改写父类的toString方法

  ```java
    public String toString(){
          return super.toString()+"[bonus="+bonus+"]";
      }
  
  //Manager [name=modige,Salary=1000.0,hireDay=Sun Oct 03 16:19:34 CST 2021][bonus=0.0]
  ```

## 5.3 泛型数组列表ArrayList

* ArrayList是一个采用类型参数的泛型类
* 定义一个长度未知的数组
* 当提前定义的空间用完后，系统会自动创建一个更大的数组，并将之前的数据复制到新数组中
* 如果提前知道长度，可以使用ensureCapacity指定长度

## 5.4 对象包装器与自动打包

有时候需要将int这类基本数据类型转换为对象。所有的基本数据类型都有对应的类 例如Integer对应int。通常这种类称为包装器（wrapper）

* Integer
* Long
* Short
* Byte
* Double
* Float
* Character
* Void
* Boolean

其中前六个派生于超类Number

在ArrayList<>的尖括号中不允许出现基本数据类型，就是说不允许写成ArrayList，这时就需要Integer包装器

在实际编程中，编译器会将list.add(3)自动转换成list.add(new Integer(3))

这种变换称为**自动打包**，对应的是自动拆包

## 5.5参数数量可变的方法

例如

```java
System.out.println(a);
System.out.println("%a %b"a,b);
```

这里的print方法分别有一个和两个参数

```java
//可变参数
        public  double max(double... values){
        double largest = Double.MIN_VALUE;
        for (Double v:values){
            if (v>largest) largest = v;
        }
        return largest;
        }
```

形参里的省略号...表示可以传入任意数量的对象

## 5.6 枚举类

枚举数据类型本身就是一个类

```java
public enum Size{
    SMALL,MEDIUM,LARGE;
}
```

## 5.7 反射

能够分析类能力的程序被称为反射(reflective),反射的功能包括

* [掘金](https://juejin.cn/post/6864324335654404104)

* 在运行中分析类的能力
* 在运行中查看对象，例如，编写一个toString
* 实现数组的操作代码
* 利用Method对象

#### **反射的应用场景**

通过上面的讲解，我们可以回味总结下：

反射常见的应用场景这里介绍3个：

- **Spring 实例化对象：当程序启动时，Spring 会读取配置文件applicationContext.xml并解析出里面所有的标签实例化到IOC容器中。**
- **反射 + 工厂模式：通过反射消除工厂中的多个分支，如果需要生产新的类，无需关注工厂类，工厂类可以应对各种新增的类，反射可以使得程序更加健壮。**
- **JDBC连接数据库：使用JDBC连接数据库时，指定连接数据库的驱动类时用到反射加载驱动类**


作者：苏世_
链接：https://juejin.cn/post/7082713148607856654
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

### 5.7.1 Class类

### 5.7.2 捕获异常

### 5.7.3分析类

## 5.8 继承设计的技巧

* 将公共操作和域放在超类
* 不要使用受保护的类
* 使用继承实现 is-a 关系
* 除非所有继承的方法都有意义，否则不要使用继承
* 覆盖方法时不要改变预期的行为
* 使用多态而非类型信息
* 不要过多地使用反射
  *

## 方法

### 注意事项

* 不能嵌套定义
* void可以不写return ,也可以写return ,但后面不加数据

## 方法重载

同一个类中定义的多个方法满足以下条件

* 同一个类中
* 方法名相同
* 参数不同（数量或类型不同）

出现原因：需要对不同数据类型的元素实现相同的功能

以求和函数为例

* 对两个整数求和
  int sum(int a,int b){return a+b}

* 对两个浮点数求和

  float sum(float a,float b){return a+b}

* 对三个整数求和

  int sum(int a,int b，int c){return a+b+c}

###  调用方法

  int result = sum(10,20)

  float result2 = sum(1.0,2.0)

  int result3 = sum(10,20,30)

## **方法的重写（override）两同两小一大原则**：

方法名相同，参数类型相同

子类返回类型小于等于父类方法返回类型，

子类抛出异常小于等于父类方法抛出异常，

子类访问权限大于等于父类方法访问权限。

# 6-接口与内部类

* **接口**技术主要描述类具有什么功能，而不用具体实现
* 一个类可以实现（implement）一个或多个接口 
* 克隆对象（深拷贝）是指新创建一个对象，新对象的状态与原始对象相同，对新对象的修改不影响原始对象
* 内部类指定义在另外一个类内部的类，他的方法可以访问外部类的域

## 6.1 接口

* 在java中，接口不是类，而是对类的一组需求描述
* 接口中的方法自动属于public,因此可以省略public，但在类中实现这个方法时需要提供public修饰
* 接口中不能含有实例域，也不能实现方法

为了让类实现一个接口，通常需要两个步骤

1. 将类声明为实现给定的接口
2. 对接口的所有方法进行定义

### 6.1.1 接口的特性

* 接口不是类，尤其不能使用new运算符实例化一个接口

* 可以声明接口的变量

  ```java
  comparable x
      //变量必须引用实现了接口的类
  x = new Employee()
  ```

* 可以使用instanceof 检查一个类是否实现了某个接口

```java
if (Employee instanceof compatable)
```

* 接口也可以被继承
* 接口中不能包含实例域或静态方法，但可以有常量

```java
    @Override
            public int compareTo(Employee employee) {
                if (salary<employee.salary) return -1;
                if (salary>employee.salary) return 1;
                return 0;
            }
```



### 6.1.2 接口与抽象类

|          | 接口                        | 抽象类                           |
| -------- | --------------------------- | -------------------------------- |
| 变量     | 静态变量                    | 普通成员变量+静态变量            |
| 方法     | 抽象、静态、默认(可以实现） | 可以有普通方法，可以没有抽象方法 |
| 实例化   | 不能                        | 不能                             |
| 定义     | 行为规范                    | 一种模板化设计                   |
| 构造器   | 不包含                      | 包含（只是为了给子类调用）       |
| 初始化块 | 不能包含                    | 可以包含                         |
| 继承     | 多继承                      | 单继承                           |
| 场景     |                             |                                  |

抽象类的通用属性存在的问题：**每个类只能扩展于一个类**，**而接口可以实现多个接口**

#### Java8

* 接口可以有默认方法，默认方法可以提供实现
* 

#### 1.抽象类的使用场景

既想约束子类具有共同的行为（但不再乎其如何实现），又想拥有缺省的方法，又能拥有实例变量

如：模板方法设计模式，模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中某些步骤的具体实现。

#### 2.接口的应用场景

① 约束多个实现类具有统一的行为，但是不在乎每个实现类如何具体实现

② 作为能够实现特定功能的标识存在，也可以是什么接口方法都没有的纯粹标识。

③ 实现类需要具备很多不同的功能，但各个功能之间可能没有任何联系。

④ 使用接口的引用调用具体实现类中实现的方法（多态）
————————————————
版权声明：本文为CSDN博主「IT阿豪」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_2662385590/article/details/125311664

## 6.2 对象克隆

当拷贝一个对象时，新对象与原始对象引用的是同一个对象，对新对象修改时原始对象也会改变

```java
Employee e = new Employee("John",1000.0);
Employee copy = e;
copy.raiseSalary(10);
//这时两个对象的薪水都改变了
```

如果要创建一个新的对象，对它的操作不影响原始变量，就需要使用克隆clone

```java
Employee copy = e.clone();
```

**克隆又分为深拷贝和浅拷贝两种，默认使用浅拷贝**

1. 浅拷贝 

   如果原始对象中的实例都为基本数据类型，不会有问题，如果原始对象中存在对子对象的引用，那么新对象仍会引用相同的子对象，这样来说并没有完全解决问题

2. 深拷贝

重新对clone进行定义，以实现克隆子对象的深拷贝

对于每一个类，需要做出以下判断

* 默认的clone方法是否满足要求
* 默认的clone方法是否可以通过调用子对象的clone得到修补
* 是否不应该使用clone

```java
   public Employee clone() throws CloneNotSupportedException{
            Employee cloned = (Employee)super.clone();
            cloned.hireDay = (Date)hireDay.clone();
            return cloned;
                }
```

## 6.3 接口与回调

回调指发生某个特定事件时应该采取的动作

这里以一个定时器为例

```java
public class MyTimer implements ActionListener {
    @Override
    public void actionPerformed(ActionEvent actionEvent) {
        Date now = new Date();
        System.out.println("at the tone,the time is "+now);
        Toolkit.getDefaultToolkit().beep();
    }
}

```

## 6.4 内部类

内部类指定义在另外一个类内部的类，他的方法可以访问外部类的域，使用内部类的原因

*  内部类可以访问所在类的数据，包括私有类型
*  内部类能够对同一个包中的其他类隐藏起来
*  想要写一个回调函数且不想写大量代码时，用匿名内部类比较便捷

1.静态内部类才可以声明静态方法

2.静态方法不可以使用非静态变量

3.抽象方法不可以有函数体

1.为什么使用内部类?
使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，
对于内部类都没有影响
1.1.使用内部类最大的优点就在于它能够非常好的解决多重继承的问题,使用内部类还能够为我们带来如下特性:
(1)、内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独。
(2)、在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。
(3)、创建内部类对象的时刻并不依赖于外围类对象的创建。
(4)、内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。
(5)、内部类提供了更好的封装，除了该外围类，其他类都不能访问。

# 7-图形化编程

# 新建一个桌面计时器

## 1. 初始化窗口

```java
 private void init() {
        //指定窗口名
        frame = new JFrame("计时器");
        /**
         * j10指定一条标签及其内容
         * 例如
         * <html>
         *     <h1>hello world</h1>
         * </html>
         * */
        jl0 = new JLabel();

        JPanel jp = new JPanel();
        jp.add(jl0);
        frame.add(jp);
        
        //设置窗口及其位置
        frame.setVisible(true);
        frame.setLocation(300, 400);
        frame.setSize(330, 200);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    }
```

## 2.准备构造方法

通过构造方法声明窗口

```java
    public TimerBox() {
        //直接调用窗口初始化方法
        init();
    }
```

## 3. 设置窗口内容

通过标签以及j10为窗口设置需要显示的内容

```java
  public void timer(){
        String s = "<html><h1>hello world</h1></html>";
        jl0.setText(s);
    }

```

运行效果

![image-20211010155137439](E:\gitfile\notes\Java\image-20211010155137439.png)

完整代码

```java
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
public class TimerBox {
    private JFrame frame;
    private JLabel jl0;
    public static void main(String[] args) {
        TimerBox tb = new TimerBox();
        tb.timer();
    }
    public TimerBox() {
        init();
    }
    public void timer(){
        String s = "<html><h1>hello world</h1></html>";
        jl0.setText(s);
    }
    private void init() {
        frame = new JFrame("计时器");   
        jl0 = new JLabel();
        JPanel jp = new JPanel();
        jp.add(jl0);
        frame.add(jp);
        frame.setVisible(true);
        frame.setLocation(300, 400);
        frame.setSize(330, 200);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    }
}
```



## 4. 实例：桌面计时器

### 添加点击事件

1. 首先声明按钮组件

```java
 		JButton jb = new JButton("暂停");

        ActionListener actionListener = new ClickAction();
        jb.addActionListener(actionListener);

        JPanel jp = new JPanel();
        jp.add(jb);
```

2. JButton对象有一个添加点击事件的方法addActionListener（），该方法的参数是一个实现了ActionListener接口的类
3. 因此需要自定义一个实现了ActionListener接口的类，并把点击处理逻辑放在其actionPerformed方法中

**建议将 ClickAction定义为内部类**

```java
package graphics;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

/**
 * @author :modige
 * @description :此类用于实现处理点击事件的方法
 * @date :2021/10/10 16:17
 */
public class ClickAction implements ActionListener {
    public ClickAction(){

    }

    @Override
    public void actionPerformed(ActionEvent actionEvent) {
        System.out.println("clicked");
    }
}

```

**此时如果点击”暂停“按钮，程序会按ClickAction类actionPerformed方法中写的输出clicked**



全部代码

```java
package graphics;

import javax.swing.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Date;
import java.util.concurrent.ScheduledThreadPoolExecutor;

import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;

import java.util.concurrent.TimeUnit;

/**
 * @author :modige
 * @description :用于统计学习时间的一个计时器
 * @date :2021/10/10 15:31
 */
public class TimerBox {
    /**
     * frame : 窗口
     * jp   ：表盘
     * j10  :内容标签
     * flag :用来区分暂停与开始
     * count:用来记录秒数
     * */


    private JFrame frame;
    private JPanel jp;
    private JLabel jl0;
    private boolean flag;
    private int count;

    private ScheduledThreadPoolExecutor scheduled;

    static final String JDBC_DRIVER = "com.mysql.cj.jdbc.Driver";
    static final String DB_URL = "jdbc:mysql://localhost:3306/mybatis?useSSL=false&allowPublicKeyRetrieval=true&serverTimezone=UTC";

    static final String USER = "root";
    static final String PASS = "123456";

    public static void main(String[] args) {
        TimerBox tb = new TimerBox();
        tb.timer();

    }

    public TimerBox() {
        scheduled = new ScheduledThreadPoolExecutor(2);
        init();
    }
    /**
     * 计时方法
     * */
    public void timer(){ //计时开始
        scheduled.scheduleAtFixedRate(new Runnable() { //使用匿名类作为参数
            @Override
            public void run() {



                if (flag){ //如果flag为真，说明是开始状态，count每秒加一
                    count++;
                    long hour = count / 3600;
                    long minute = ( count - hour * 3600) / 60;
                    long seconds =  count- hour * 3600 - minute * 60;
                    StringBuilder timer = new StringBuilder();
                    timer.append("<html><br><h1>已经开始<br>").append(hour).append("时 ").append(minute).append("分 ").append(seconds).append("秒 ")
                            .append("</h1></br></html>");
                    jl0.setText(timer.toString());
                }
                //否则为暂停状态，count不变
            }
        }, 0, 1, TimeUnit.SECONDS);
    }

    /** 生成窗口
    *  */
    private void init() {

        frame = new JFrame("计时器");  //指定窗口名
        /**
         * j10指定一条标签及其内容
         * 例如
         * <html>
         *     <h1>hello world</h1>
         * </html>
         * */
        jl0 = new JLabel();

        JButton jbBegin = new JButton("开始");     //开始按钮

        JButton jbPause = new JButton("暂停");      //暂停按钮
        jbPause.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent actionEvent) {
                flag = false;
                System.out.println("已暂停，时间为："+new Date());
                String sql = "insert into timer values('"+new Date()+"','"+"暂停')";
                SqlConnect sc = new SqlConnect(sql);
                sc.connect();

            }
        });

        jbBegin.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent actionEvent) {
                flag = true;

                String sql = "insert into timer values('"+new Date()+"','"+"开始')";
                SqlConnect sc = new SqlConnect(sql);
                sc.connect();
            }
        });


        jp = new JPanel();
        jp.add(jl0);
        flag = true;
        jp.add(jbBegin);
        jp.add(jbPause);
        frame.add(jp);
        count = 0;

        //设置窗口及其位置
        frame.setVisible(true);
        frame.setLocation(300, 400);
        frame.setSize(330, 200);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    }


    /**
     * @author :modige
     * @description :数据库访问，用于将暂停与开始时间发生的时间记录到数据库
     * @date :2021/10/11 9:39
     */
       class SqlConnect {

        private String sqlQuery;

        static final String JDBC_DRIVER = "com.mysql.cj.jdbc.Driver";
        static final String DB_URL = "jdbc:mysql://localhost:3306/mybatis?useSSL=false&allowPublicKeyRetrieval=true&serverTimezone=UTC";

        static final String USER = "root";
        static final String PASS = "123456";

        public SqlConnect(String s){
            sqlQuery = s;
        }

        public void connect(){
            Connection conn = null;
            Statement stmt = null;
            try{
                // 注册 JDBC 驱动
                Class.forName(JDBC_DRIVER);

                // 打开链接
                System.out.println("连接数据库...");
                conn = DriverManager.getConnection(DB_URL,USER,PASS);

                // 执行查询
                System.out.println(" 实例化Statement对象...");
                stmt = conn.createStatement();
                //查询专用语句
//            ResultSet rs = stmt.executeQuery(sqlQuery);
                //插入语句
                stmt.execute(sqlQuery);

                // 完成后关闭

                stmt.close();
                conn.close();
            }catch(SQLException se){
                // 处理 JDBC 错误
                se.printStackTrace();
            }catch(Exception e){
                // 处理 Class.forName 错误
                e.printStackTrace();
            }finally{
                // 关闭资源
                try{
                    if(stmt!=null) stmt.close();
                }catch(SQLException se2){
                }// 什么都不做
                try{
                    if(conn!=null) conn.close();
                }catch(SQLException se){
                    se.printStackTrace();
                }
            }
            System.out.println("Goodbye!");
        }
    }


}

```



# 11-异常

# 异常 日志 断言 调试

## 11.1 处理异常

  如果出现错误，程序应该

* 返回到一种安全状态，并能够让用户执行一些命令，或者
* 允许用户保存所有操作的结果，并以适当的方式终止程序

**常见错误**

1. 用户输入错误
2. 设备错误
3. 物理限制
4. 代码错误

### 11.1.1 异常分类

![image-20211008205504453](C:\Users\modige\AppData\Roaming\Typora\typora-user-images\image-20211008205504453.png)

所有的异常都继承自Throwable，但在下一层分为Error和Exception

* Error类层次结构描述了Java运行时系统的内部错误和资源耗尽错误。
* 系统主要关注Exception层次结构

**Exception又分为两个分支，一个分支派生于RuntimeException,另一个分支包含其他异常**

派生于RuntimeException的异常包含以下几种情况

* 错误的类型转换
* 数组访问越界
* 访问空指针

**其他异常包括**

* 试图在文件尾部读取数据
* 试图打开一个错误格式的URL、
* 试图根据给定的字符串查找Class对象，而这个字符串表示的类不存在

**Java语言规范将所有派生于Error和Exception的异常称为未检查异常，其他异常称为已检查异常**、

### 11.1.2 声明已检查异常

方法应该在其首部声明所有可能出现的已检查异常、



### 11.1.3如何抛出异常

 对于一个已经存在的异常类，将其抛出非常容易，在这种情况下

1. 找到一个合适的异常类
2. 创建这个类的一个对象
3. 将对象抛出

一旦方法抛出了异常，这个方法就不可能返回到调用者，也就是说不用为返回的默认值或错误代码担忧

### 11.1.4 创建异常类

* 当标准异常类不能充分描述问题时，需要创建自己的异常类

* 需要做的是定义一个派生于Exception或者其子类的类
* 习惯上定义的类应该包含两个构造器，一个是默认的构造器，另一个是带有详细描述信息的构造器

## 11.2 捕获异常

 到目前为止，已经知道如何抛出一个异常

要想捕获一个异常，必须设置try/catch语句块，最简单的try语句块如下所示



```java
try{
    code;
}
catch(Exception e){
    handler for this type
}
```

如果在try语句块抛出了任何一个在catch中说明的异常类，那么

1.  程序将跳过try语句块中的其他代码
2.  程序将执行catch字句中的处理器代码

如果没有出现异常，程序将跳过catch字句

### 11.2.1捕获多个异常

在一个try字句中可以捕获多个异常类型，并对不同类型的异常做出不同的处理

```java
try{
    
}
catch(Exception e1){
}
catch(Exception e2){
    
}
```

### 11.2.2 再次抛出异常

在catch字句中可以抛出一个异常，这是为了改变异常类型

### 11.2.3 finally字句



根据官方的JVM规范：
**如果try语句里有return，返回的是try语句块中变量值。**
详细执行过程如下：

1. 如果有返回值，就把返回值保存到局部变量中；
2. 执行jsr指令跳到finally语句里执行；
3. 执行完finally语句后，返回之前保存在局部变量表里的值。



![img](https://uploadfiles.nowcoder.com/images/20211028/348470426_1635431780619/6479D7BB01736CCC61B8270D41F00B17)



## throw&throws

* [Java中throw和throws有什么区别？](https://blog.csdn.net/weixin_46511008/article/details/118770337)

### 一、说明：

> 1. **throw 在方法体内使用，throws 在方法声明上使用；**
>
> 2. throw 后面接的是异常对象，只能接一个。throws 后面接的是异常类型，可以接多个，多个异常类型用逗号隔开；
>
> 3. throw 是在方法中出现不正确情况时，手动来抛出异常，结束方法的，执行了 throw 语句一定会出现异常。而 throws 是用来声明当前方法有可能会出现某种异常的，如果出现了相应的异常，将由调用者来处理，声明了异常不一定会出现异常。
>
>    

### 二、相关解析

throw 和 throws 都是用来进行 Java 异常处理的。

1、其中，throw 是用在某个方法的方法体内的，当我们认定某种情况不合理时，就可以创建异常对象，封装好异常信息，然后通过 throw 来抛出异常并终止该方法。

```java
public class CustomerLevel {
    // 性别
    private String level;
    public String getLevel() {
    	return level;
	}

	public void setLevel(String level) {
        if (!("会员".equals(level) || "普通用户".equals(level))) {
            //throw用在setLevel(String level)方法的方法体内
            throw new IllegalArgumentException("非法用户：" + level);
        }
   	 this.level = level;
	}
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
```

2、而 throws 是用在某个方法的方法声明上的，表示当前方法如果抛出了某些异常，将由调用者来进行异常处理。这种方式也可以让调用者知晓该对哪些异常进行处理。throws 声明的异常不一定会出现，只是一种可能。
public class FileInputStream extends InputStream {
    //throws用在FileInputStream(String namwe)方法的方法声明上的
    public FileInputStream(String name) throws FileNotFoundException {
        this(name != null ? new File(name) : null);
    }
}
————————————————
版权声明：本文为CSDN博主「我不是你不是我」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_46511008/article/details/118770337

# 12-泛型

## 12.2 简单泛型的定义

**一个泛型类**就是具有一个或多个类型变量的类

换句话说，泛型类可以看成普通类的工厂

```java
package Generic;

import lombok.Data;

/**
 * @description :一个简单的泛型类例子
 * 引入了一个类型变量T
 * 
 * @author      :modige
 * @date        :2021-10-9
 * */
@Data
public class Pair<T> {
    //实例域
    private T first;
    private T secend;

     //构造方法
     public Pair(){first = null;secend=null;}
     public Pair(T first,T secend){
         this.first = first;
         this.secend = secend;
     }

     public T getFirst(){return first;}
     public T getSecond(){return secend;}
     public void setFirst(T newValue){first = newValue;}
     public void setSecond(T newValue){secend = newValue;}
     /**
      * 已有*/

}

```

在java库中，使用

* E表示集合的元素类型

* K和V表示表的关键字与值的类型
* T（必要时还可以用邻近的字母U和S）表示任意类型

## 12.3 泛型方法

```java
public static <T> T gerMiddle(T[] a){
         return a[a.length/2];
     }
```

泛型方法可以定义在普通类中，也可以定义在泛型类中

## 12.4 类型方法的限定

## 12.5 泛型代码与虚拟机

虚拟机没有泛型类型对象，所有对象都属于普通类。

# 13-集合

## 13.1 集合接口

### 13.1.1 将集合的接口与实现分离

Java 集合类库将接口与实现分离。以队列(queue）为例介绍

一个队列的最小形式如下

```java
interface Queue<E>{
void add(E element);
E remove;
int size();
}
```

通常队列的实现有两种方法，分别是循环数组和链表



### 13.1.2 Java 类库中的集合接口和迭代器接口

在Java类库中，集合类的基本接口是Collection接口。

这个接口有两个基本方法

```java
public interface Collection<E>{
    boolean add(E element);
    Iterator <E> iterator();
    ...
}
```

add方法用于向集合添加元素。如果添加元素成功返回true，失败（例如集合中已经存在要添加的元素）返回false

iterator方法返回一个实现了Iterator接口的对象，可以用这个迭代器对象遍历集合中的元素

**迭代器**：Iterator接口包含三个方法

```java
public interface Iterator<E>{
    E next();
    boolean hasNext();
    void remove();
}
```

通过反复调用next（）方法，可以逐个访问集合的每个元素

## 13.2 具体的集合

1. 链表  List 、LinkedList
2. 数组列表 ArrayList 实现了List
3. 散列集 HashSet 
4. 树集 TreeSet
5. 

散列



## 线程安全

Collection 是对象集合， Collection 有两个子接口 List 和 Set,

**有且只有Vector和HashTable线程安全**

Vector和Hashtable中的方法有synchronized修饰

两者虽然线程安全，但是性能变差，因为线程加锁需要监控时间

------

List 可以通过下标 (1,2..) 来取得值，值可以重复,而 Set 只能通过游标来取值，并且值是不能重复的

ArrayList ， Vector ， LinkedList 是 List 的实现类

ArrayList 是线程不安全的， Vector 是线程安全的，这两个类底层都是由数组实现的

LinkedList 是线程不安全的，底层是由链表实现的

------

Map 是键值对集合

HashTable 和 HashMap 是 Map 的实现类

HashTable 是线程安全的，不能存储 null 值

HashMap 不是线程安全的，可以存储 null 值

# 14-多线程

# 1.线程的概念



# 14.4 线程属性

## 14.4.1 线程优先级

- 线程继承父线程的优先级

- setPriority可以设置线程优先级，可以设置为1-10之间的值

## 14.4.2 守护线程

- 使用t.setDaemon(true)调用

守护线程的唯一用途就是为其他线程提供服务。

## 14.4.3 未捕获异常处理器

# 14.5 同步

## 14.5.2 详解竞争条件

假设两个线程都要执行以下语句

- 取出accounts

- accounts += 500

- 放回accounts

如果线程一执行完前两步就被剥夺了运行权，线程二执行结束后线程一又执行了第三步，那么线程二所做的修改将被抹去

## 14.5.3 锁对象

从java se 5以后，有两种机制防止代码块受并发控制的干扰。

- synchronized关键字

- 14.5.5 synchronized关键字

- volatile能保证数据的可见性，但不能完全保证数据的原子性，

- synchronized即保证了数据的可见性也保证了原子性





（645页）

- 锁用来保护代码片段，任何时刻只能有一个线程执行被保护的代码

- 所可以管理试图进入被保护代码的线程

- 锁可以拥有一个或多个相关的条件对象

- 每个条件对象管理那些已经进入被保护的代码段但还不能运行的线程

如果一个方法使用synchronized声明，那么对象的锁将保护整个方法，也就是说，要调用该方法，线程必须获得对象的内部锁

## 14.5.8 volatile域

有时，仅仅需要读写一两个实例域就使用同步，显得开销太大了。

***\*volatile关键字为实例域的同步访问提供了一种免锁机制\**，如果声明一个域为volatile，那么编译器和虚拟机就知道该域是可能被另一个进程并发更新的**

volatile变量不能提供原子性，

总之，在以下三种情况下域的并发访问是安全的

1. 域是final,并且在构造完成后被访问

2. 对域的访问由共有的锁进行保护

3. 域是valatile的

## 14.10 同步器



同步器



类

它能做什么

何时使用

CyclicBarrier

允许线程集等待直至其中预定数目的线程到达一个公共障栏，然后可以选择执行一个处理障栏的动作

当大量的线程需要在他们的结果可用之前完成时
