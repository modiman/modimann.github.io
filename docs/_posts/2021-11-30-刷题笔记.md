## [155. 最小栈](https://leetcode-cn.com/problems/min-stack/)

设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

```push(x)``` —— 将元素 x 推入栈中。
```pop() ```—— 删除栈顶的元素。
```top() ```—— 获取栈顶元素。
```getMin()``` —— 检索栈中的最小元素。

示例:

```
输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```

### 思路

* 使用两个栈，一个stackData存放数据，另一个stackMin存放当前时刻数据栈最小值

### 入栈规则

对于新数据val

* 如果stackMin为空，val入栈，否则比较val与stackMin栈顶元素，如果val更小或者相等，val入stackMin，这样能保证stackMin的栈顶元素永远是数据栈最小值，**相等也入栈是为了处理重复的最小值**
* val入stackData

### 出栈规则

* val==stackMin.peek

### 代码

```java
class MinStack {
    private Stack<Integer> stackData;
    private Stack<Integer> stackMin;


    public MinStack() {
        this.stackData = new Stack<Integer>();
        this.stackMin = new Stack<Integer>();
    }
    
    public void push(int val) {
        if (this.stackMin.isEmpty()){
            this.stackMin.push(val);
        }
        else if(val <= this.getMin()){
             this.stackMin.push(val);

        }
        this.stackData.push(val);

    }
    
    public void pop() {
        if(this.stackData.isEmpty()){
            throw new RuntimeException("Empty");
        }
        int val = this.stackData.pop();
        if (val == this.getMin()){
            this.stackMin.pop();
        }

    }
    
    public int top() {
        return stackData.peek();

    }
    
    public int getMin() {
        if(this.stackMin.isEmpty()){
            throw new RuntimeException("Empty");
        }
        return this.stackMin.peek();


    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(val);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
```

#### [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)

难度简单512收藏分享切换为英文接收动态反馈

请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（`push`、`pop`、`peek`、`empty`）：

实现 `MyQueue` 类：

- `void push(int x)` 将元素 x 推到队列的末尾
- `int pop()` 从队列的开头移除并返回元素
- `int peek()` 返回队列开头的元素
- `boolean empty()` 如果队列为空，返回 `true` ；否则，返回 `false`

 

**说明：**

- 你只能使用标准的栈操作 —— 也就是只有 `push to top`, `peek/pop from top`, `size`, 和 `is empty` 操作是合法的。
- 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。

 

**进阶：**

- 你能否实现每个操作均摊时间复杂度为 `O(1)` 的队列？换句话说，执行 `n` 个操作的总时间复杂度为 `O(n)` ，即使其中一个操作可能花费较长时间。

 

**示例：**

```
输入：
["MyQueue", "push", "push", "peek", "pop", "empty"]
[[], [1], [2], [], [], []]
输出：
[null, null, null, 1, 1, false]

解释：
MyQueue myQueue = new MyQueue();
myQueue.push(1); // queue is: [1]
myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)
myQueue.peek(); // return 1
myQueue.pop(); // return 1, queue is [2]
myQueue.empty(); // return false
```

### 思路

* 准备两个栈stackPush ，stackPop
* 当需要push时，将数据压入stackPush
* 当需要pop时，为了将数逆序处理，全部弹出到stackPop,此时stackPop中数的顺序即为先进的在栈顶，符合队列的先进先出
* 当需要peek时，与pop做相同处理
* 当stackPush与stackPop都为空时，队列为空

### 代码

```java
class MyQueue {
    private Stack<Integer> stackPush;
    private Stack<Integer> stackPop;

    public MyQueue() {
        stackPush = new Stack<Integer> ();
        stackPop = new Stack<Integer>() ;
    }
    
    public void push(int x) {
        stackPush.push(x);

    }
    
    public int pop() {
        if (stackPush.empty()&&stackPop.empty()){
            throw new RuntimeException("Empty");
        }
        else if(stackPop.empty()){
            while(!stackPush.empty()){
                stackPop.push(stackPush.pop());
            }
            
        }
        return stackPop.pop();
    }
    
    public int peek() {
        if (stackPush.empty()&&stackPop.empty()){
            throw new RuntimeException("Empty");
        }
        else if(stackPop.empty()){
            while(!stackPush.empty()){
                stackPop.push(stackPush.pop());
            }
            
        }
        return stackPop.peek();

    }
    
    public boolean empty() {
        return stackPop.empty()&&stackPush.empty();
    }
}

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue obj = new MyQueue();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.peek();
 * boolean param_4 = obj.empty();
 */
```

