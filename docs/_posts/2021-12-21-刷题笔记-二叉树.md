# [剑指 Offer II 048. 序列化与反序列化二叉树](https://leetcode-cn.com/problems/h54YBf/)

难度困难14

序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。

请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg)

```
输入：root = [1,2,3,null,null,4,5]
输出：[1,2,3,null,null,4,5]
```

**示例 2：**

```
输入：root = []
输出：[]
```

**示例 3：**

```
输入：root = [1]
输出：[1]
```

**示例 4：**

```
输入：root = [1,2]
输出：[1,2]
```

 

**提示：**

- 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 [LeetCode 序列化二叉树的格式](https://leetcode-cn.com/faq/#binary-tree)。你并非必须采取这种方式，也可以采用其他的方法解决这个问题。
- 树中结点数在范围 `[0, 104]` 内
- `-1000 <= Node.val <= 1000`

```java
// Your Codec object will be instantiated and called as such:
// Codec ser = new Codec();
// Codec deser = new Codec();
// TreeNode ans = deser.deserialize(ser.serialize(root));
```



 ## 思路

注意调用方式，只需要能够使用序列化得到的字符串恢复成树即可

* 序列化也即层次遍历二叉树之后返回字符串
* 反序列化即根据上述字符串建立二叉树并返回

为了能根据序列化得到的字符串恢复二叉树，有以下问题

* 如何判断字符串中的字符是哪个节点的值，即如何将字符串恢复为整数
* 如何判断空节点null

解决方案：

* 将节点值以特殊字符隔开，比如！
* 用特殊字符表示空节点，比如#

**上述例子序列化后可以表示为**

root = [1,2,3,null,null,4,5]     - ->       1！2！3!#!#!4！5！

## 代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Codec {

    // Encodes a tree to a single string.
    //借助队列完成对二叉树的层次遍历，并
    public String serialize(TreeNode root) {
        if(root==null) return "#";
        String res = root.val + "!";
        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);
        while(!q.isEmpty()){
            TreeNode curNode = q.poll();
            if(curNode.left!=null){
                res = res + curNode.left.val + "!";
                q.offer(curNode.left);
            }
            else res = res + "#!";

             if(curNode.right!=null){
                res = res + curNode.right.val + "!";
                q.offer(curNode.right);
            }
            else res = res + "#!";
        }
    
        return res;   
    }

    // Decodes your encoded data to tree.
    
    public TreeNode deserialize(String data) {
        
        String[] values = data.split("!");
        int index = 0;

        TreeNode head = recon(values[index++]);

        Queue<TreeNode> q = new LinkedList<>();

        if(head!=null){
            q.offer(head);
        }
        TreeNode node = null;
        while(!q.isEmpty()){
            node = q.poll();
            node.left = recon(values[index++]);
            node.right = recon(values[index++]);
            if(node.left!=null){
                q.offer(node.left);
            }
            if(node.right!=null){
                q.offer(node.right);
            }

        }
       return head;
    }

    public TreeNode recon(String v){
            if(v.equals("#")){
                return null;
            }
            return new TreeNode(Integer.valueOf(v));
    }
}

// Your Codec object will be instantiated and called as such:
// Codec ser = new Codec();
// Codec deser = new Codec();
// TreeNode ans = deser.deserialize(ser.serialize(root));
```

# [剑指 Offer 07. 重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)

难度中等632

输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。

假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

 

**示例 1:**

![img](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)

```
Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
Output: [3,9,20,null,null,15,7]
```

**示例 2:**

```
Input: preorder = [-1], inorder = [-1]
Output: [-1]
```

## 思路

* 先序遍历第一个数字是二叉树的头节点

* 中序遍历中,头结点左边的部分是左子树的中序遍历

* 中序遍历中,头节点右边的部分是右子树的中序遍历

* 假设左子树长度为k,先序数组中头结点之后k个结点是左子树的先序遍历

* 先序数组中除去头节点和左子树部分剩下的部分是右子树的先序遍历

* 以上步骤可以递归

  所需参数

* pi记录先序数组的开始下表

* pj记录先序数组的结束下表

* ni记录中序数组的开始下表

* nj记录中序数组的结束下表

* index记录头结点在中序数组中的下标,用来判断新的子树的先序结束与中序数组开始位置

## 代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        if(preorder==null||inorder==null){
            return null;
        }
        HashMap<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<preorder.length;i++){
            //题目假设无重复数字
            map.put(inorder[i],i);
        }
        return reCon(preorder,0,preorder.length-1,inorder,0,inorder.length-1,map);

    }

    public TreeNode reCon(int[]p,int pi,int pj,int[]n,int ni,int nj,HashMap<Integer,Integer> map){
       
        if(pi>pj){
            return null;
        }
        TreeNode head = new TreeNode(p[pi]);
        int index = map.get(p[pi]);
        head.left = reCon(p,pi+1,pi+index-ni,n,ni,index-1,map);
        head.right = reCon(p,pi+index-ni+1,pj,n,index+1,nj,map);
        return head;
    }
}
```

