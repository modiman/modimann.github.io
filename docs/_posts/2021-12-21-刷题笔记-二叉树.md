# [剑指 Offer II 048. 序列化与反序列化二叉树](https://leetcode-cn.com/problems/h54YBf/)

难度困难14

序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。

请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg)

```
输入：root = [1,2,3,null,null,4,5]
输出：[1,2,3,null,null,4,5]
```

**示例 2：**

```
输入：root = []
输出：[]
```

**示例 3：**

```
输入：root = [1]
输出：[1]
```

**示例 4：**

```
输入：root = [1,2]
输出：[1,2]
```

 

**提示：**

- 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 [LeetCode 序列化二叉树的格式](https://leetcode-cn.com/faq/#binary-tree)。你并非必须采取这种方式，也可以采用其他的方法解决这个问题。
- 树中结点数在范围 `[0, 104]` 内
- `-1000 <= Node.val <= 1000`

```java
// Your Codec object will be instantiated and called as such:
// Codec ser = new Codec();
// Codec deser = new Codec();
// TreeNode ans = deser.deserialize(ser.serialize(root));
```



 ## 思路

注意调用方式，只需要能够使用序列化得到的字符串恢复成树即可

* 序列化也即层次遍历二叉树之后返回字符串
* 反序列化即根据上述字符串建立二叉树并返回

为了能根据序列化得到的字符串恢复二叉树，有以下问题

* 如何判断字符串中的字符是哪个节点的值，即如何将字符串恢复为整数
* 如何判断空节点null

解决方案：

* 将节点值以特殊字符隔开，比如！
* 用特殊字符表示空节点，比如#

**上述例子序列化后可以表示为**

root = [1,2,3,null,null,4,5]     - ->       1！2！3!#!#!4！5！

## 代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Codec {

    // Encodes a tree to a single string.
    //借助队列完成对二叉树的层次遍历，并
    public String serialize(TreeNode root) {
        if(root==null) return "#";
        String res = root.val + "!";
        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);
        while(!q.isEmpty()){
            TreeNode curNode = q.poll();
            if(curNode.left!=null){
                res = res + curNode.left.val + "!";
                q.offer(curNode.left);
            }
            else res = res + "#!";

             if(curNode.right!=null){
                res = res + curNode.right.val + "!";
                q.offer(curNode.right);
            }
            else res = res + "#!";
        }
    
        return res;   
    }

    // Decodes your encoded data to tree.
    
    public TreeNode deserialize(String data) {
        
        String[] values = data.split("!");
        int index = 0;

        TreeNode head = recon(values[index++]);

        Queue<TreeNode> q = new LinkedList<>();

        if(head!=null){
            q.offer(head);
        }
        TreeNode node = null;
        while(!q.isEmpty()){
            node = q.poll();
            node.left = recon(values[index++]);
            node.right = recon(values[index++]);
            if(node.left!=null){
                q.offer(node.left);
            }
            if(node.right!=null){
                q.offer(node.right);
            }

        }
       return head;
    }

    public TreeNode recon(String v){
            if(v.equals("#")){
                return null;
            }
            return new TreeNode(Integer.valueOf(v));
    }
}

// Your Codec object will be instantiated and called as such:
// Codec ser = new Codec();
// Codec deser = new Codec();
// TreeNode ans = deser.deserialize(ser.serialize(root));
```

# [剑指 Offer 07. 重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)

难度中等632

输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。

假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

 

**示例 1:**

![img](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)

```
Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
Output: [3,9,20,null,null,15,7]
```

**示例 2:**

```
Input: preorder = [-1], inorder = [-1]
Output: [-1]
```

## 思路

* 先序遍历第一个数字是二叉树的头节点

* 中序遍历中,头结点左边的部分是左子树的中序遍历

* 中序遍历中,头节点右边的部分是右子树的中序遍历

* 假设左子树长度为k,先序数组中头结点之后k个结点是左子树的先序遍历

* 先序数组中除去头节点和左子树部分剩下的部分是右子树的先序遍历

* 以上步骤可以递归

  所需参数

* pi记录先序数组的开始下表

* pj记录先序数组的结束下表

* ni记录中序数组的开始下表

* nj记录中序数组的结束下表

* index记录头结点在中序数组中的下标,用来判断新的子树的先序结束与中序数组开始位置

## 代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        if(preorder==null||inorder==null){
            return null;
        }
        HashMap<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<preorder.length;i++){
            //题目假设无重复数字
            map.put(inorder[i],i);
        }
        return reCon(preorder,0,preorder.length-1,inorder,0,inorder.length-1,map);

    }

    public TreeNode reCon(int[]p,int pi,int pj,int[]n,int ni,int nj,HashMap<Integer,Integer> map){
       
        if(pi>pj){
            return null;
        }
        TreeNode head = new TreeNode(p[pi]);
        int index = map.get(p[pi]);
        head.left = reCon(p,pi+1,pi+index-ni,n,ni,index-1,map);
        head.right = reCon(p,pi+index-ni+1,pj,n,index+1,nj,map);
        return head;
    }
}
```

# [面试题 04.08. 首个共同祖先](https://leetcode-cn.com/problems/first-common-ancestor-lcci/)

难度中等63收藏分享切换为英文接收动态反馈

设计并实现一个算法，找出二叉树中某两个节点的第一个共同祖先。不得将其他的节点存储在另外的数据结构中。注意：这不一定是二叉搜索树。

例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]

```
    3
   / \
  5   1
 / \ / \
6  2 0  8
  / \
 7   4
```

**示例 1:**

```
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
```

**示例 2:**

```
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出: 5
解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。
```

##  思路

**当前根节点是最近公共祖先有以下两种情形**

1. p和q分别在左右（或右左）子树中
2. 当前结点是p或q

程序执行过程：

* 1 自定向下遍历二叉树

* 2 如果根节点是p或q中的一个，说明一个是另一个祖先，返回根节点

* 3 如果根节点是null，说明不存在公共祖先，返回根节点

* 如果不是上述两种情况，需要结合左子树、右子树判断

* 分别判断左右子树是否为空、是否为p、q

  

## 代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode head, TreeNode p, TreeNode q) {
        //如果是当前结点是空或p、q，符合情形1，可以直接返回，否则需要根据左右子树情况判断
        if(head==null||head==p||head==q){
            return head;
        }
        
        TreeNode left = lowestCommonAncestor(head.left,p,q);
        TreeNode right = lowestCommonAncestor(head.right,p,q);
        
        //如果左右子树都不为空，符合情形二
        if(left!=null&&right!=null) return head;
        //如果左孩子不为空，说明左孩子是p或q，返回左孩子，否则返回右孩子
        return left!=null?left:right;

    }
}
```

# [114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

难度中等1009收藏分享切换为英文接收动态反馈

给你二叉树的根结点 `root` ，请你将它展开为一个单链表：

- 展开后的单链表应该同样使用 `TreeNode` ，其中 `right` 子指针指向链表中下一个结点，而左子指针始终为 `null` 。
- 展开后的单链表应该与二叉树 [**先序遍历**](https://baike.baidu.com/item/先序遍历/6442839?fr=aladdin) 顺序相同。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg)

```
输入：root = [1,2,5,3,4,null,6]
输出：[1,null,2,null,3,null,4,null,5,null,6]
```

**示例 2：**

```
输入：root = []
输出：[]
```

**示例 3：**

```
输入：root = [0]
输出：[0]
```

 

**提示：**

- 树中结点数在范围 `[0, 2000]` 内
- `-100 <= Node.val <= 100`

 

**进阶：**你可以使用原地算法（`O(1)` 额外空间）展开这棵树吗？

通过次数198,919

提交次数273,690

## 思路一

利用一个额外的队列记录先序遍历二叉树得到的结点序列，根据队列建立链表

## 代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public void flatten(TreeNode root) {
        Queue<TreeNode> q = new LinkedList();
        preOrder(root,q);
        TreeNode head = new TreeNode(),ans = head;
        while(!q.isEmpty()){
            TreeNode node = q.poll();
            node.left = null;
            head.right = node;
            head = node;
        }
        head.right = null;
    }
    //先序遍历二叉树
    public void preOrder(TreeNode root,Queue<TreeNode> q){
        if(root!=null){
            q.offer(root);
            preOrder(root.left,q);
            preOrder(root.right,q);
        }
    }
}
```

# [116. 填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

难度中等625收藏分享切换为英文接收动态反馈

给定一个 **完美二叉树** ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

```
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL`。

初始状态下，所有 next 指针都被设置为 `NULL`。

 

**进阶：**

- 你只能使用常量级额外空间。
- 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。

 

**示例：**

![img](https://assets.leetcode.com/uploads/2019/02/14/116_sample.png)

```
输入：root = [1,2,3,4,5,6,7]
输出：[1,#,2,3,#,4,5,6,7,#]
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束。
```

## 思路

注意规律

对于任意结点

* 它的左孩子的next指向它的右孩子
* 它的右孩子的next指向它的右侧结点（即它的next）的左孩子

使用树的任意遍历方式为每个结点设置next指针即可

## 代码

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}
    
    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _left, Node _right, Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
};
*/

class Solution {
    public Node connect(Node root) {
        preorder(root);
        return root;      
    }
    public void preorder(Node root){
        if(root!=null){
            if(root.right!=null)    root.right.next = root.next==null?null:root.next.left;  
            if(root.left!=null)     root.left.next = root.right;
            preorder(root.right);
            preorder(root.left);              
        }
     
    }
}
```



#### [117. 填充每个节点的下一个右侧节点指针 II](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/)

难度中等486收藏分享切换为英文接收动态反馈

给定一个二叉树

```
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL`。

初始状态下，所有 next 指针都被设置为 `NULL`。

 

**进阶：**

- 你只能使用常量级额外空间。
- 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。

 

**示例：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/15/117_sample.png)

```
输入：root = [1,2,3,4,5,null,7]
输出：[1,#,2,3,#,4,5,7,#]
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 next 指针连接），'#' 表示每层的末尾。
```

 

**提示：**

- 树中的节点数小于 `6000`
- `-100 <= node.val <= 100`

 ## 思路

## **与上一题的根本区别是本题中的树不是完全二叉树，指定next指针的方法稍有改变**

对于任意一棵树，它的左孩子（如果存在）的next指针规定为

* 如果存在右孩子，则为右孩子
* 如果不存在右孩子，则在与它同一层的结点中找到第一个有孩子的结点，对于上述例子中的树，加入结点5不存在，那么4的next将指向7，而7是与2同层的结点3的第一个孩子
* 如果上述两种情况都不满足，说明它的左孩子同层中没有更右边的结点，next指向null

它的右孩子（如果存在）的next指针规定为

* 则在与它同一层的结点中找到第一个有孩子的结点，对于上述例子中的树，加入结点5不存在，那么4的next将指向7，而7是与2同层的结点3的第一个孩子
* 否则为null

## 注意

在本题中，需要先遍历右孩子再遍历左孩子，因为这并非一棵完全二叉树，而树的左孩子的next指针依赖于右孩子。

假设树的形状如下，

![image-20211224140325439](E:\gitfile\mypages\modiman.github.io\docs\_posts\image-20211224140325439.png)

采用先序遍历的方式处理这棵树，过程如下

1. 访问结点1

* 2->3   ,3->null

2. 访问结点2

* 4->5,    5->6

3. 访问结点4

* 8->9

4. 访问结点8
5. 访问结点5

* 9->10,    10->null

​       **问题出现**，由于在先前的遍历中，5的next指向6后就没有继续，所以5的右孩子10发现6没有孩子，没有继续访问7的孩子，而是直接将next设置为null,

​      而这样的问题在上题中就不会出现，因为上一题规定所有的结点都有两个孩子，所以这种从左往右逐步前进的方式不会出现断层，也就没有错误

​      为了解决这一问题，可以从右往左遍历，仍然使用先序遍历，只不过先访问右子树，再访问左子树，这样就没有错误了

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}
    
    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _left, Node _right, Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
};
*/

class Solution {
    public Node connect(Node root) {
        preorder(root);
        return root;
        
    }
    public void preorder(Node root){
        if(root!=null){
            if(root.left!=null){
                if(root.right!=null) root.left.next = root.right;
                else root.left.next = getChild(root.next);
            }

             if(root.right!=null){
                  root.right.next = getChild(root.next);
            }
            preorder(root.right);
            preorder(root.left);
           
        }
    }


    public Node getChild(Node root){
        if(root==null) return null;
        while(root!=null){
            if (root.left!=null) return root.left;
            else if(root.right!=null) return root.right;
            else root = root.next;
        }
        return null;
    }
}
```

# [515. 在每个树行中找最大值](https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/)

难度中等162

给定一棵二叉树的根节点 `root` ，请找出该二叉树中每一层的最大值。

 

**示例1：**

```
输入: root = [1,3,2,5,3,null,9]
输出: [1,3,9]
解释:
          1
         / \
        3   2
       / \   \  
      5   3   9 
```

**示例2：**

```
输入: root = [1,2,3]
输出: [1,3]
解释:
          1
         / \
        2   3
```

**示例3：**

```
输入: root = [1]
输出: [1]
```

**示例4：**

```
输入: root = [1,null,2]
输出: [1,2]
解释:      
           1 
            \
             2     
```

**示例5：**

```
输入: root = []
输出: []
```

 

**提示：**

- 二叉树的节点个数的范围是 `[0,104]`
- `-231 <= Node.val <= 231 - 1`

## 思路

利用二叉树的层次遍历

定义一个last指针用来记录每一层的最后一个结点

利用原理   如果当前结点是last，那么当前队列有两种情况：1.有且只有下一层的全部节点 2.队列为空

利用数据结构：双端队列

```java
Deque<TreeNode> q = new LinkedList();
```

## 代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> largestValues(TreeNode root) {
        if(root==null) return new ArrayList<Integer>();
        else if(root.right==null&&root.left==null) 
        {
            List<Integer> ans = new ArrayList();
            ans.add(root.val);

            return ans;

        }
        Deque<TreeNode> q = new LinkedList();
        q.offer(root);
        int max = Integer.MIN_VALUE;
        List<Integer> ans = new ArrayList();
        ans.add(root.val);
        TreeNode last = root;
        while(!q.isEmpty()){
            TreeNode node = q.poll();
            if(node.left!=null) 
            {
                q.offer(node.left);
                if(node.left.val>max){
                    max = node.left.val;
                }

            }
            if(node.right!=null){
                q.offer(node.right);
                if(node.right.val>max){
                    max = node.right.val;
                }
            } 

            if(node == last){

               
                if(q.peek()!=null){
                     ans.add(max);
                max =  Integer.MIN_VALUE;
               // System.out.println(q.getLast().val);

                    last = q.getLast();

                }         
            }

        }
        return ans;
    }
}
```
# [1161. 最大层内元素和](https://leetcode-cn.com/problems/maximum-level-sum-of-a-binary-tree/)

难度中等47

给你一个二叉树的根节点 `root`。设根节点位于二叉树的第 `1` 层，而根节点的子节点位于第 `2` 层，依此类推。

请你找出层内元素之和 **最大** 的那几层（可能只有一层）的层号，并返回其中 **最小** 的那个。

 

**示例 1：**

**![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/08/17/capture.jpeg)**

```
输入：root = [1,7,0,7,-8,null,null]
输出：2
解释：
第 1 层各元素之和为 1，
第 2 层各元素之和为 7 + 0 = 7，
第 3 层各元素之和为 7 + -8 = -1，
所以我们返回第 2 层的层号，它的层内元素之和最大。
```

**示例 2：**

```
输入：root = [989,null,10250,98693,-89388,null,null,null,-32127]
输出：2
```

 

**提示：**

- 树中的节点数介于 `1` 和 `10^4` 之间
- `-10^5 <= node.val <= 10^5`

通过次数11,195

提交次数17,689

## 代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int maxLevelSum(TreeNode root) {
        int max =  Integer.MIN_VALUE;
        int[] sum =new int[]{0};
        int ans = 1;
        int maxheight= 1;
        Deque<TreeNode> q = new LinkedList();
        q.offer(root);
        if(root.val>max) max = root.val;
        TreeNode last = root;


        while(!q.isEmpty()){
            TreeNode node = q.poll();
            if(node.left!=null){
                q.offer(node.left);
                sum[0] += node.left.val;
            }
            if(node.right!=null){
                q.offer(node.right);
                sum[0] += node.right.val;


            }

            if(node==last){
                ans +=1 ;

                if(q.peek()!=null){
                    last = q.getLast();

                    if(sum[0]>max){
                        max = sum[0];
                        maxheight = ans;
                    }


                }
            sum[0] = 0;
            }
        }
//        System.out.println(last.val);
        return maxheight;
    }
}
```



# [222. 完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)

难度中等594

给你一棵 **完全二叉树** 的根节点 `root` ，求出该树的节点个数。

[完全二叉树](https://baike.baidu.com/item/完全二叉树/7773232?fr=aladdin) 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 `h` 层，则该层包含 `1~ 2h` 个节点。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/14/complete.jpg)

```
输入：root = [1,2,3,4,5,6]
输出：6
```

**示例 2：**

```
输入：root = []
输出：0
```

**示例 3：**

```
输入：root = [1]
输出：1
```

 

**提示：**

- 树中节点的数目范围是`[0, 5 * 104]`
- `0 <= Node.val <= 5 * 104`
- 题目数据保证输入的树是 **完全二叉树**

 

**进阶：**遍历树来统计节点是一种时间复杂度为 `O(n)` 的简单解决方案。你可以设计一个更快的算法吗？

## 思路

简单解法：通过遍历二叉树来统计总的节点个数

**注意**：数组是全局变量，整数是局部变量

## 代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int countNodes(TreeNode root) {
        int[] sum = new int[] {0};
        preOrder(root,sum);
        return sum[0];
    }
    public void preOrder(TreeNode root,int[] sum ){
        if(root!=null){
            sum[0]++;
            preOrder(root.left,sum);
            preOrder(root.right,sum);
        }
    }
}
```



## 进阶

递归解法

总个数=左子树节点+右子树节点+本身

**规律**      完全二叉树的左子树或右子树必为满二叉树，满二叉树的节点个数为2<sup>height</sup>-1

假设有一颗高度为h的完全二叉树t

* 如果在t的第h层有右子树上的叶子节点，那么t的左子树必为满二叉树   此时二叉树的节点总数=2<sup>height-1</sup>-1 + （右子树节点总数） + 1
* 如果在t的第h层没有右子树上的叶子节点，则t的右子树必为满二叉树，此时二叉树的节点总数=2<sup>height-2</sup>-1 + （左子树节点总数） + 1

2的幂运算可以使用左移运算符实现  2<sup>height</sup> = 1<<height

满二叉树的节点个数使用公式计算

完全二叉树的节点个数使用递归计算

## 代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int countNodes(TreeNode root) {
        if(root==null) return 0;

        return bs(root,1,height(root,1));
    }

    //求 以 当前节点为根节点的二叉树的节点个数
    public int bs(TreeNode node,int l,int h){
        //如果当前层数为树的高度，说明是叶子节点，返回1
        if(l==h){
           return 1;
        }
        //如果当前节点的右子树高度为树的高度-1，说明左子树是满二叉树，树的节点个数为 左子树+1+右子树
        
        if(height(node.right,l+1)==h){
            return (1<<(h-l))+bs(node.right,l+1,h);
        
        }

        //否则说明左子树不为满二叉树，右子树是一个少一层的满二叉树，总结点=右子树个数+1+左子树个数
        else{
            return (1<<(h-l-1))+bs(node.left,l+1,h);
        }
    }
    public int height(TreeNode node,int level){
        while(node!=null){
            level++;
            node = node.left;
        }
        return level-1;
    }
}
```

# [513. 找树左下角的值](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)

难度中等224

给定一个二叉树的 **根节点** `root`，请找出该二叉树的 **最底层 最左边** 节点的值。

假设二叉树中至少有一个节点。

 

**示例 1:**

![img](https://assets.leetcode.com/uploads/2020/12/14/tree1.jpg)

```
输入: root = [2,1,3]
输出: 1
```

**示例 2:**

![img](https://assets.leetcode.com/uploads/2020/12/14/tree2.jpg)

```
输入: [1,2,3,4,null,5,6,null,null,7]
输出: 7
```

 

**提示:**

- 二叉树的节点个数的范围是 `[1,104]`
- `-231 <= Node.val <= 231 - 1` 

## 思路 

* 利用二叉树的非递归遍历
* 当遇到叶子节点时，栈的长度就是这个叶子节点的层数
* 找到最深的叶子节点即可

## 代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

class Solution {

     public int findBottomLeftValue(TreeNode root) {
        Stack<TreeNode> stack = new Stack<>();
        int max = 0;
        TreeNode maxNode = root;
        stack.push(root);
        HashSet<TreeNode> set = new HashSet<>();
        set.add(root);
        while (!stack.isEmpty()){
            TreeNode node = stack.peek();
            if (node.left!=null&&!set.contains(node.left)){
                stack.push(node.left);
                set.add(node.left);
            }
            else if(node.right!=null&&!set.contains(node.right)){
                stack.push(node.right);
                set.add(node.right);
            }
            else {
                if (stack.size()>max) {
                    max = stack.size();
                    maxNode = node;

                }
                stack.pop();
            }
        }
        return maxNode.val;
    }
}
```

# [113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)

难度中等638

给你二叉树的根节点 `root` 和一个整数目标和 `targetSum` ，找出所有 **从根节点到叶子节点** 路径总和等于给定目标和的路径。

**叶子节点** 是指没有子节点的节点。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg)

```
输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：[[5,4,11,2],[5,8,4,5]]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg)

```
输入：root = [1,2,3], targetSum = 5
输出：[]
```

**示例 3：**

```
输入：root = [1,2], targetSum = 0
输出：[]
```

 

**提示：**

- 树中节点总数在范围 `[0, 5000]` 内
- `-1000 <= Node.val <= 1000`
- `-1000 <= targetSum <= 1000`

## 思路

非递归遍历树，栈中元素即路径

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        List<List<Integer>> ans = new ArrayList<>();
        if(root==null) return ans;
         Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        HashSet<TreeNode> set = new HashSet<>();
        set.add(root);
       
        List<Integer> path = new ArrayList<>();
        path.add(root.val);

        while (!stack.isEmpty()){
            TreeNode node = stack.peek();
            if (node.left!=null&&!set.contains(node.left)){
                stack.push(node.left);
                path.add(node.left.val);

                set.add(node.left);
            }
            else if(node.right!=null&&!set.contains(node.right)){
                stack.push(node.right);
                path.add(node.right.val);

                set.add(node.right);
            }
            else {

                if(node.left==null&&node.right==null){
                    int sum = 0;
                    List<Integer> a = new ArrayList<>();

                    for (Integer i:path) sum+=i;
                    if (sum==targetSum)

                    {                
                        a.addAll(path);
                        ans.add(a);
                    }

                }
                path.remove(path.size()-1);
                stack.pop();
            }
        }
        return ans;
    }
}
```

#### [剑指 Offer II 054. 所有大于等于节点的值之和](https://leetcode-cn.com/problems/w6cpku/)

难度中等8

给定一个二叉搜索树，请将它的每个节点的值替换成树中大于或者等于该节点值的所有节点值之和。

 

提醒一下，二叉搜索树满足下列约束条件：

- 节点的左子树仅包含键 **小于** 节点键的节点。
- 节点的右子树仅包含键 **大于** 节点键的节点。
- 左右子树也必须是二叉搜索树。

 

**示例 1：**

**![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/05/03/tree.png)**

```
输入：root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
```

**示例 2：**

```
输入：root = [0,null,1]
输出：[1,null,1]
```

**示例 3：**

```
输入：root = [1,0,2]
输出：[3,3,2]
```

**示例 4：**

```
输入：root = [3,2,4,1]
输出：[7,9,4,10]
```

 

**提示：**

- 树中的节点数介于 `0` 和 `104` 之间。
- 每个节点的值介于 `-104` 和 `104` 之间。
- 树中的所有值 **互不相同** 。
- 给定的树为二叉搜索树。

 ## 思路

中序遍历树，取值

从末尾相加得到新的值

重新给树赋值

## 代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode convertBST(TreeNode root) {
       
        ArrayList<Integer> a = new ArrayList<>();

        inOrder(root,a);
        int nums [] = new int[a.size()];
        int index=0;
        for (Integer i:a)
            nums[index++] = i;


        if(nums.length>1)
        for (int i=nums.length-2;i>=0;i--){
            nums[i] = nums[i]+nums[i+1];
        }

        a.clear();
        for (Integer i:nums)
            a.add(i);
        Queue<Integer> q = new LinkedList<>();
        for (Integer i:a){
           q.offer(i);
        }

        inOrder(root,q);
        return root;


    }

 public void inOrder(TreeNode root,ArrayList<Integer> num){
        if(root!=null){

            inOrder(root.left,num);
            num.add(root.val);
            inOrder(root.right,num);


        }
    }
    public void inOrder(TreeNode root,Queue<Integer> num){
        if(root!=null){

              inOrder(root.left,num);
            root.val = num.poll();
         
             inOrder(root.right,num);

        }
    }
}
```

