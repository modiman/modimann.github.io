# [剑指 Offer II 048. 序列化与反序列化二叉树](https://leetcode-cn.com/problems/h54YBf/)

难度困难14

序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。

请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg)

```
输入：root = [1,2,3,null,null,4,5]
输出：[1,2,3,null,null,4,5]
```

**示例 2：**

```
输入：root = []
输出：[]
```

**示例 3：**

```
输入：root = [1]
输出：[1]
```

**示例 4：**

```
输入：root = [1,2]
输出：[1,2]
```

 

**提示：**

- 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 [LeetCode 序列化二叉树的格式](https://leetcode-cn.com/faq/#binary-tree)。你并非必须采取这种方式，也可以采用其他的方法解决这个问题。
- 树中结点数在范围 `[0, 104]` 内
- `-1000 <= Node.val <= 1000`

```java
// Your Codec object will be instantiated and called as such:
// Codec ser = new Codec();
// Codec deser = new Codec();
// TreeNode ans = deser.deserialize(ser.serialize(root));
```



 ## 思路

注意调用方式，只需要能够使用序列化得到的字符串恢复成树即可

* 序列化也即层次遍历二叉树之后返回字符串
* 反序列化即根据上述字符串建立二叉树并返回

为了能根据序列化得到的字符串恢复二叉树，有以下问题

* 如何判断字符串中的字符是哪个节点的值，即如何将字符串恢复为整数
* 如何判断空节点null

解决方案：

* 将节点值以特殊字符隔开，比如！
* 用特殊字符表示空节点，比如#

**上述例子序列化后可以表示为**

root = [1,2,3,null,null,4,5]     - ->       1！2！3!#!#!4！5！

## 代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Codec {

    // Encodes a tree to a single string.
    //借助队列完成对二叉树的层次遍历，并
    public String serialize(TreeNode root) {
        if(root==null) return "#";
        String res = root.val + "!";
        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);
        while(!q.isEmpty()){
            TreeNode curNode = q.poll();
            if(curNode.left!=null){
                res = res + curNode.left.val + "!";
                q.offer(curNode.left);
            }
            else res = res + "#!";

             if(curNode.right!=null){
                res = res + curNode.right.val + "!";
                q.offer(curNode.right);
            }
            else res = res + "#!";
        }
    
        return res;   
    }

    // Decodes your encoded data to tree.
    
    public TreeNode deserialize(String data) {
        
        String[] values = data.split("!");
        int index = 0;

        TreeNode head = recon(values[index++]);

        Queue<TreeNode> q = new LinkedList<>();

        if(head!=null){
            q.offer(head);
        }
        TreeNode node = null;
        while(!q.isEmpty()){
            node = q.poll();
            node.left = recon(values[index++]);
            node.right = recon(values[index++]);
            if(node.left!=null){
                q.offer(node.left);
            }
            if(node.right!=null){
                q.offer(node.right);
            }

        }
       return head;
    }

    public TreeNode recon(String v){
            if(v.equals("#")){
                return null;
            }
            return new TreeNode(Integer.valueOf(v));
    }
}

// Your Codec object will be instantiated and called as such:
// Codec ser = new Codec();
// Codec deser = new Codec();
// TreeNode ans = deser.deserialize(ser.serialize(root));
```

# [剑指 Offer 07. 重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)

难度中等632

输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。

假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

 

**示例 1:**

![img](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)

```
Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
Output: [3,9,20,null,null,15,7]
```

**示例 2:**

```
Input: preorder = [-1], inorder = [-1]
Output: [-1]
```

## 思路

* 先序遍历第一个数字是二叉树的头节点

* 中序遍历中,头结点左边的部分是左子树的中序遍历

* 中序遍历中,头节点右边的部分是右子树的中序遍历

* 假设左子树长度为k,先序数组中头结点之后k个结点是左子树的先序遍历

* 先序数组中除去头节点和左子树部分剩下的部分是右子树的先序遍历

* 以上步骤可以递归

  所需参数

* pi记录先序数组的开始下表

* pj记录先序数组的结束下表

* ni记录中序数组的开始下表

* nj记录中序数组的结束下表

* index记录头结点在中序数组中的下标,用来判断新的子树的先序结束与中序数组开始位置

## 代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        if(preorder==null||inorder==null){
            return null;
        }
        HashMap<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<preorder.length;i++){
            //题目假设无重复数字
            map.put(inorder[i],i);
        }
        return reCon(preorder,0,preorder.length-1,inorder,0,inorder.length-1,map);

    }

    public TreeNode reCon(int[]p,int pi,int pj,int[]n,int ni,int nj,HashMap<Integer,Integer> map){
       
        if(pi>pj){
            return null;
        }
        TreeNode head = new TreeNode(p[pi]);
        int index = map.get(p[pi]);
        head.left = reCon(p,pi+1,pi+index-ni,n,ni,index-1,map);
        head.right = reCon(p,pi+index-ni+1,pj,n,index+1,nj,map);
        return head;
    }
}
```

# [面试题 04.08. 首个共同祖先](https://leetcode-cn.com/problems/first-common-ancestor-lcci/)

难度中等63收藏分享切换为英文接收动态反馈

设计并实现一个算法，找出二叉树中某两个节点的第一个共同祖先。不得将其他的节点存储在另外的数据结构中。注意：这不一定是二叉搜索树。

例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]

```
    3
   / \
  5   1
 / \ / \
6  2 0  8
  / \
 7   4
```

**示例 1:**

```
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
```

**示例 2:**

```
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出: 5
解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。
```

##  思路

**当前根节点是最近公共祖先有以下两种情形**

1. p和q分别在左右（或右左）子树中
2. 当前结点是p或q

程序执行过程：

* 1 自定向下遍历二叉树

* 2 如果根节点是p或q中的一个，说明一个是另一个祖先，返回根节点

* 3 如果根节点是null，说明不存在公共祖先，返回根节点

* 如果不是上述两种情况，需要结合左子树、右子树判断

* 分别判断左右子树是否为空、是否为p、q

  

## 代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode head, TreeNode p, TreeNode q) {
        //如果是当前结点是空或p、q，符合情形1，可以直接返回，否则需要根据左右子树情况判断
        if(head==null||head==p||head==q){
            return head;
        }
        
        TreeNode left = lowestCommonAncestor(head.left,p,q);
        TreeNode right = lowestCommonAncestor(head.right,p,q);
        
        //如果左右子树都不为空，符合情形二
        if(left!=null&&right!=null) return head;
        //如果左孩子不为空，说明左孩子是p或q，返回左孩子，否则返回右孩子
        return left!=null?left:right;

    }
}
```

# [114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

难度中等1009收藏分享切换为英文接收动态反馈

给你二叉树的根结点 `root` ，请你将它展开为一个单链表：

- 展开后的单链表应该同样使用 `TreeNode` ，其中 `right` 子指针指向链表中下一个结点，而左子指针始终为 `null` 。
- 展开后的单链表应该与二叉树 [**先序遍历**](https://baike.baidu.com/item/先序遍历/6442839?fr=aladdin) 顺序相同。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg)

```
输入：root = [1,2,5,3,4,null,6]
输出：[1,null,2,null,3,null,4,null,5,null,6]
```

**示例 2：**

```
输入：root = []
输出：[]
```

**示例 3：**

```
输入：root = [0]
输出：[0]
```

 

**提示：**

- 树中结点数在范围 `[0, 2000]` 内
- `-100 <= Node.val <= 100`

 

**进阶：**你可以使用原地算法（`O(1)` 额外空间）展开这棵树吗？

通过次数198,919

提交次数273,690

## 思路一

利用一个额外的队列记录先序遍历二叉树得到的结点序列，根据队列建立链表

## 代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public void flatten(TreeNode root) {
        Queue<TreeNode> q = new LinkedList();
        preOrder(root,q);
        TreeNode head = new TreeNode(),ans = head;
        while(!q.isEmpty()){
            TreeNode node = q.poll();
            node.left = null;
            head.right = node;
            head = node;
        }
        head.right = null;
    }
    //先序遍历二叉树
    public void preOrder(TreeNode root,Queue<TreeNode> q){
        if(root!=null){
            q.offer(root);
            preOrder(root.left,q);
            preOrder(root.right,q);
        }
    }
}
```

