# [剑指 Offer II 048. 序列化与反序列化二叉树](https://leetcode-cn.com/problems/h54YBf/)

难度困难14

序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。

请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg)

```
输入：root = [1,2,3,null,null,4,5]
输出：[1,2,3,null,null,4,5]
```

**示例 2：**

```
输入：root = []
输出：[]
```

**示例 3：**

```
输入：root = [1]
输出：[1]
```

**示例 4：**

```
输入：root = [1,2]
输出：[1,2]
```

 

**提示：**

- 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 [LeetCode 序列化二叉树的格式](https://leetcode-cn.com/faq/#binary-tree)。你并非必须采取这种方式，也可以采用其他的方法解决这个问题。
- 树中结点数在范围 `[0, 104]` 内
- `-1000 <= Node.val <= 1000`

```java
// Your Codec object will be instantiated and called as such:
// Codec ser = new Codec();
// Codec deser = new Codec();
// TreeNode ans = deser.deserialize(ser.serialize(root));
```



 ## 思路

注意调用方式，只需要能够使用序列化得到的字符串恢复成树即可

* 序列化也即层次遍历二叉树之后返回字符串
* 反序列化即根据上述字符串建立二叉树并返回

为了能根据序列化得到的字符串恢复二叉树，有以下问题

* 如何判断字符串中的字符是哪个节点的值，即如何将字符串恢复为整数
* 如何判断空节点null

解决方案：

* 将节点值以特殊字符隔开，比如！
* 用特殊字符表示空节点，比如#

**上述例子序列化后可以表示为**

root = [1,2,3,null,null,4,5]     - ->       1！2！3!#!#!4！5！

## 代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Codec {

    // Encodes a tree to a single string.
    //借助队列完成对二叉树的层次遍历，并
    public String serialize(TreeNode root) {
        if(root==null) return "#";
        String res = root.val + "!";
        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);
        while(!q.isEmpty()){
            TreeNode curNode = q.poll();
            if(curNode.left!=null){
                res = res + curNode.left.val + "!";
                q.offer(curNode.left);
            }
            else res = res + "#!";

             if(curNode.right!=null){
                res = res + curNode.right.val + "!";
                q.offer(curNode.right);
            }
            else res = res + "#!";
        }
    
        return res;   
    }

    // Decodes your encoded data to tree.
    
    public TreeNode deserialize(String data) {
        
        String[] values = data.split("!");
        int index = 0;

        TreeNode head = recon(values[index++]);

        Queue<TreeNode> q = new LinkedList<>();

        if(head!=null){
            q.offer(head);
        }
        TreeNode node = null;
        while(!q.isEmpty()){
            node = q.poll();
            node.left = recon(values[index++]);
            node.right = recon(values[index++]);
            if(node.left!=null){
                q.offer(node.left);
            }
            if(node.right!=null){
                q.offer(node.right);
            }

        }
       return head;
    }

    public TreeNode recon(String v){
            if(v.equals("#")){
                return null;
            }
            return new TreeNode(Integer.valueOf(v));
    }
}

// Your Codec object will be instantiated and called as such:
// Codec ser = new Codec();
// Codec deser = new Codec();
// TreeNode ans = deser.deserialize(ser.serialize(root));
```

# [剑指 Offer 07. 重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)

难度中等632

输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。

假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

 

**示例 1:**

![img](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)

```
Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
Output: [3,9,20,null,null,15,7]
```

**示例 2:**

```
Input: preorder = [-1], inorder = [-1]
Output: [-1]
```

## 思路

* 先序遍历第一个数字是二叉树的头节点

* 中序遍历中,头结点左边的部分是左子树的中序遍历

* 中序遍历中,头节点右边的部分是右子树的中序遍历

* 假设左子树长度为k,先序数组中头结点之后k个结点是左子树的先序遍历

* 先序数组中除去头节点和左子树部分剩下的部分是右子树的先序遍历

* 以上步骤可以递归

  所需参数

* pi记录先序数组的开始下表

* pj记录先序数组的结束下表

* ni记录中序数组的开始下表

* nj记录中序数组的结束下表

* index记录头结点在中序数组中的下标,用来判断新的子树的先序结束与中序数组开始位置

## 代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        if(preorder==null||inorder==null){
            return null;
        }
        HashMap<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<preorder.length;i++){
            //题目假设无重复数字
            map.put(inorder[i],i);
        }
        return reCon(preorder,0,preorder.length-1,inorder,0,inorder.length-1,map);

    }

    public TreeNode reCon(int[]p,int pi,int pj,int[]n,int ni,int nj,HashMap<Integer,Integer> map){
       
        if(pi>pj){
            return null;
        }
        TreeNode head = new TreeNode(p[pi]);
        int index = map.get(p[pi]);
        head.left = reCon(p,pi+1,pi+index-ni,n,ni,index-1,map);
        head.right = reCon(p,pi+index-ni+1,pj,n,index+1,nj,map);
        return head;
    }
}
```

# [面试题 04.08. 首个共同祖先](https://leetcode-cn.com/problems/first-common-ancestor-lcci/)

难度中等63收藏分享切换为英文接收动态反馈

设计并实现一个算法，找出二叉树中某两个节点的第一个共同祖先。不得将其他的节点存储在另外的数据结构中。注意：这不一定是二叉搜索树。

例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]

```
    3
   / \
  5   1
 / \ / \
6  2 0  8
  / \
 7   4
```

**示例 1:**

```
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
```

**示例 2:**

```
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出: 5
解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。
```

##  思路

**当前根节点是最近公共祖先有以下两种情形**

1. p和q分别在左右（或右左）子树中
2. 当前结点是p或q

程序执行过程：

* 1 自定向下遍历二叉树

* 2 如果根节点是p或q中的一个，说明一个是另一个祖先，返回根节点

* 3 如果根节点是null，说明不存在公共祖先，返回根节点

* 如果不是上述两种情况，需要结合左子树、右子树判断

* 分别判断左右子树是否为空、是否为p、q

  

## 代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode head, TreeNode p, TreeNode q) {
        //如果是当前结点是空或p、q，符合情形1，可以直接返回，否则需要根据左右子树情况判断
        if(head==null||head==p||head==q){
            return head;
        }
        
        TreeNode left = lowestCommonAncestor(head.left,p,q);
        TreeNode right = lowestCommonAncestor(head.right,p,q);
        
        //如果左右子树都不为空，符合情形二
        if(left!=null&&right!=null) return head;
        //如果左孩子不为空，说明左孩子是p或q，返回左孩子，否则返回右孩子
        return left!=null?left:right;

    }
}
```

# [114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

难度中等1009收藏分享切换为英文接收动态反馈

给你二叉树的根结点 `root` ，请你将它展开为一个单链表：

- 展开后的单链表应该同样使用 `TreeNode` ，其中 `right` 子指针指向链表中下一个结点，而左子指针始终为 `null` 。
- 展开后的单链表应该与二叉树 [**先序遍历**](https://baike.baidu.com/item/先序遍历/6442839?fr=aladdin) 顺序相同。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg)

```
输入：root = [1,2,5,3,4,null,6]
输出：[1,null,2,null,3,null,4,null,5,null,6]
```

**示例 2：**

```
输入：root = []
输出：[]
```

**示例 3：**

```
输入：root = [0]
输出：[0]
```

 

**提示：**

- 树中结点数在范围 `[0, 2000]` 内
- `-100 <= Node.val <= 100`

 

**进阶：**你可以使用原地算法（`O(1)` 额外空间）展开这棵树吗？

通过次数198,919

提交次数273,690

## 思路一

利用一个额外的队列记录先序遍历二叉树得到的结点序列，根据队列建立链表

## 代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public void flatten(TreeNode root) {
        Queue<TreeNode> q = new LinkedList();
        preOrder(root,q);
        TreeNode head = new TreeNode(),ans = head;
        while(!q.isEmpty()){
            TreeNode node = q.poll();
            node.left = null;
            head.right = node;
            head = node;
        }
        head.right = null;
    }
    //先序遍历二叉树
    public void preOrder(TreeNode root,Queue<TreeNode> q){
        if(root!=null){
            q.offer(root);
            preOrder(root.left,q);
            preOrder(root.right,q);
        }
    }
}
```

# [116. 填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

难度中等625收藏分享切换为英文接收动态反馈

给定一个 **完美二叉树** ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

```
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL`。

初始状态下，所有 next 指针都被设置为 `NULL`。

 

**进阶：**

- 你只能使用常量级额外空间。
- 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。

 

**示例：**

![img](https://assets.leetcode.com/uploads/2019/02/14/116_sample.png)

```
输入：root = [1,2,3,4,5,6,7]
输出：[1,#,2,3,#,4,5,6,7,#]
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束。
```

## 思路

注意规律

对于任意结点

* 它的左孩子的next指向它的右孩子
* 它的右孩子的next指向它的右侧结点（即它的next）的左孩子

使用树的任意遍历方式为每个结点设置next指针即可

## 代码

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}
    
    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _left, Node _right, Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
};
*/

class Solution {
    public Node connect(Node root) {
        preorder(root);
        return root;      
    }
    public void preorder(Node root){
        if(root!=null){
            if(root.right!=null)    root.right.next = root.next==null?null:root.next.left;  
            if(root.left!=null)     root.left.next = root.right;
            preorder(root.right);
            preorder(root.left);              
        }
     
    }
}
```



#### [117. 填充每个节点的下一个右侧节点指针 II](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/)

难度中等486收藏分享切换为英文接收动态反馈

给定一个二叉树

```
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL`。

初始状态下，所有 next 指针都被设置为 `NULL`。

 

**进阶：**

- 你只能使用常量级额外空间。
- 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。

 

**示例：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/15/117_sample.png)

```
输入：root = [1,2,3,4,5,null,7]
输出：[1,#,2,3,#,4,5,7,#]
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 next 指针连接），'#' 表示每层的末尾。
```

 

**提示：**

- 树中的节点数小于 `6000`
- `-100 <= node.val <= 100`

 ## 思路

## **与上一题的根本区别是本题中的树不是完全二叉树，指定next指针的方法稍有改变**

对于任意一棵树，它的左孩子（如果存在）的next指针规定为

* 如果存在右孩子，则为右孩子
* 如果不存在右孩子，则在与它同一层的结点中找到第一个有孩子的结点，对于上述例子中的树，加入结点5不存在，那么4的next将指向7，而7是与2同层的结点3的第一个孩子
* 如果上述两种情况都不满足，说明它的左孩子同层中没有更右边的结点，next指向null

它的右孩子（如果存在）的next指针规定为

* 则在与它同一层的结点中找到第一个有孩子的结点，对于上述例子中的树，加入结点5不存在，那么4的next将指向7，而7是与2同层的结点3的第一个孩子
* 否则为null

## 注意

在本题中，需要先遍历右孩子再遍历左孩子，因为这并非一棵完全二叉树，而树的左孩子的next指针依赖于右孩子。

假设树的形状如下，

![image-20211224140325439](E:\gitfile\mypages\modiman.github.io\docs\_posts\image-20211224140325439.png)

采用先序遍历的方式处理这棵树，过程如下

1. 访问结点1

* 2->3   ,3->null

2. 访问结点2

* 4->5,    5->6

3. 访问结点4

* 8->9

4. 访问结点8
5. 访问结点5

* 9->10,    10->null

​       **问题出现**，由于在先前的遍历中，5的next指向6后就没有继续，所以5的右孩子10发现6没有孩子，没有继续访问7的孩子，而是直接将next设置为null,

​      而这样的问题在上题中就不会出现，因为上一题规定所有的结点都有两个孩子，所以这种从左往右逐步前进的方式不会出现断层，也就没有错误

​      为了解决这一问题，可以从右往左遍历，仍然使用先序遍历，只不过先访问右子树，再访问左子树，这样就没有错误了

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}
    
    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _left, Node _right, Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
};
*/

class Solution {
    public Node connect(Node root) {
        preorder(root);
        return root;
        
    }
    public void preorder(Node root){
        if(root!=null){
            if(root.left!=null){
                if(root.right!=null) root.left.next = root.right;
                else root.left.next = getChild(root.next);
            }

             if(root.right!=null){
                  root.right.next = getChild(root.next);
            }
            preorder(root.right);
            preorder(root.left);
           
        }
    }


    public Node getChild(Node root){
        if(root==null) return null;
        while(root!=null){
            if (root.left!=null) return root.left;
            else if(root.right!=null) return root.right;
            else root = root.next;
        }
        return null;
    }
}
```

