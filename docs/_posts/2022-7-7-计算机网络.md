## 参考文档

* [计算机网络常用知识总结](https://juejin.cn/post/7092326134146138142#heading-4)
* https://www.nowcoder.com/discuss/974891
* https://www.nowcoder.com/discuss/976851
* https://www.nowcoder.com/discuss/978531
* https://www.nowcoder.com/issue/tutorial?zhuanlanId=70DnZj&uuid=2ebc11de0cb240cdbedb2bd48766c27d、、‘
* [为什么三次握手](https://juejin.cn/post/7138946301323903012#heading-19)

[toc]

## 模型

|                |                                        |      |
| -------------- | -------------------------------------- | ---- |
| OSI七层模型    | 注重通信协议必要的功能                 |      |
| TCP/IP四层模型 | 强调在计算机上实现协议应该开发哪种程序 |      |
|                |                                        |      |

​	

| OSI        | 任务                       | 作用                               | 数据   | 设备           | 协议            |
| ---------- | -------------------------- | ---------------------------------- | ------ | -------------- | --------------- |
| 物理层     | 定义物理设备标准           | 传输比特流                         | 比特   | 集线器、中继器 |                 |
| 数据链路层 | 格式化数据进行传输         | 物理层面上互连的节点之间的通信传输 | 帧     | 网卡、交换机   | HDLC、PPP、SLIP |
| 网络层     | 网络地址->物理地址         | 寻址和路由选择                     | 数据包 | 路由器         | IP、ICMP        |
| 传输层     |                            | 主机间的数据传输                   | 段落   |                | TCP、UDP        |
| 会话层     | 自动收发包，自动寻址       | 负责建立和断开通信连接             |        |                | `ADSP、RPC`     |
| 表示层     | 据格式的转换               | 不同系统之间通信语法问题           |        |                | ASCII、SSL/TLS  |
| 应用层     | 方便应用从网络中接收的数据 |                                    |        |                | HTTP            |

| TCP/IP     | 任务                       | 作用                               | 数据   | 设备   | 协议            |
| ---------- | -------------------------- | ---------------------------------- | ------ | ------ | --------------- |
| 物理层     | 定义物理设备标准           | 传输比特流                         | 比特   | 网卡   |                 |
| 数据链路层 | 格式化数据进行传输         | 物理层面上互连的节点之间的通信传输 | 帧     | 交换机 | HDLC、PPP、SLIP |
| 网络层     | 网络地址->物理地址         | 寻址和路由选择                     | 数据包 | 路由器 | IP、ICMP        |
| 传输层     |                            | 主机间的数据传输                   | 段落   |        | TCP、UDP        |
| 会话层     | 自动收发包，自动寻址       | 负责建立和断开通信连接             |        |        | `ADSP、RPC`     |
| 表示层     | 据格式的转换               | 不同系统之间通信语法问题           |        |        | ASCII、SSL/TLS  |
| 应用层     | 方便应用从网络中接收的数据 |                                    |        |        | HTTP            |

## 常见协议

| 协议     | 层次       | 作用                                                         |
| -------- | ---------- | :----------------------------------------------------------- |
| ARP      | 数据链路层 | Address Resolution Protocol，地址解析协议。是根据[IP地址](http://baike.baidu.com/view/3930.htm)获取[物理地址](http://baike.baidu.com/view/883168.htm)的一个[TCP/IP协议](http://baike.baidu.com/view/7649.htm)。 |
| RARP     |            | MAC->IP                                                      |
| **PPP**  | 数据链路层 | 点对点协议（Point to Point Protocol）点对点协议（PPP）为在点对点连接上传输多协议数据包提供了一个标准方法。PPP 最初设计是为两个对等节点之间的 IP 流量传输提供一种封装协议。在 TCP-IP 协议集中它是一种用来同步调制连接的数据链路层协议（OSI 模式中的第二层），替代了原来非标准的第二层协议，即 SLIP。 |
|          |            |                                                              |
|          |            |                                                              |
| **ICMP** |            | Internet Control Message Protocol，它是[TCP/IP协议族](http://baike.baidu.com/view/2221037.htm)的一个子协议，用于在IP[主机](http://baike.baidu.com/view/23880.htm)、[路由](http://baike.baidu.com/view/18655.htm)器之间传递控制消息。控制消息是指[网络通](http://baike.baidu.com/view/8079702.htm)不通、[主机](http://baike.baidu.com/view/23880.htm)是否可达、[路由](http://baike.baidu.com/view/18655.htm)是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。 |
| **DHCP** |            | Dynamic Host Configuration Protocol，是一个[局域网](http://baike.baidu.com/view/788.htm)的[网络协议](http://baike.baidu.com/view/16603.htm)，使用[UDP](http://baike.baidu.com/view/30509.htm)协议工作， 主要有两个用途：给内部网络或[网络服务](http://baike.baidu.com/view/1279152.htm)供应商自动分配[IP地址](http://baike.baidu.com/view/3930.htm)，给用户或者内部[网络管理员](http://baike.baidu.com/view/31921.htm)作为对所有[计算机](http://baike.baidu.com/view/3314.htm)作***管理的手段，在RFC 2131中有详细的描述。 |
|          |            |                                                              |
|          |            |                                                              |



|      |
| :--- |

## 名词解释

### MAC地址

> 1. mac地址前24位是厂商编号 来自IEEE，后24位来自厂商，区别每一个网卡
>
> 2. MAC地址一共有6个字节，他们从出厂时就被固化在网卡中
>
> 4. 局域网中的计算机在判断所收到的广播帧是否为自己应该接收的方法是判断 **目的帧** 的MAC地址是否与本机的硬件地址相同
>   
>    MAC帧中有目的地址 与 源地址。需要指明是目的帧与本机相同才是对的
>    
>5. 

### **1.报文(message)**

报文是网络中交换与传输的数据单元，也是网络传输的单元。报文包含了将要发送的完整的数据信息，其长短不需一致。报文在传输过程中会不断地封装成分组、包、帧来传输，封装的方式就是添加一些控制信息组成的首部，那些就是报文头。

 

### **2.分组(packet)**--网络层

分组是在网络中传输的二进制格式的单元，为了提供通信性能和可靠性，每个用户发送的数据会被分成多个更小的部分。在每个部分的前面加上一些必要的控制信息组成的首部，有时也会加上尾部，就构成了一个分组。



### **3.数据包(data packet)**

数据包是TCP/IP协议通信传输中的数据单元，也称为“包”。是指自包含的，带有足够寻址信息，可独立地从源主机传输到目的主机，而不需要依赖早期的源主机和目的主机之间交换信息以及传输网络的数据包。

 

### **4.数据报(datagram)**

面向无连接的数据传输，其工作过程类似于报文交换。采用数据报方式传输时，被传输的分组称为数据报。

 

### **5.帧(frame)**

帧是数据链路层的传输单元。它将上层传入的数据添加一个头部和尾部，组成了帧。

 

*  DNS（域名系统）是一种用于TCP/IP应用程序的分布式数据库，因此它在TCP/IP体系结构中处于应用层。
* TFTP是一种文件传递应用程序，它使用的传输层协议是UDP
* Telnet是标准的提供远程登录功能的应用，可以在不同OS系统的主机之间运行
* Ping是对两个TCP/IP系统连通性进行测试的基本工具，它利用ICMP进行基本的请求和应答

应用层——消息

传输层——数据段(segment)

网络层——分组、数据包（packet）

链路层——帧（frame）

物理层——P-PDU（bit）	

### 以太网

以太网提供的服务是不可靠的交付，即尽最大努力的交付。当目的站收到有差错的数据帧时就丢弃此帧，其他什么也不做。差错的纠正由高层来决定。如果高层发现丢失了一些数据而进行重传，以太网并不知道这是一个重传的帧。

## 常见命令

```
	
```

## 常见应用

| 应用           | 应用层协议 | 运输层协议 |
| -------------- | ---------- | ---------- |
| 名字转换       | DNS        | UDP        |
| 文件传送       | TFTP       | UDP        |
| 路由选择协议   | RIP        | UDP        |
| IP地址配置     | DHCP       | UDP        |
| 网络管理       | SNMP       | UDP        |
| 远程文件服务器 | NFS        | UDP        |
| IP电话         | 专用协议   | UDP        |
| 流式多媒体通信 | 专用协议   | UDP        |
| 多播           | IGMP       | UDP        |
| 电子邮件       | SMTP       | TCP        |
| 远程终端接入   | TELNET     | TCP        |
| 万维网         | HTTP       | TCP        |
| 文件传送       | FTP        | TCP        |

## OSI七层网络模型

### 物理层

首先解决两台物理机之间的通信需求，具体就是机器A往机器B发送比特流，机器B能收到比特流。

**物理层**主要定义了物理设备的标准，如网线的类型，光纤的接口类型，各种传输介质的传输速率。

主要**作用**是传输比特流（`0101`二进制数据），将比特流转化为电流强弱传输，到达目的后再转化为比特流，即常说的数模转化和模数转换。

这层**数据**叫做比特。**「网卡工作在这层」**。

物理层是OSI七层模型的物理基础，没有它就谈不上数据传输了

物理层就是由实物所承载的，所以作比喻的话，公路、汽车和飞机等承载货物（数据）的交通工具，就是物理层的象征

### 数据链路层

在传输比特流的过程中，会产生错传、数据传输不完整的可能。

数据链路层定义了**「如何格式化数据进行传输」**，以及如何控制对物理介质的访问。通常提供错误检测和纠正，以确保数据传输的准确性。

本层将比特数据组成帧，交换机工作在这层，对帧解码，并根据帧中包含的信息把数据发送到正确的接收方。

该层负责物理层面上互连的节点之间的通信传输。例如与1个以太网相连的两个节点间的通讯。

常见的协议有 `HDLC、PPP、SLIP`等

数据链路层会将`0、1`序列划分为具有意义的数据帧传送给对端（**「数据帧的生成与接收」**）

### **「网络层」**

随着网络节点的不断增加，点对点通讯需要通过多个节点，如何找到目标节点，如何选择最佳路径成为首要需求。

网络层主要功能是将网络地址转化为对应的物理地址，并决定如何将数据从发送方路由到接收方。

网络层通过综合考虑发送优先权、网络拥塞程度、服务质量以及可选路由的花费来决定从一个网络中节点A到另一个网络中节点B的最佳路径。

由于网络层处理并智能指导数据传送，路由器连接网络隔断，所以路由器属于网络层。

此层的数据称之为数据包。本层需要关注的协议`TCP/IP`协议中的IP协议。

网络层负责将数据传输到目标地址。目标地址可以使多个网络通过路由器连接而成的某一个地址。因此这一层主要负责**「寻址和路由选择」**。主要由 `IP、ICMP` 两个协议组成

网络层将数据从发送端的主机发送到接收端的主机，两台主机间可能会存在很多数据链路，但网络层就是负责找出一条相对顺畅的通路将数据传递过去。传输的地址使用的是IP地址。IP地址通过不断转发到更近的IP地址，最终可以到达目标地址

### **「传输层」**

随着网络通信需求的进一步扩大，通信过程中需要发送大量的数据，如海量文件传输，可能需要很长时间，网络在通信的过程中会中断很多次，此时为了保证传输大量文件时的准确性，需要对发送出去的数据进行切分，切割为一个一个的段落（`Segement`）发送，其中一个段落丢失是否重传，段落是否按顺序到达，是传输层需要考虑的问题。

传输层解决了主机间的数据传输，数据间的传输可以是不同网络，并且传输层解决了**「传输质量」**的问题。

传输层需要关注的协议有TCP/IP协议中的`TCP`协议和`UDP`协议。

### **「会话层」**

自动收发包，自动寻址。

会话层作用是**「负责建立和断开通信连接」**，何时建立，断开连接以及保持多久的连接。常见的协议有 `ADSP、RPC` 等

### **「表示层」**

Linux给WIndows发包，不同系统语法不一致，如exe不能在`Linux`下执行，shell不能在Windows不能直接运行。于是需要表示层。

解决**「不同系统之间通信语法问题」**，在表示层数据将按照网络能理解的方案进行格式化，格式化因所使用网络的不同而不同。

它主要负责数据格式的转换。具体来说，就是讲设备固有的数据格式转换为网络标准格式。常见的协议有`ASCII、SSL/TLS` 等

### **「应用层」**

规定发送方和接收方必须使用一个固定长度的消息头，消息头必须使用某种固定的组成，消息头中必须记录消息体的长度等信息，方便接收方正确解析发送方发送的数据。

应用层旨在更**「方便应用从网络中接收的数据」**，重点关注`TCP/IP`协议中的HTTP协议

## TCP/IP四层模型

### 定义

* 第一层：应用层，主要有负责web浏览器的HTTP协议， 文件传输的FTP协议，负责电子邮件的SMTP协议，负责域名系统的DNS等

* 第二层：传输层，主要是有**「可靠传输」**的TCP协议，特别**「高效」**的UDP协议。主要负责传输应用层的数据包。

* 第三层：网络层，主要是IP协议。主要负责寻址（找到目标设备的位置）

* 第四层：数据链路层，主要是负责转换数字信号和物理二进制信号。

### 作用

- 发送端是由上至下，把上层来的数据在头部加上各层协议的数据（部首）再下发给下层。
- 接受端则由下而上，把从下层接受到的数据进行解密和去掉头部的部首后再发送给上层。
- 层层加密和解密后，应用层最终拿到了需要的数据。

## TCP与UDP

| TCP                       | UDP                |
| ------------------------- | ------------------ |
| 面向连接                  | 无连接             |
| 一对一                    | 1-1\|1-n\|n-1\|n-n |
| 可靠交互                  | 尽最大努力交付     |
| 面向字节流                | 面向报文           |
| 有拥塞控制                | 无拥塞控制         |
| 首部开销大                | 首部开销小         |
| 全双工                    |                    |
| 数据有序                  | 数据无序           |
| 不保留数据边界，粘包/拆包 | 保留数据边界       |

## 沾包&半包

粘包和半包问题是数据传输中比较常见的问题，所谓的**粘包问题是指数据在传输时，在一条消息中读取到了另一条消息的部分数据，这种现象就叫做粘包。** 比如发送了两条消息，分别为“ABC”和“DEF”，那么正常情况下接收端也应该收到两条消息“ABC”和“DEF”，但接收端却收到的是“ABCD”，像这种情况就叫做粘包，如下图所示：


半包问题是指接收端只收到了部分数据，而非完整的数据的情况就叫做半包。比如发送了一条消息是“ABC”，而接收端却收到的是“AB”和“C”两条信息，这种情况就叫做半包，如下图所示：



粘包和半包问题是数据传输中比较常见的问题，它的解决方案有很多，比较常见的解决方案有：设置固定的数据传输大小、自定义请求协议的封装，在请求头中加入传输数据的长度、使用特殊符号作为结束符等。



作者：字节内推dd
链接：https://www.nowcoder.com/discuss/978531
来源：牛客网



造成粘包和拆包现象的原因： 

-  TCP 发送缓冲区剩余空间不足以发送一个完整的[数据]()包，将发生拆包； 
-  要发送的[数据]()超过了最大报文长度的限制，TCP 传输[数据]()时进行拆包； 
-  要发送的[数据]()包小于 TCP 发送缓冲区剩余空间，TCP 将多个[数据]()包写满发送缓冲区一次发送出去，将发生粘包； 
-  接收端没有及时读取 TCP 发送缓冲区中的[数据]()包，将会发生粘包。 

 粘包拆包的解决方法： 

-  发送端给[数据]()包添加首部，首部中添加[数据]()包的长度属性，这样接收端通过首部中的长度字段就可以知道[数据]()包的实际长度啦； 
-  针对发送的[数据]()包小于缓冲区大小的情况，发送端可以将不同的[数据]()包规定成同样的长度，不足这个长度的补充 0，接收端从缓冲区读取固定的长度[数据]()这样就可以区分不同的[数据]()包； 
- ​       发送端通过给不同的[数据]()包添加间隔符合确定边界，接收端通过这个间隔符合就可以区分不同的[数据]()包。

## TCP首部



![img](https://img-blog.csdn.net/20180628005629363?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzQwNDQ4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

| 同步SYN   | 当SYN为1ACK为0时表示这是一个请求连接，同意建立连接则将ACK改为1 |
| --------- | ------------------------------------------------------------ |
| 确认ACK   | 只有为1确认号字段才有效                                      |
| 序号seq   | 本报文段数据第一个字节的的序号                               |
| 确认号ack | 期望收到对方下一个报文的第一个字节的序号                     |
| 终止FIN   | 为1表示发送方发送完毕，请求关闭连接                          |

## 三次握手&四次挥手

![img](https://pic3.zhimg.com/v2-2a54823bd63e16674874aa46a67c6c72_b.jpg)

| 同步SYN   | 当SYN为1ACK为0时表示这是一个请求连接，同意建立连接则将ACK改为1 |
| --------- | ------------------------------------------------------------ |
| 确认ACK   | 只有为1确认号字段才有效                                      |
| 序号seq   | 本报文段数据第一个字节的的序号                               |
| 确认号ack | 期望收到对方下一个报文的第一个字节的序号                     |
| 终止FIN   | 为1表示发送方发送完毕，请求关闭连接                          |

**1.1 为什么需要三次握手，两次不行吗？**

**目的**：客户端和服务端都需要知道双方具有发送、接受能力

|        | 发送能力 | 接受能力 |
| ------ | -------- | -------- |
| 服务端 | 2        | 1        |
| 客户端 | 1        | 2        |
|        |          |          |

弄清这个问题，我们需要先弄明白三次握手的目的是什么，能不能只用两次握手来达到同样的目的。

第一次握手：客户端发送网络包，服务端收到了。

这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。

第二次握手：服务端发包，客户端收到了。

这样**客户端**就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时**服务器**并不能确认客户端的接收能力是否正常。

第三次握手：客户端发包，服务端收到了。

这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。

因此，需要三次握手才能确认双方的接收与发送能力是否正常。

试想如果是用两次握手，则会出现下面这种情况：



作者：老刘
链接：https://zhuanlan.zhihu.com/p/86426969
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

### 四次挥手

![img](https://pic2.zhimg.com/v2-c7d4b5aca66560365593f57385ce9fa9_b.jpg)

**closs_wait|time_wait**



##  可靠传输

### 要求

* 传输信道不产生差错
* 不管发多快接收方都来得及接收

### 滑动窗口



### 流量控制

**目的**：让发送方发送速率不要太快，让接收方来得及接收

连接建立时，接收方告诉发送方自己的接收窗口rwnd数值，发送方的发送窗口不能大于接收方的接收窗口。



### 拥塞控制

若对网络中某一资源的需求超过了该资源所能提供的部分，网络的性能就要变坏，这种情况就叫做**拥塞**。

所谓**拥塞控制**就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不至于过载。

| 拥塞控制 | 流量控制 |
| -------- | -------- |
| 全局     | 点到点   |

#### 方法

1. 慢开始
2. 拥塞避免
3. 快重传
4. 快恢复

| 方法     | 特点                                            |
| -------- | ----------------------------------------------- |
| 慢开始   | cwnd=1,之后每个轮次*2·                          |
| 拥塞避免 | cwnd每个轮次+1                                  |
| 快重传   | 将丢失的数据重传                                |
| 快恢复   | cwnd=ssthresh,开始拥塞避免，不用让cwnd从1开始。 |





#### 慢开始&拥塞避免

发送方维持一个**拥塞窗口**(cwnd)，大小取决于网络拥塞程度，然后使发送窗口等于拥塞窗口

**原则**：没有拥塞，增大窗口，出现拥塞，减小窗口。

判断拥塞的依据是**超时**

**慢开始**：由小到大逐渐增大发送窗口，逐渐翻倍

**拥塞避免**让拥塞窗口缓慢的增大，逐次加一

**慢开始门限**：ssthresh,设置一个

* cwnd<ssthresh,慢开始
* cwnd>ssthresh,拥塞避免
* cwnd=ssthresh，随便

网络出现超时后，将ssthresh更新为当前cwnd的一半，cwnd设置为1，再次慢开始

![img](https://img-blog.csdnimg.cn/20200707145606417.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjI2OTgxNw==,size_16,color_FFFFFF,t_70)

#### 快重传&快恢复

因为报文段丢失无法确认，被误判为拥塞，这时使用慢开始降低传输效率。

使用**快重传算法**可以让发送方**尽早知道发生了个别报文段的丢失**。

**场景**，假设发送1,2,3,4四段报文，其中3丢失了，当4到达时接收方不会回复4的确认，而是回复2的确认，表示自己没有接受到3，这时来了5,6,7，接收方仍然回复2的确认，当发送方一连收到3个重复确认，就知道3没发送到，因而应当立即进行重传（**即快重传**）。

之后系统不启动慢开始而是执行**快恢复**，将ssthresh设置为cwnd/2,同时设置拥塞窗口cwnd=ssthresh，并开始执行拥塞避免。
