# Spring框架

- Spring 是一个功能强大的开源、松散耦合、轻量级的[Java 框架](https://www.interviewbit.com/java-interview-questions/)，
- 旨在降低开发企业级应用程序的复杂性。
- 这个框架也被称为“框架的框架”，因为 Spring 提供了对各种其他重要框架的支持，如 JSF、Hibernate、Structs、EJB 等。
- 大约有 20 个模块，可概括为以下类型：
  - 核心容器
  - 数据访问/集成
  - 网络
  - AOP（面向方面编程）
  - 仪器仪表
  - 消息传递
  - 测试



# Spring设计模式

参考：

* 2022-4-2

* [spring 设计模式](https://www.baeldung.com/spring-framework-design-patterns)

设计模式是软件开发的基础部分。这些方法不仅可以解决重复发生的问题，还能帮助开发者通过识别设计模式来理解框架的设计。

本文关注四种Spring框架中最常见的设计模式

1. 单例模式
2. 工厂方法模式
3. 代理模式
4. 模板模式

看看Spring如何使用这些模式去减少开发者的负担并帮助用户快速实施繁琐的任务

## 2. 单例模式

单例模式是一种确保每个应用程序只存在一个对象实例的机制。这种模式在管理共享资源或提供横切服务（例如日志记录）时很有用。

### 2.1. Singleton Beans

通常，单例对于应用程序来说是全局唯一的，但是在 Spring 中，这个约束被放宽了。相反，Spring 将单例限制为每个 Spring IoC 容器一个对象。实际上，这意味着 Spring 只会为每个应用程序上下文的每种类型创建一个 bean。

Spring 的方法不同于对单例的严格定义，因为一个应用程序可以有多个 Spring 容器。因此，如果我们有多个容器，同一类的多个对象可以存在于单个应用程序中。

![]![img](https://www.baeldung.com/wp-content/uploads/2020/02/Singleton.png)

默认情况下，Spring 将所有 bean 创建为单例。

## 策略模式

AOP选择使用哪种代理模式就是使用的策略模式

* AopProxy是策略接口
* JdkDynamicAopProxy、CglibAopProxy是两个实现了AopProxy接口的策略类

## 工厂模式

### 简单工厂模式

### 工厂方法模式

* 模板方法模式：jdbcTemplate等一系列以Template结尾的对数据库操作的类都使用到了模板模式

# SpringAOP

将与业务无关，却能被业务模块共同调用的逻辑或责任封装起来（例如事务管理、日志管理、权限控制等），以便减少系统的重复代码，降低模块间耦合度，并有利于未来的可扩展性和可维护性。



**目的**：减少重复代码

**实现原理：**代理模式（动态代理+cglib）

**编程中，对象与对象之间，方法与方法之间，模块与模块之间都是一个个切面**。

**关键词**：

1. 连接点： 所有可能的需要注入切面的地方。如方法前后、类初始化、属性初始化前后等等。
2. 切点 需要做某些处理（如打印日志、处理缓存等等）的连接点。如何来指明一个切点？spring使用了AspectJ的切点表达式语言来定义Spring切面。
3. 通知： 定义在什么时候做什么事情。spring支持5种方法上的通知类型
4. 切面（Aspect）：通知+切点的集合，定义在什么地方什么时间做什么事情。
5. 引入（Introduction）： 允许我们向现有的类添加新方法属性。这不就是把切面（也就是新方法属性：通知定义的）用到目标类中吗
6. 目标（Target）： 引入中提到的目标类，也就是要被通知的对象。也就是真正的业务逻辑，他可以在毫不知情的情况下，被咱们织入切面。而自己专注于业务本身的逻辑。
7. 织入（Weaving）： 把切面应用到目标对象来创建新的代理对象的过程。
8. 

## 实现 动态代理模式

* 当实现接口时，使用JDK动态代理
* 没有实现接口时，使用cglib代理



**为其他对象提供一种代理以控制对这个对象的访问**

* 静态代理：由程序员创建或特定工具自动生成源代码，再对其编译。在程序运行前，代理类的.class文件就已经存在了。

* 动态代理：在程序运行时，运用反射机制动态创建而成，无需手动编写代码。动态代理不仅简化了编程工作，而且提高了软件系统的可扩展性，因为Java反射机制可以生成任意类型的动态代理类。

**代理原理**：

1. 代理对象内部含有对真实对象的引用，从而可以操作真实对象，
2. 同时代理对象提供与真实对象相同的接口以便在任何时刻都能代替真实对象。
3. 同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装。

## 应用

* 事务
* 日志
* 安全性框架、
* 权限

# IoC inverse of control

1.**谁控制谁？**：在以前，对象的创建和销毁都是由用户控制的，用了ioc之后，对象的创建和销毁就都交给容器来控制了，用户就不用管这些，只关注业务需求就好了；

控制反转

* 控制反转就是把对象或程序的一部分转交给容器或框架

* 有多种机制可以实现控制反转，比如策略模式、服务定位器模式、工厂模式、依赖注入等

### 参考文档

* https://www.baeldung.com/inversion-control-and-dependency-injection-in-spring



## IoC容器

* Spring 容器构成了 Spring Framework 的核心。
* Spring 容器使用依赖注入 (DI) 通过创建对象、将它们连接在一起以及配置和管理它们的整体生命周期来管理应用程序组件。
* Spring 容器执行任务的指令可以通过 XML 配置、Java 注释或 Java 代码提供。

* IoC容器是实现了控制反转的框架们的共同特性
* 在Spring中，*ApplicationContext* 接口就代表了IOC容器 。
* Spring容器担负着实例化、配置和组装注入beans等对象的职责，同时还要管理它们的生命周期。

Spring框架提供了几种 *ApplicationContext*接口的实现。*ClassPathXmlApplicationContext*和 *FileSystemXmlApplicationContext*对应独立的应用，*WebApplicationContext* 对应web应用。

为了组装beans，容器使用以xml或注解形式存储的配置元数据

下面是一种手动实例化容器的方法

```java
ApplicationContext context
  = new ClassPathXmlApplicationContext("applicationContext.xml");
```

上述案例中，为了设置属性，我们可以使用元数据。接着容器就会在运行时读取元数据并组装beans。

Spring 中的依赖注入可以通过构造函数、setter 或字段来完成。

# Bean 

## 名词解析

| 名称   | 解释                                                         |
| ------ | ------------------------------------------------------------ |
| bean   | 任何类都可以是一个bean;它不仅仅可以包括对象的属性以及get,set方法，还可以有具体的业务逻辑。 |
| Entity | 数据表对应到实体类的映射                                     |
| Model  | 可能不和Entity一一对应，因为展示在View层中数据可能是一个Entity的精简，也可能是多个Entity的组合。 |
| POJO   | 除了属性和get、set方法外不包含具体的业务逻辑方法，这个和上文表述的Model很相像，和Entity区别在于没有和数据表中字段一一对应。 |

## bean 作用域有哪些？

![img](https://img-blog.csdn.net/20160417164310654?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

Spring 框架有五个范围支持。他们是：

- **单例：**使用它时 bean 定义的范围将是每个 IoC 容器的单个实例。
- **原型：**在这里，单个 bean 定义的范围可以是任意数量的对象实例。
- **请求：** bean 定义的范围是一个 HTTP 请求。
- **Session：**这里，bean定义的范围是HTTP-session。
- **Global-session：**这里bean定义的范围是一个Global HTTP session。

注意：最后三个范围仅在用户使用 Web 感知 ApplicationContext 容器时可用。



## Beans生命周期

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/461189abf3044e94a888a4b9d8b058d0~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

Bean生命周期如下：

1. IoC 容器从 XML 文件中的 bean 定义实例化 bean。
2. 然后 Spring 使用 bean 定义中指定的依赖注入填充所有属性。
3. 获取bean ID的bean工厂容器调用`setBeanName()`，对应的bean必须实现`BeanNameAware`接口。
4. 然后工厂`setBeanFactory()`通过传递自身的实例来调用（如果 BeanFactoryAware 接口在 bean 中实现）。
5. 如果`BeanPostProcessors`与 bean 相关联，则`preProcessBeforeInitialization()`调用方法。
6. 如果指定了一个 init-method，那么它将被调用。
7. 最后，`postProcessAfterInitialization()`如果有任何 BeanPostProcessor 与需要在创建后运行的 bean 关联，则将调用方法。
8. 使用Bean
9. 容器销毁前，调用bean的销毁方法



# java依赖注入

##  引言
一个老板雇了一个程序员，为他编写一个看电影的方法。
老板最开始家境贫寒，只有走路去，程序员将方法实现为
```java
public void watchMovie(){
	Ststem.out.println("go to cinema on foot;" );
}
```
突然有一天，老板一夜暴富，买了一辆车，那么以后就可以开车去看电影了，程序员将方法实现改为
```java
public void watchMovie(){
	Ststem.out.println("go to cinema by car;" );
}
```
又过了一段时间，老板发现身边潮流变成了自行车出行，要求程序员继续修改，程序员又将方法实现改为
```java
public void watchMovie(){
	Ststem.out.println("go to cinema by bike;" );
}
```
长此以往，每次都要改，程序员觉得实在太麻烦了，既然刁老板这么爱改，怎么去电影院干脆不写死了，留给老板定。这在写方法的时候很容易想到解决方案：定义一个形参，通过传参的方法确定去电影院的方式
```java
public void watchMovie(String transportation){
	Ststem.out.println("go to cinema " + transportation);
}
```
如此一来，以后就不用每次修改代码了
## 依赖
一个类依赖于另一个类的定义
**举例**
在SpringBoot中，Controller和ServiceImpl之间就是一种依赖关系，前者需要使用后者提供的服务
假如没有依赖注入，Controller想要使用ServiceImpl最简单直接的方式是new一个实例
```java
class PeopleController{
	PeopleServiceImpl p = new PeopleServiceImpl;
	p.watchMovie();
}
class PeopleServiceImpl{
	public void watchMovie(){
		Ststem.out.println("go to cinema by car;" );
    }
}
```
## 问题

那么问题来了，就像引言里提到的那样，看电影可以有多种实现方式，开车、骑车等等，根据单一职责原则，这些不同的方法实现应该写在不同的PeopleServiceImpl类里，按照上面的写法，Controller每次选择不同的出行方式都要实例化一个新的类，这就需要修改PeopleController里的源代码。

这个问题该如何解决呢？
## 依赖注入
同样的，跟引言里设置形参的思路相同，在PeopleController里也不把实例化哪个类直接定死，而是交给外部决定。或者说把实例化依赖的方式更改为外部注入依赖。（这也是实现控制反转IoC的重要方式，将对类的控制交给外部，也就是Spring容器），这就是依赖注入
## 具体实现
依赖注入有三种常见的方式,在介绍这三种方式之前，首先介绍另一个遗留的问题。

上述包含看电影方法的不同类都只有一个看电影方法，根据面向接口编程的原则，首先可以抽象出一个PeopleService接口，它提供了看电影的声明，以后想要添加别的实现方式只用实现这个接口就行了。


```java
@Service
interface PeopleService{
	public void watchMovie();
}
```
这个接口也是后续实现依赖注入必不可少的组成。因为在上面的看电影方法设置形参时，我们默认交通工具是一种String。但在依赖注入时，由于不知道将来会将哪个类注入进Controller，所以无法在形参中确定数据类型。有了这个接口之后，就可以将数据类型统一声明为PeopleService。因为实现了这个接口的类都可以用PeopleService声明
### 基于构造器
```java
class PeopleController{
	private PeopleService p;
	PeopleController(PeopleService peopleService){
		this.p = peopleService;
	}
}
```
### 基于setter的依赖注入
```java
class PeopleController{
	private PeopleService p;
	public void setService(PeopleService peopleService){
	this.p = peopleService;
	}
}
```

### 基于field的依赖注入
使用 @Autowired注解进行依赖注入
```java
public class PeopleController {
    @Autowired
    private PeopleService p;
}
```
这种方法看起来更加简单，但不推荐使用，因为有下列缺陷

* 该方法使用反射来注入依赖项，这比基于构造函数或基于 setter 的注入成本更高。
* 使用这种方法继续添加多个依赖项真的很容易。如果我们使用构造函数注入，有多个参数会让我们认为类做不止一件事，这可能违反单一职责原则
* 当同一个接口有多个实现时，需要进一步配置

扩展阅读[JavaGuide](https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html#%E6%B3%A8%E5%85%A5-bean-%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%9C%89%E5%93%AA%E4%BA%9B)
* Autowired 属于 Spring 内置的注解，默认的注入方式为byType（根据类型进行匹配），也就是说会优先根据接口类型去匹配并注入 Bean （接口的实现类）。

* 这会有什么问题呢？ 当一个接口存在多个实现类的话，byType这种方式就无法正确注入对象了，因为这个时候 Spring 会同时找到多个满足条件的选择，默认情况下它自己不知道选择哪一个。
* 这种情况下，注入方式会变为 byName（根据名称进行匹配），这个名称通常就是类名（首字母小写）。就比如说下面代码中的 smsService 就是我这里所说的名称，这样应该比较好理解了吧。

**Java Dependency Injection** 设计模式允许我们移除硬编码依赖，使我们的应用松耦合、可扩展、可维护。我们可以实现依赖注入来移除从编译到运行时的依赖处理处理.

**依赖**：一个类依赖于另一个类的定义

比如Controller依赖ServiceImpl，想要使用ServiceImpl提供的服务

常规的处理依赖的方式，new一个实例

```java
class PeopleController{
	PeopleServiceImpl p = new PeopleServiceImpl;
}
```

**缺点**：

* 紧耦合
* 硬编码 想要修改只能改源代码重新编译

场景，假设ServiceImpl提供的一项服务是去看电影

```java
class PeopleServiceImpl{
	public void watchMovie(){
		go to cinema on foot;
    }
}
```

原本的实现是走路去电影院，现在希望多一个开车去电影院，并在PeopleController使用

解决办法是

1. 新建一个 PeopleServiceImpl2，
2. 重新写watchMovie方法，
3. 修改PeopleController中的实例

假如将来又有了一个新的坐车去电影院，那上述步骤又要重新完成。每次有新的需求都要重新走一遍1-3。

这种情况就要考虑怎么把这些重复的工作封装起来

**解决**：

首先考虑实例化，由于上面定死了实例化方式，导致每次使用新的方法都要重新修改

这里最先想到的就是把实例化封装起来，通过外部传参的形式实例化

这是很容易想到的。



## 优点|缺点

- 可配置的组成让应用更容易扩展 
- 使用模拟对象使单元测试更简单

# MVC

## 工作流程

![在这里插入图片描述](https://img-blog.csdnimg.cn/e9a7960d674744519903d34a446360e6.png#pic_center)

1. 用户点击某个请求路径,发起一个 HTTP request 请求,该请求会被提交到前端控制器(DispatcherServlet)；
2. 由 DispatcherServlet 请求一个或多个处理器映射器(HandlerMapping),并返回一个执行链(HandlerExecutionChn)。  
3. DispatcherServlet 将执行链返回的 Handler 信息发送给处理器适配器(HandlerAdapter)；
4. HandlerAdapter 根据 Handler 信息找到并执行相应的 Handler(常称为 Controller)；
5. Handler 执行完毕后会返回给 HandlerAdapter 一个 ModelAndView 对象(Spring MVC的底层对象,包括 Model 数据模型和 View 视图信息)；
6. HandlerAdapter 接收到 ModelAndView 对象后,将其返回给 DispatcherServlet ； 
7. DispatcherServlet 接收到 ModelAndView 对象后,会请求视图解析器(ViewResolver)对视图进行解析； 
8. ViewResolver 根据 View 信息匹配到相应的视图结果,并返回给 DispatcherServlet； 
9. DispatcherServlet 接收到具体的 View 视图后,进行视图渲染,将 Model 中的模型数据填充到 View 视图中的 request 域,生成最终的 View(视图)； 
10. 视图负责将结果显示到浏览器(客户端)。 
11. 加分回答 
12. Spring MVC 涉及到的组件有 
    * DispatcherServlet DispatcherServlet 是前端控制器,从图 1 可以看出,Spring MVC 的所有请求都要经过 DispatcherServlet 来统一分发。DispatcherServlet 相当于一个转发器或中央处理器,控制整个流程的执行,对各个组件进行统一调度,以降低组件之间的耦合性,有利于组件之间的拓展。 
    * HandlerMapping是处理器映射器,其作用是根据请求的 URL 路径,通过注解或者 XML 配置,寻找匹配的处理器（Handler）信息。 
    * HandlerAdapter是处理器适配器,其作用是根据映射器找到的处理器（Handler）信息,按照特定规则执行相关的处理器（Handler）。 
    * Handler 是处理器,和 Java Servlet 扮演的角色一致。其作用是执行相关的请求处理逻辑,并返回相应的数据和视图信息,将其封装至 ModelAndView 对象中。 
    * View Resolver 是视图解析器,其作用是进行解析操作,通过 ModelAndView 对象中的 View 信息将逻辑视图名解析成真正的视图 View（如通过一个 JSP 路径返回一个真正的 JSP 页面）。 
    * View 是视图,其本身是一个接口,实现类支持不同的 View 类型（JSP、FreeMarker、Excel 等）。 
    * 以上组件中,需要开发人员进行开发的是处理器（Handler,常称Controller）和视图（View）。通俗的说,要开发处理该请求的具体代码逻辑,以及最终展示给用户的界面。
