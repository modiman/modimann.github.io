# Spring设计模式

参考：

* 2022-4-2

* [spring 设计模式](https://www.baeldung.com/spring-framework-design-patterns)

设计模式是软件开发的基础部分。这些方法不仅可以解决重复发生的问题，还能帮助开发者通过识别设计模式来理解框架的设计。

本文关注四种Spring框架中最常见的设计模式

1. 单例模式
2. 工厂方法模式
3. 代理模式
4. 模板模式

看看Spring如何使用这些模式去减少开发者的负担并帮助用户快速实施繁琐的任务

## 2. 单例模式

单例模式是一种确保每个应用程序只存在一个对象实例的机制。这种模式在管理共享资源或提供横切服务（例如日志记录）时很有用。

### 2.1. Singleton Beans

通常，单例对于应用程序来说是全局唯一的，但是在 Spring 中，这个约束被放宽了。相反，Spring 将单例限制为每个 Spring IoC 容器一个对象。实际上，这意味着 Spring 只会为每个应用程序上下文的每种类型创建一个 bean。

Spring 的方法不同于对单例的严格定义，因为一个应用程序可以有多个 Spring 容器。因此，如果我们有多个容器，同一类的多个对象可以存在于单个应用程序中。

![]![img](https://www.baeldung.com/wp-content/uploads/2020/02/Singleton.png)

默认情况下，Spring 将所有 bean 创建为单例。

首先，我们创建一个 BookRepository 来管理我们的 Book 域对象。 接下来，我们创建 LibraryController，它使用 BookRepository 返回图书馆中的图书数量：

```java
@RestController
public class LibraryController {
    
    @Autowired
    private BookRepository repository;

    @GetMapping("/count")
    public Long findCount() {
        System.out.println(repository);
        return repository.count();
    }
}
```

最后创建一个BookController，关注于特定书的行为，比如通过ID查找一本书

```java
@RestController
public class BookController {
     
    @Autowired
    private BookRepository repository;
 
    @GetMapping("/book/{id}")
    public Book findById(@PathVariable long id) {
        System.out.println(repository);
        return repository.findById(id).get();
    }
}
```



# Spring

**目的**：减少重复代码

**实现原理：**代理模式（动态代理+cglib）

**编程中，对象与对象之间，方法与方法之间，模块与模块之间都是一个个切面**。

**关键词**：

1. 连接点： 所有可能的需要注入切面的地方。如方法前后、类初始化、属性初始化前后等等。
2. 切点 需要做某些处理（如打印日志、处理缓存等等）的连接点。如何来指明一个切点？spring使用了AspectJ的切点表达式语言来定义Spring切面。
3. 通知： 定义在什么时候做什么事情。spring支持5种方法上的通知类型
4. 切面（Aspect）：通知+切点的集合，定义在什么地方什么时间做什么事情。
5. 引入（Introduction）： 允许我们向现有的类添加新方法属性。这不就是把切面（也就是新方法属性：通知定义的）用到目标类中吗
6. 目标（Target）： 引入中提到的目标类，也就是要被通知的对象。也就是真正的业务逻辑，他可以在毫不知情的情况下，被咱们织入切面。而自己专注于业务本身的逻辑。
7. 织入（Weaving）： 把切面应用到目标对象来创建新的代理对象的过程。
8. 

## 实现 代理模式

**为其他对象提供一种代理以控制对这个对象的访问**

* 作者：林湾村龙猫
* 链接：https://juejin.cn/post/6844903529232990222
* 来源：稀土掘金
* 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



![Java实现代理模式](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea327fa6b6eb47059b740565ea110acd~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)





* 静态代理：由程序员创建或特定工具自动生成源代码，再对其编译。在程序运行前，代理类的.class文件就已经存在了。

* 动态代理：在程序运行时，运用反射机制动态创建而成，无需手动编写代码。动态代理不仅简化了编程工作，而且提高了软件系统的可扩展性，因为Java反射机制可以生成任意类型的动态代理类。

**代理原理**：

1. 代理对象内部含有对真实对象的引用，从而可以操作真实对象，
2. 同时代理对象提供与真实对象相同的接口以便在任何时刻都能代替真实对象。
3. 同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装。



# IoC inverse of control

控制反转



### 参考文档

* https://www.baeldung.com/inversion-control-and-dependency-injection-in-spring

控制反转就是把对象或程序的一部分转交给容器或框架

有多种机制可以实现控制反转，比如策略模式、服务定位器模式、工厂模式、依赖注入等

### The Spring IoC Container

IoC容器是实现了控制反转的框架们的共同特性

在Spring中，*ApplicationContext* 接口就代表了IOC容器 。Spring容器担负着实例化、配置和组装注入beans等对象的职责，同时还要管理它们的生命周期。

Spring框架提供了几种 *ApplicationContext*接口的实现。*ClassPathXmlApplicationContext*和 *FileSystemXmlApplicationContext*对应独立的应用，*WebApplicationContext* 对应web应用。

为了组装beans，容器使用以xml或注解形式存储的配置元数据

下面是一种手动实例化容器的方法

```java
ApplicationContext context
  = new ClassPathXmlApplicationContext("applicationContext.xml");
```

上述案例中，为了设置属性，我们可以使用元数据。接着容器就会在运行时读取元数据并组装beans。

Spring 中的依赖注入可以通过构造函数、setter 或字段来完成。

### 基于构造器的依赖注入

容器将会调用构造器，构造器中的参数与想要注入的依赖一一对应。

Spring 主要按类型解析每个参数，然后是属性名称，以及用于消歧的索引。让我们使用注解查看 bean 的配置及其依赖项：

```java
@Configuration
public class AppConfig {

    @Bean
    public Item item1() {
        return new ItemImpl1();
    }

    @Bean
    public Store store() {
        return new Store(item1());
    }
}
```

@Configuration 注解表明该类是 bean 定义的来源。我们也可以将其添加到多个配置类中

我们在方法上使用@Bean 注解来定义一个 bean。如果我们不指定自定义名称，那么 bean 名称将默认为方法名称。

对于具有默认单例范围的 bean，Spring 首先检查 bean 的缓存实例是否已经存在，如果不存在则只创建一个新实例

如果我们使用原型作用域，容器会为每个方法调用返回一个新的 bean 实例。

创建 bean 配置的另一种方法是通过 XML 配置：

```xml
<bean id="item1" class="org.baeldung.store.ItemImpl1" /> 
<bean id="store" class="org.baeldung.store.Store"> 
    <constructor-arg type="ItemImpl1" index="0" name="item" ref="item1" /> 
</bean>
```

### 基于setter的依赖注入

在调用无参数构造函数或无参数静态工厂方法来实例化 bean 后，容器将调用我们类的 setter 方法。让我们使用注解创建这个配置：

```java
@Bean
public Store store() {
    Store store = new Store();
    store.setItem(item1());
    return store;
}
```

```xml
<bean id="store" class="org.baeldung.store.Store">
    <property name="item" ref="item1" />
</bean>
```

我们可以为同一个 bean 组合基于构造函数和基于 setter 的注入类型。 Spring 文档建议对强制依赖项使用基于构造函数的注入，对可选依赖项使用基于 setter 的注入。

### 基于field的依赖注入

使用@Autowired注解实现依赖注入

```java
public class Store {
    @Autowired
    private Item item; 
}
```

在构造 Store 对象时，如果没有构造函数或 setter 方法来注入 Item bean，容器将使用反射将 Item 注入 Store。

这种方法看起来更加简单，但不推荐使用，因为有下列缺陷

* 该方法使用反射来注入依赖项，这比基于构造函数或基于 setter 的注入成本更高。
* 使用这种方法继续添加多个依赖项真的很容易。如果我们使用构造函数注入，有多个参数会让我们认为类做不止一件事，这可能违反单一职责原则

## Autowiring依赖



* https://martinfowler.com/bliki/InversionOfControl.html

控制反转是一个在扩展框架时经常遇到的现象

考虑一个简单的例子，从命令行获取一些用户信息

```ruby
#ruby
  puts 'What is your name?'
  name = gets
  process_name(name)
  puts 'What is your quest?'
  quest = gets
  process_quest(quest)
```

这一交互的控制者为代码：它决定什么时候询问、读取回答以及处理答案

当在一个窗口系统做这件事时

```python
require 'tk'
root = TkRoot.new()
name_label = TkLabel.new() {text "What is Your Name?"}
name_label.pack
name = TkEntry.new(root).pack
name.bind("FocusOut") {process_name(name)}
quest_label = TkLabel.new() {text "What is Your Quest?"}
quest_label.pack
quest = TkEntry.new(root).pack
quest.bind("FocusOut") {process_quest(quest)}
Tk.mainloop()
```

​	现在发生了很大的变化，尤其在调用 `process_name`和 `process_quest` 方法时的控制

在命令行模式下，**编程者控制着方法的调用**，而在窗口案例中并非如此。与此相反，编程者将控制权交给了窗口系统（使用`Tk.mainloop` 命令），它根据编程者在创建表单时做出的绑定决定什么时候调用这些方法。由此控制被倒置了---它调用编程者而非编程者调用框架。这一现象就是控制反转（也叫好莱坞原则----别给我打电话，我会打给你）

**思考：上述例子把调用方法的控制转交给系统了，因此叫做控制反转**

* https://stackoverflow.com/questions/3058/what-is-inversion-of-control

The **`Inversion-of-Control` (IoC)** pattern, is about providing *any kind* of `callback` (which controls reaction), instead of acting ourself directly (in other words, inversion and/or redirecting control to external handler/controller). The **`Dependency-Injection` (DI)** pattern is a more specific version of IoC pattern, and is all about removing dependencies from your code.

控制反转模式是关于用提供回调（控制回应）取代自己直接（反转或重定向控制到外部控制者）。依赖注入模式是一种特殊的IOC模式，他关注于从你的代码中移除依赖。

Every `DI` implementation can be considered `IoC`, but one should not call it `IoC`, because implementing Dependency-Injection is harder than callback (Don't lower your product's worth by using general term "IoC" instead).

举一个依赖注入的例子，加入应用有一个文本编辑组件，现在想要提供拼写检查

```java
public class TextEditor {

    private SpellChecker checker;

    public TextEditor() {
        this.checker = new SpellChecker();
    }
}
```

这样一来就在`TextEditor` 和`SpellChecker`之间建立了依赖关系。

在ioc场景下可以这么做

```java
public class TextEditor {

    private IocSpellChecker checker;

    public TextEditor(IocSpellChecker checker) {
        this.checker = checker;
    }
}
```

In the first code example we are instantiating `SpellChecker` (`this.checker = new SpellChecker();`), which means the `TextEditor` class directly depends on the `SpellChecker` class.

在第一段代码中实例化

In the second code example we are creating an abstraction by having the `SpellChecker` dependency class in `TextEditor`'s constructor signature (not initializing dependency in class). This allows us to call the dependency then pass it to the TextEditor class like so:

```cs
SpellChecker sc = new SpellChecker(); // dependency
TextEditor textEditor = new TextEditor(sc);
```

Now the client creating the `TextEditor` class has control over which `SpellChecker` implementation to use because we're injecting the dependency into the `TextEditor` signature.

第一个例子中`TextEditor` 直接依赖于 `SpellChecker`

第二个例子中，通过构造器传参建立这种依赖,而非在类中实例化依赖

```java
SpellChecker sc = new SpellChecker(); // dependency
TextEditor textEditor = new TextEditor(sc);
```

## Dependency Inject (DI,依赖注入）

翻译自文章

* **https://www.jamesshore.com/v2/blog/2006/dependency-injection-demystified**

  当我第一次听人谈到依赖注入时，我心想，这是啥？之后就忘了这件事了。后来我终于花时间弄明白人们在讨论啥时，我笑了，就这？

"依赖注入"就是给一个5美分的概念起了一个25美元的术语。这并不是说它是一个bad术语,恰恰相反，恰恰相反，它是一个好的工具。然而，谷歌上排名靠前的文章花里胡哨讲了一通，却忽略了最基本的概念。我想我应该用更简单的话讲讲依赖注入。

### 极简版

依赖注入意味着为对象提供它的实例变量。仅仅如此。

### 稍长版，PartI：依赖未注入



类中存在一些像这样的方法，可以称之为依赖。大多数人叫他们变量，觉得花哨的人会叫它们实例变量。

```java
public class Example {
 private DatabaseThingie myDatabase;

 public Example() {
  myDatabase = new DatabaseThingie();
 }

 public void DoStuff() {
  ...
  myDatabase.GetData();
  ...
 }
}
```

这里有一个名叫myDatabase的变量，或者说依赖，我们在构造器里初始化了它。

### 更长版，Part II: 依赖注入

如果需要，我们可以把这个变量传递进构造器，这将会把依赖**注入**进类，现在当我们使用变量（依赖），用的是外部给的而不是自己创建的。

```java
public class Example {
  private DatabaseThingie myDatabase;

  public Example() {
    myDatabase = new DatabaseThingie();
  }

  public Example(DatabaseThingie useThisDatabaseInstead) {
    myDatabase = useThisDatabaseInstead;
  }

  public void DoStuff() {
    ...
    myDatabase.GetData();
    ...
  }
}
```

其实本质就这些，别的不过是一些形式的改变。你可以把依赖设置进一个setter方法。你可以通过调用一个定义在特定接口中的setter方法设置依赖。您可以将依赖项设置为接口，然后以多态方式传入一些 polyjuice。都无所谓。

### 最后, Part III: 为什么我们要用到它

别的不说，这很容易在单元测试时把类隔离开

```java
public class ExampleTest {
  TestDoStuff() {
    MockDatabase mockDatabase = new MockDatabase();

    // MockDatabase is a subclass of DatabaseThingie, so we can
    // "inject" it here:
    Example example = new Example(mockDatabase);

    example.DoStuff();
    mockDatabase.AssertGetDataWasCalled();
  }
}

public class Example {
  private DatabaseThingie myDatabase;

  public Example() {
    myDatabase = new DatabaseThingie();
  }

  public Example(DatabaseThingie useThisDatabaseInstead) {
    myDatabase = useThisDatabaseInstead;
  }

  public void DoStuff() {
    ...
    myDatabase.GetData();
    ...
  }
}
```

综上所述，依赖注入就是传递一个实例参数。

### 拓展阅读

### Further Reading

把简单的概念复杂化有很多方法。 (任何概念都可以被复杂化，但简单化却很困难）必如，我没有提到那些花哨的东西，但你要是想看，去下面这些地方

- [Inversion of Control Containers and the Dependency Injection Pattern](http://www.martinfowler.com/articles/injection.html). Martin Fowler is my favorite author. Usually he’s clear and concise. Here he succeeds in making dependency injection sound terribly complicated. Still, this article has a thorough discussion of the various ways dependency injection can be tweaked.
- [A Beginner’s Guide to Dependency Injection](http://www.theserverside.com/articles/article.tss?l=IOCBeginners). This article is more about “DI containers” than it is about dependency injection itself. It takes a simple example and shows how it could be implemented using multiple off-the-shelf containers. I’m left wondering what the value is, but I’m a heretic, so feel free to ignore me on this one. Still, you have to marvel at any approach that takes three concepts (“TripPlanner,” “CabAgency,” and "AirlineAgency”), turns them into nine-plus classes, and then adds dozens of lines of glue code and configuration XML before a single line of application logic is written.

## 



# java依赖注入

**Java Dependency Injection** 设计模式允许我们移除硬编码依赖，使我们的应用松耦合、可扩展、可维护。我们可以实现依赖注入来移除从编译到运行时的依赖处理处理.



## Java Dependency Injection

Java Dependency injection seems hard to grasp with theory, so I would take a simple example and then we will see how to use dependency injection pattern to achieve loose coupling and extendability in the application.

java依赖理论不容易理解，下面用一个简单地例子依赖注入是如何使应用松耦合、可扩展。

假设有一个EmailService用来发送邮件，一般这样写

```java
package com.journaldev.java.legacy;

public class EmailService {

	public void sendEmail(String message, String receiver){
		//logic to send email
		System.out.println("Email sent to "+receiver+ " with Message="+message);
	}
}
```

​	`EmailService` 的逻辑就是向接收者发送信息，使用该服务的类如下

```java
package com.journaldev.java.legacy;

public class MyApplication {

	private EmailService email = new EmailService();
	
	public void processMessages(String msg, String rec){
		//do some msg validation, manipulation logic etc
		this.email.sendEmail(msg, rec);
	}
}
```

客户使用 `MyApplication` 发送邮件

```java

package com.journaldev.java.legacy;

public class MyLegacyTest {

	public static void main(String[] args) {
		MyApplication app = new MyApplication();
		app.processMessages("Hi Pankaj", "pankaj@abc.com");
	}

}

```

乍一看，上述逻辑没啥问题，但其实存在很多局限

- .myapplication类负责实例化email 服务然后使用。这导致硬编码依赖的产生。如果未来想要转用一些别的高级email服务，将不得不修改`MyApllication`类。这使得应用难以扩展（因为每次扩展都需要修改次类的代码），假如email 服务被多个类使用，那么扩展将会更加困难（因为这些类都要修改）
- .如果想要扩展应用去提供一些额外的服务，比如SMS或facebook消息，那我们将不得不为他们写别的应用。这会同时引起应用类和客户类的修改
- 测试应用将会非常困难，因为应用直接创建了email服务实例。测试类无法模拟这些对象

有人会说可以把service类的实例化从 `MyApplication` 类移除，然后使用构造器以参数的形式获取sevice.

```java

package com.journaldev.java.legacy;

public class MyApplication {

	private EmailService email = null;
	
	public MyApplication(EmailService svc){
		this.email=svc;
	}
	
	public void processMessages(String msg, String rec){
		//do some msg validation, manipulation logic etc
		this.email.sendEmail(msg, rec);
	}
}

```

但要求客户端应用或测试类实例化email service 并非好的设计决定

现在请看如何应用依赖注入模式解决这些问题

java中的依赖注入至少有以下要求

1. .服务成分应该被设计成基类或接口。接口或抽象类更好
2. 消费者类应该根据服务接口编写
3. Injector classes that will initialize the services and then the consumer classes.注入类将会依次实例化服务和消费者类



### Java Dependency Injection – Service Components

定义服务接口

```java

package com.journaldev.java.dependencyinjection.service;

public interface MessageService {

	void sendMessage(String msg, String rec);
}

```

根据接口实现具体的服务

```java

package com.journaldev.java.dependencyinjection.service;

public class EmailServiceImpl implements MessageService {

	@Override
	public void sendMessage(String msg, String rec) {
		//logic to send email
		System.out.println("Email sent to "+rec+ " with Message="+msg);
	}

}

```

```java

package com.journaldev.java.dependencyinjection.service;

public class SMSServiceImpl implements MessageService {

	@Override
	public void sendMessage(String msg, String rec) {
		//logic to send SMS
		System.out.println("SMS sent to "+rec+ " with Message="+msg);
	}

}

```

这些java sevices作为依赖注入已经准备好了，现在可以写消费者类

### Java Dependency Injection – Service Consumer

We are not required to have base interfaces for consumer classes but I will have a `Consumer` interface declaring contract for consumer classes.

```java

package com.journaldev.java.dependencyinjection.consumer;

public interface Consumer {

	void processMessages(String msg, String rec);
}

```

消费者类实现如下

```java

package com.journaldev.java.dependencyinjection.consumer;

import com.journaldev.java.dependencyinjection.service.MessageService;

public class MyDIApplication implements Consumer{
    
    /*
    * 原代码：
    private EmailService email = null;
	
	public MyApplication(EmailService svc){
		this.email=svc;
	}
    */

	private MessageService service;
	
	public MyDIApplication(MessageService svc){
		this.service=svc;
	}
	
	@Override
	public void processMessages(String msg, String rec){
		//do some msg validation, manipulation logic etc
		this.service.sendMessage(msg, rec);
	}

}

```

Notice that our application class is just using the service.

注意我们的类现在只是用service，并不实例化service，因此产生了更好的关注点分离 。同时，使用service接口允许我们更容易通过模拟messageService测试应用并且在运行时绑定服务而不是编译时

现在准备写注入器来实例化服务和消费者类

```java

package com.journaldev.java.dependencyinjection.injector;

import com.journaldev.java.dependencyinjection.consumer.Consumer;

public interface MessageServiceInjector {

	public Consumer getConsumer();
}

```

对于每个服务，我们可以这样创建注入类

```java

package com.journaldev.java.dependencyinjection.injector;

import com.journaldev.java.dependencyinjection.consumer.Consumer;
import com.journaldev.java.dependencyinjection.consumer.MyDIApplication;
import com.journaldev.java.dependencyinjection.service.EmailServiceImpl;

public class EmailServiceInjector implements MessageServiceInjector {

	@Override
	public Consumer getConsumer() {
		return new MyDIApplication(new EmailServiceImpl());
	}

}

```

```java

package com.journaldev.java.dependencyinjection.injector;

import com.journaldev.java.dependencyinjection.consumer.Consumer;
import com.journaldev.java.dependencyinjection.consumer.MyDIApplication;
import com.journaldev.java.dependencyinjection.service.SMSServiceImpl;

public class SMSServiceInjector implements MessageServiceInjector {

	@Override
	public Consumer getConsumer() {
		return new MyDIApplication(new SMSServiceImpl());
	}

}

```



现在来看客户如何通过一个简单的程序使用应用

```java

package com.journaldev.java.dependencyinjection.test;

import com.journaldev.java.dependencyinjection.consumer.Consumer;
import com.journaldev.java.dependencyinjection.injector.EmailServiceInjector;
import com.journaldev.java.dependencyinjection.injector.MessageServiceInjector;
import com.journaldev.java.dependencyinjection.injector.SMSServiceInjector;

public class MyMessageDITest {

	public static void main(String[] args) {
		String msg = "Hi Pankaj";
		String email = "pankaj@abc.com";
		String phone = "4088888888";
		MessageServiceInjector injector = null;
		Consumer app = null;
		
		//Send email
		injector = new EmailServiceInjector();
		app = injector.getConsumer();
		app.processMessages(msg, email);
		
		//Send SMS
		injector = new SMSServiceInjector();
		app = injector.getConsumer();
		app.processMessages(msg, phone);
	}

}

```



可以看出应用类只负责使用服务。服务类在注入器中创建，如果要进一步扩展应用，只需要添加服务类以及修改注入器类即可。



所以依赖注入的实现解决了硬编码依赖的问题，还帮我们提高应用弹性，使得容易拓展。

现在看看通过模拟注入器和服务类来测试应用有多简单



###  JUnit Test Case with Mock Injector and Service

```java

package com.journaldev.java.dependencyinjection.test;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import com.journaldev.java.dependencyinjection.consumer.Consumer;
import com.journaldev.java.dependencyinjection.consumer.MyDIApplication;
import com.journaldev.java.dependencyinjection.injector.MessageServiceInjector;
import com.journaldev.java.dependencyinjection.service.MessageService;

public class MyDIApplicationJUnitTest {

	private MessageServiceInjector injector;
	@Before
	public void setUp(){
		//mock the injector with anonymous class
		injector = new MessageServiceInjector() {
			
			@Override
			public Consumer getConsumer() {
				//mock the message service
				return new MyDIApplication(new MessageService() {
					
					@Override
					public void sendMessage(String msg, String rec) {
						System.out.println("Mock Message Service implementation");
						
					}
				});
			}
		};
	}
	
	@Test
	public void test() {
		Consumer consumer = injector.getConsumer();
		consumer.processMessages("Hi Pankaj", "pankaj@abc.com");
	}
	
	@After
	public void tear(){
		injector = null;
	}

}

```



使用 [anonymous classes](https://www.journaldev.com/996/java-inner-class) to *mock the injector and service classes* 可以轻松测试应用方法. 

上面是使用构造器注入依赖

下面使用setter方法注入依赖

```java

package com.journaldev.java.dependencyinjection.consumer;

import com.journaldev.java.dependencyinjection.service.MessageService;

public class MyDIApplication implements Consumer{

	private MessageService service;
	
	public MyDIApplication(){}

	//setter dependency injection	
	public void setService(MessageService service) {
		this.service = service;
	}

	@Override
	public void processMessages(String msg, String rec){
		//do some msg validation, manipulation logic etc
		this.service.sendMessage(msg, rec);
	}

}

```

```java

package com.journaldev.java.dependencyinjection.injector;

import com.journaldev.java.dependencyinjection.consumer.Consumer;
import com.journaldev.java.dependencyinjection.consumer.MyDIApplication;
import com.journaldev.java.dependencyinjection.service.EmailServiceImpl;

public class EmailServiceInjector implements MessageServiceInjector {

	@Override
	public Consumer getConsumer() {
		MyDIApplication app = new MyDIApplication();
		app.setService(new EmailServiceImpl());
		return app;
	}

}

```

setter方法注入依赖的最佳案例是[Struts2 Servlet API Aware interfaces](https://www.journaldev.com/2203/get-servlet-session-request-response-context-attributes-struts-2-action).



Whether to use Constructor based dependency injection or setter based is a design decision and depends on your requirements. 

选择构造器还是setter方法取决于需求环境

比如，如果应用没有服务类就不能工作，那适合使用构造器，否则使用setter方法



依赖注入实现控制反转的方法之一，其他还有工厂模式、模板方法模式、策略模式和服务定位器模式等。

**[Spring Dependency Injection](https://www.journaldev.com/2410/spring-dependency-injection)**, **[Google Guice](https://www.journaldev.com/2403/google-guice-dependency-injection-example-tutorial)** and **Java EE CDI** frameworks facilitate the process of dependency injection through use of [Java Reflection API](https://www.journaldev.com/1789/java-reflection-example-tutorial) and [java annotations](https://www.journaldev.com/721/java-annotations). All we need is to annotate the field, constructor or setter method and configure them in configuration xml files or classes.

### Java Dependency Injection优点

- Separation of Concerns
- Boilerplate Code reduction in application classes because all work to initialize dependencies is handled by the injector component
- 可配置的组成让应用更容易扩展 
- 使用模拟对象使单元测试更简单

### Disadvantages of Java Dependency Injection

Java Dependency injection has some disadvantages too:

- If overused, it can lead to maintenance issues because the effect of changes are known at runtime.
- Dependency injection in java hides the service class dependencies that can lead to runtime errors that would have been caught at compile time.

# Spring面试题

## Spring、Spring Core、Spring IoC 面试题

### 一、什么是Spring框架？

- Spring 是一个功能强大的开源、松散耦合、轻量级的[Java 框架](https://www.interviewbit.com/java-interview-questions/)，旨在降低开发企业级应用程序的复杂性。这个框架也被称为“框架的框架”，因为 Spring 提供了对各种其他重要框架的支持，如 JSF、Hibernate、Structs、EJB 等。
- 大约有 20 个模块，可概括为以下类型：
  - 核心容器
  - 数据访问/集成
  - 网络
  - AOP（面向方面编程）
  - 仪器仪表
  - 消息传递
  - 测试

![img](https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/839/original/spring_framework.png?1628693487)

> Spring 处理所有与基础设施相关的方面，使程序员可以主要专注于应用程序开发。

### 2、Spring框架有哪些特点？

- Spring 框架遵循**分层架构**模式，有助于选择必要的组件，同时为 J2EE 应用程序开发提供健壮且内聚的框架。
- Spring 的 AOP（Aspect Oriented Programming）部分通过确保**应用程序的业务逻辑**与其他系统服务的分离来支持统一开发。
- Spring 提供了**高度可配置**的 MVC Web 应用程序框架，可以轻松切换到其他框架。
- 提供配置的**创建和管理**以及定义应用程序对象的生命周期。
- Spring 有一个特殊的设计原则，称为 IoC（**控制反转**），它支持对象提供其依赖关系，而不是寻找创建依赖对象。
- Spring 是一个**轻量级的、基于 java 的、松散耦合的**框架。
- **Spring为事务管理**提供了通用抽象层，这对于无容器环境也非常有用。
- Spring 提供了一个方便的 API 来将特定于技术的异常（由 JDBC、Hibernate 或其他框架抛出）转换为**一致的、未经检查的异常。**这引入了抽象并大大简化了异常处理。

### 3.什么是Spring配置文件？

Spring 配置文件基本上是一个 XML 文件，主要包含类信息并描述这些类是如何配置和相互链接的。XML 配置文件详细且清晰。





### 4. IoC（Inversion of Control）容器是什么意思？

Spring 容器构成了 Spring Framework 的核心。Spring 容器使用依赖注入 (DI) 通过创建对象、将它们连接在一起以及配置和管理它们的整体生命周期来管理应用程序组件。Spring 容器执行任务的指令可以通过 XML 配置、Java 注释或 Java 代码提供。

![img](https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/840/original/IOC.png?1628693864)

### 5.你对依赖注入的理解是什么？

依赖注入的主要思想是您不必创建对象，而只需要描述应该如何创建它们。

- 组件和服务不需要我们直接在代码中连接。我们必须在配置文件中描述哪些组件需要哪些服务。Spring 中的 IoC 容器会将它们连接在一起。

![img](https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/841/original/Dependency_Injection.png?1628693939)

- 在Java中，实现依赖注入的两种主要方式是：
  - 构造函数注入：在这里，IoC 容器调用具有多个参数的类构造函数，其中每个参数代表对另一个类的依赖。
  - Setter 注入：这里，spring 容器在调用无参数静态工厂方法或默认构造函数来实例化 bean 后，调用 bean 上的 setter 方法。

### 6.解释构造函数和setter注入的区别？

- 在构造函数注入中，部分注入是不允许的，而在 setter 注入中是允许的。
- 构造函数注入不会覆盖 setter 属性，而 setter 注入则不然。
- 如果完成任何修改，构造函数注入会创建一个新实例。在 setter 注入中无法创建新实例。
- 如果 bean 有很多属性，那么构造函数注入是首选。如果它的属性很少，则首选 setter 注入。

### 7. 什么是 Spring Bean？

- 它们是构成用户应用程序主干的对象，由 Spring IoC 容器管理。
- Spring bean 由 IoC 容器实例化、配置、连接和管理。
- Bean 是使用用户提供给容器的配置元数据创建的（通过 XML 或 java 注释配置）。

### 8、配置元数据是如何提供给spring容器的？

提供配置元数据的方式有 3 种。它们如下：

- **基于 XML 的配置：** bean 配置及其依赖项在 XML 配置文件中指定。这以 bean 标记开始，如下所示：

```plaintext
   <bean id="interviewBitBean" class="org.intervuewBit.firstSpring.InterviewBitBean">
    <property name="name" value="InterviewBit"></property>
   </bean>
```

- 基于注释的配置：

  可以通过在相关类、方法或字段声明上使用注释将 bean 配置到组件类本身，而不是 XML 方法。

  - 默认情况下，注解连接在 Spring 容器中是不活动的。这必须在 Spring XML 配置文件中启用，如下所示

```plaintext
<beans>
<context:annotation-config/>
<!-- bean definitions go here -->
</beans>
```

- 基于 Java 的配置：

   Spring Framework 引入了关键特性作为新的 Java 配置支持的一部分。这利用了

  @Configuration

  注释类和

  @Bean

  注释方法。

  注意：

  - @Bean 注解与 <bean/> 元素的作用相同。
  - 使用 @Configuration 注解的类允许通过简单地调用同一类中的其他 @Bean 方法来定义 bean 间的依赖关系。

### 9. Spring 中可用的 bean 作用域有哪些？

Spring 框架有五个范围支持。他们是：

- **单例：**使用它时 bean 定义的范围将是每个 IoC 容器的单个实例。
- **原型：**在这里，单个 bean 定义的范围可以是任意数量的对象实例。
- **请求：** bean 定义的范围是一个 HTTP 请求。
- **Session：**这里，bean定义的范围是HTTP-session。
- **Global-session：**这里bean定义的范围是一个Global HTTP session。

注意：最后三个范围仅在用户使用 Web 感知 ApplicationContext 容器时可用。

### 10、讲解Spring Bean Factory Container中的Bean生命周期。

Bean生命周期如下：

- IoC 容器从 XML 文件中的 bean 定义实例化 bean。
- 然后 Spring 使用 bean 定义中指定的依赖注入填充所有属性。
- 获取bean ID的bean工厂容器调用`setBeanName()`，对应的bean必须实现`BeanNameAware`接口。
- 然后工厂`setBeanFactory()`通过传递自身的实例来调用（如果 BeanFactoryAware 接口在 bean 中实现）。
- 如果`BeanPostProcessors`与 bean 相关联，则`preProcessBeforeInitialization()`调用方法。
- 如果指定了一个 init-method，那么它将被调用。
- 最后，`postProcessAfterInitialization()`如果有任何 BeanPostProcessor 与需要在创建后运行的 bean 关联，则将调用方法。

![img](https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/842/original/Spring_Bean_Life_Cycle.png?1628694921)

### 11. 你对 Bean Wiring 的理解是什么。

- 当 bean 在 Spring 容器中组合在一起时，它们被称为连线或这种现象称为 bean 连线。
- Spring 容器在连接 bean 时应该知道需要哪些 bean，以及这些 bean 是如何相互依赖的。这是通过基于 XML / Annotations / Java 代码的配置给出的。

### 12.什么是自动装配并命名它的不同模式？

IoC 容器自动装配应用程序 bean 之间的关系。Spring 让协作者通过检查 BeanFactory 的内容来解决必须自动连接的 bean。
这个过程的不同模式是：

- **no**：这意味着**没有自动装配**，是默认设置。应使用显式 bean 引用进行接线。
- **byName**：根据bean的**名字**注入bean依赖。这会将其属性与配置中由相同名称定义的 bean 匹配并连接。
- **byType**：这会根据**type**注入 bean 依赖项。
- **constructor ：在这里，它****通过调用类的构造函数**来注入 bean 依赖项。它有大量的参数。
- **autodetect**：首先容器尝试通过构造函数使用 autowire 进行连接，如果不可能，则尝试通过 byType 自动连接。

### 13. 自动装配有什么限制？

- **覆盖可能性**：使用 覆盖自动装配的设置`<constructor-arg>`来指定依赖关系。`<property>`
- **数据类型限制**：原始数据类型、字符串和类不能自动装配。

## Spring Boot 面试题

### 14. 你对“Spring Boot”这个词是怎么理解的？

Spring Boot 是一个开源的、基于 java 的框架，它为快速应用程序开发提供支持，并为开发独立和生产就绪的 Spring 应用程序提供了一个平台，只需要很少的配置。

### 15. 解释使用 Spring Boot 进行应用程序开发的优势。

- Spring Boot 有助于创建可以使用 java.jar 启动的独立应用程序（不需要配置 WAR 文件）。
- Spring Boot 还为 Maven 配置提供了精确的“启动”POM。
- 可以直接嵌入 Undertow、Tomcat、Jetty 或其他 Web 服务器。
- 自动配置：提供一种基于类路径上存在的依赖项自动配置应用程序的方法。
- Spring Boot 的开发旨在减少代码行数。
- 它提供了生产就绪的支持，如监控和使用 Spring Boot 开发的应用程序更容易启动。

### 16.区分Spring和Spring Boot。

- Spring Framework 提供了多种功能，如依赖注入、数据绑定、面向方面编程 (AOP)、数据访问等，有助于更轻松地开发 Web 应用程序，而 Spring Boot 通过简化或管理各种松散耦合的 Spring 块很乏味并且有可能变得混乱。
- Spring Boot 简化了常用的 Spring 依赖项，并直接从命令行运行应用程序。它也不需要应用程序容器，它有助于监控多个组件并在外部配置它们。

### 17. Spring Boot 有哪些特点？

- **Spring Boot CLI** – 这允许您使用 Groovy / Maven 编写 Spring Boot 应用程序并避免样板代码。
- **Starter Dependency** – 在这个特性的帮助下，Spring Boot 将常见的依赖聚合在一起，最终提高生产力并减轻负担
- **Spring Initializer** – 这是一个 Web 应用程序，可帮助开发人员创建内部项目结构。开发人员在使用此功能时不必手动设置项目结构。
- **自动配置**——这有助于根据您正在处理的项目加载默认配置。通过这种方式，可以避免不必要的 WAR 文件。
- **Spring Actuator** – Spring Boot 使用执行器提供“管理端点”，帮助开发人员完成应用程序内部、指标等。
- **日志记录和安全**性——这确保了所有使用 Spring Boot 制作的应用程序都得到了适当的保护，没有任何麻烦。

### 18、@SpringBootApplication注解内部有什么作用？

根据 Spring Boot 文档，@SpringBootApplication 注释是使用@Configuration、@EnableAutoConfiguration 和@ComponentScan 注释以及它们的默认属性的一点替代。

![img](https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/843/original/What_does__SpringBootApplication_annotation_do_internally.png?1628696126)

这使开发人员能够使用单个注释而不是使用多个注释，从而减少代码行数。但是，Spring 提供了松散耦合的特性，这就是我们可以根据项目需要使用这些注释的原因。

### 19. Spring Boot Application 作为“Java Application”运行有什么效果？

- 应用程序一看到我们正在运行 Web 应用程序，就会自动启动 tomcat 服务器。

### 20、什么是Spring Boot依赖管理系统？

- 它基本上用于自动管理依赖项和配置，而无需为任何依赖项指定版本。

### 21. 外部配置的可能来源有哪些？

- Spring Boot 利用其外部配置的特性，允许开发人员在不同的环境中运行相同的应用程序。这使用环境变量、属性文件、命令行参数、YAML 文件和系统属性来提及其相应环境所需的配置属性。以下是外部配置的来源：
  - **命令行属性**——Spring Boot 提供对命令行参数的支持，并将这些参数转换为属性，然后将它们添加到环境属性集中。
  - **应用程序属性**——默认情况下，Spring Boot 在应用程序的当前目录、类路径根目录或配置目录中搜索应用程序属性文件或其 YAML 文件以加载属性。
  - **特定于配置文件的属性**– 属性是从`application-{profile}.properties file`YAML 文件或其 YAML 文件加载的。此文件与非特定属性文件位于同一位置，{profile} 占位符指的是活动配置文件或环境。

### 22. Spring boot 可以更改嵌入式Tomcat服务器的默认端口吗？

- 是的，我们可以使用应用程序属性文件来更改它，方法是添加一个属性`server.port`并将其分配给您希望的任何端口。
- 例如，如果您希望端口为 8081，那么您必须提及`server.port=8081`. 一旦提到端口号，Spring Boot 将自动加载应用程序属性文件，并将指定的配置应用于应用程序。

### 23. 你能告诉如何在不使用 basePackages 过滤器的情况下排除任何包吗？

我们可以`exclude`在使用注解的同时使用属性，`@SpringBootApplication`如下所示： 

```plaintext
@SpringBootApplication(exclude= {Student.class})
public class InterviewBitAppConfiguration {}
```

### 24. 如何禁用特定的自动配置类？

- 为此，您可以使用 的`exclude`属性，如下所示：`@EnableAutoConfiguration`

```plaintext
@EnableAutoConfiguration(exclude = {InterviewBitAutoConfiguration.class})
```

如果类路径上没有指定类，我们可以指定全限定名作为`excludeName`.

```plaintext
//By using "excludeName"
@EnableAutoConfiguration(excludeName={Foo.class})
```

- 您可以添加到 application.properties 中，并且可以通过保持逗号分隔来添加多个类。

### 25. Spring Boot应用中的默认web server可以禁用吗？

是的！`application.properties`用于配置 Web 应用程序类型，通过提及`spring.main.web-application-type=none`.

### 26、Spring Boot中@RequestMapping和@RestController注解有什么用？

- @请求映射：
  - 这提供了路由信息并通知 Spring 任何与 URL 匹配的 HTTP 请求都必须映射到相应的方法。
  - `org.springframework.web.bind.annotation.RequestMapping`必须导入才能使用此注释。
- @RestController：
  - 这应用于一个类以将其标记为请求处理程序，从而使用 Spring MVC 创建 RESTful Web 服务。这个注解将@ResponseBody 和@Controller 注解添加到类中。
  - `org.springframework.web.bind.annotation.RestController`必须导入才能使用此注释。

[在这里](https://www.interviewbit.com/spring-boot-interview-questions/)查看更多关于 Spring Boot 的面试问题。

## Spring AOP、Spring JDBC、Spring Hibernate 面试题

### 27.什么是Spring AOP？

- Spring AOP（面向方面编程）类似于 OOP（面向对象编程），因为它也提供了模块化。

- 在 AOP 中，关键单元是

  方面

  或

  关注点

  ，它们只不过是应用程序中的独立模块。某些方面具有集中的代码，但其他方面可能是分散或纠结的代码，例如日志记录或事务。这些分散的方面称为

  横切关注点

  。

  - 诸如事务管理、身份验证、日志记录、安全性等横切关注点是可能影响整个应用程序的关注点，出于安全性和模块化目的，应尽可能集中在代码中的一个位置。

- AOP 提供平台，通过使用简单的可插拔配置，在实际逻辑之前、之后或周围动态添加这些横切关注点。

- 这导致代码的易于维护。只需修改配置文件即可添加或删除问题，因此无需重新编译完整的源代码。

- Spring AOP 有两种实现方式：

  - 使用 XML 配置文件
  - 使用 AspectJ 注释样式

### 28. 什么是建议？在春天解释它的类型。

一个建议是横切关注点的实现可以应用于spring应用程序的其他模块。建议主要有5种类型：

- 前：
  - 此通知在连接点**之前**执行，但它没有能力阻止执行流继续到连接点（除非它引发异常）。
  - 要使用它，请使用 @Before 注释。
- 返回后：
  - 该建议将在连接点正常**完成****后**执行，即如果方法返回而没有引发异常。
  - 要使用它，请使用 @AfterReturning 注释。
- 投掷后：
  - **如果方法因抛出异常**而退出，则将执行此建议。
  - 要使用它，请使用 @AfterThrowing 注释。
- 后：
  - **无论**连接点以何种方式退出（正常返回或遇到异常），都将执行此建议。
  - 要使用它，请使用 @After 注释。
- 大约：
  - 这是围绕诸如方法调用之类的连接点的最强大的建议。
  - 要使用它，请使用 @Around 注释。

### 29.什么是Spring AOP Proxy模式？

- 代理模式是一种常用的设计模式，其中代理是一个看起来像另一个对象但在幕后为其添加特殊功能的对象。
- Spring AOP 遵循基于代理的模式，这是由 AOP 框架创建的，用于在运行时实现切面契约。
- 标准 JDK 动态代理是默认的 AOP 代理，它允许代理任何接口。Spring AOP 还可以使用代理类而不是接口所需的 CGLIB 代理。如果业务对象没有实现接口，则默认使用 CGLIB 代理。

### 30. Spring JDBC API 有哪些类？

- 以下是课程
  - Jdbc模板
  - SimpleJdbc模板
  - 命名参数JdbcTemplate
  - SimpleJdbcInsert
  - SimpleJdbcCall
- 最常用的是JdbcTemplate。这在内部使用了 JDBC API，优点是我们不需要创建连接、语句、启动事务、提交事务和关闭连接来执行不同的查询。所有这些都由 JdbcTemplate 自己处理。开发人员可以专注于直接执行查询。

### 31. Spring JdbcTemplate如何获取记录？

这可以通过使用 JdbcTemplate 的查询方法来完成。有两个接口可以帮助做到这一点：

- 结果集提取器：
  - 它只定义了一种`extractData`接受`ResultSet`实例作为参数并返回列表的方法。
  - 句法：

```plaintext
public T extractData(ResultSet rs) throws SQLException,DataAccessException;
```

- 行映射器：
  - 这是 ResultSetExtractor 的增强版，节省了大量代码。
  - 它允许映射一行与用户定义类的实例的关系。
  - 它在内部迭代 ResultSet 并将其添加到结果集合中，从而节省了大量用于获取记录的代码。

### 32.什么是Hibernate ORM框架？

- 对象关系映射 (ORM) 是将应用程序域模型对象映射到关系数据库表的现象，反之亦然。
- Hibernate 是最常用的基于 Java 的 ORM 框架。

### 33、使用Spring访问Hibernate的两种方式是什么？

- 使用 Hibernate 模板和回调的控制反转方法。
- 扩展`HibernateDAOSupport`和应用 AOP 拦截器节点。

### 34.什么是Hibernate验证器框架？

- 数据验证是任何应用程序的关键部分。我们可以在以下位置找到数据验证：
  - 将对象发送到服务器之前的 UI 层
  - 在处理它之前在服务器端
  - 在将数据持久化到数据库之前
- 验证是一个跨领域的关注点/任务，因此作为良好的实践，我们应该尽量将它与我们的业务逻辑分开。JSR303 和 JSR349 通过使用注解为 bean 验证提供规范。
- 该框架提供了 JSR303 和 JSR349 规范的参考实现。

### 35.什么是HibernateTemplate类？

- 在 Hibernate 3.0.1 之前，Spring 提供了 2 个类，即：`HibernateDaoSupport`从 Hibernate 获取 Session 和`HibernateTemplate`用于 Spring 事务管理目的。
- 但是，从 Hibernate 3.0.1 开始，通过使用`HibernateTemplate`类我们可以使用`SessionFactory getCurrentSession()`方法来获取当前会话，然后使用它来获得事务管理的好处。
- `HibernateTemplate`具有异常翻译的好处，但可以通过使用带有服务类的@Repository 注释轻松实现。

## Spring MVC 面试题

### 36.什么是Spring MVC框架？

- Spring MVC 是请求驱动的框架，是 Spring 框架的核心组件之一。
- 它带有随时可用的松散耦合组件和元素，极大地帮助开发人员构建灵活和健壮的 Web 应用程序。
- MVC（模型 - 视图 - 控制器）架构分离并提供应用程序不同方面之间的松散耦合——输入逻辑（模型）、业务逻辑（控制器）和 UI 逻辑（视图）。

### 37. Spring MVC 框架相对于其他 MVC 框架有什么好处？

- 清晰的角色分离——每个角色都有一个专门的专用对象。
- 可重用的业务代码逻辑——使用 Spring MVC，无需复制代码。现有对象可以用作命令而不是复制它们以扩展特定的框架基类。
- Spring MVC 框架提供可定制的绑定和验证。
- 还提供可定制的语言环境和主题分辨率。
- Spring MVC 也支持可定制的处理程序映射和视图解析。

### 38. Spring MVC 中的 DispatcherServlet 是什么？换句话说，你能解释一下 Spring MVC 架构吗？

Spring MVC 框架是围绕一个称为 DispatcherServlet 的中央 servlet 构建的，它处理所有 HTTP 请求和响应。DispatcherServlet 做的远不止这些：

- 它与 IoC 容器无缝集成，允许您以更轻松的方式使用 Spring 的每个功能。
- DispatcherServlet 联系 HandlerMapping 以调用适当的 Controller 来处理接收到的请求。然后，控制器调用适当的服务方法来设置或处理模型数据。服务处理数据并将视图名称返回给 DispatcherServlet。DispatcherServlet 然后在 ViewResolver 的帮助下为请求获取定义的视图。一旦决定了视图，DispatcherServlet 将模型数据传递给视图，最终在浏览器上呈现。

![img](https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/844/original/DispatcherServlet_in_Spring_MVC.png?1628699617)

### 39.什么是View Resolver模式并解释它在Spring MVC中的意义？

- 它是一种 J2EE 模式，允许应用程序动态选择在浏览器（视图）上呈现数据的技术。
  - 任何技术，如 HTML、JSP、XSLT、JSF 或任何其他此类技术都可以用作 View。
- View Resolver 拥有不同视图的信息。Controller 返回 View 的名称，然后由 DispatcherServlet 传递给 View Resolver 以选择适当的 View 技术，然后显示数据。
- Spring MVC 中使用的默认 ViewResolver 是`InternalResourceViewResolver`.

### 40.@Controller注解是干什么用的？

- @Controller 是用于定义控制器的构造型 Spring MVC 注释。

### 41. 可以不使用@Controller 或@RestController 注解创建控制器吗？

- 是的！您可以通过使用注释对 Spring MVC 控制器类进行注释来创建没有 @Controller 或 @RestController 注释的控制器`@Component`。在这种情况下，请求映射到处理程序方法的真正工作是使用@RequestMapping 注解完成的。

### 42.什么是ContextLoaderListener，它有什么作用？

- ContextLoaderListener 加载并创建 ApplicationContext，因此开发人员无需编写显式代码来创建它。简而言之，它是一个有助于引导 Spring MVC 的侦听器。
  - 应用程序上下文是 Spring bean 所在的位置。对于 Web 应用程序，有一个称为 WebAppliationContext 的子类。
- ApplicationContext 的生命周期通过使用 ContextLoaderListener 与 ServletContext 的生命周期相关联。WebApplicationContext 中的 ServletContext 可以使用 getServletContext() 方法获得。

### 43.@RequestParam和@PathVariable注解有什么区别？

- 尽管这两个注释都用于从 URL 中提取一些数据，但它们之间存在关键区别。
  - @RequestParam 用于提取“？”之后的任何**查询参数** 在网址中。
  - @PathVariable 用于提取作为 URI 本身的一部分存在的数据。]
  - 例如，如果给定的 URL 是 http://localhost:8080/InterviewBit/Spring/SpringMVC/?format=json，那么您可以使用 @RequestParam 注释和 /Spring/{type} 访问查询参数“format” @PathVariable，它将为您提供 SpringMVC。

```plaintext
@RequestMapping("/Spring/{type}")
public void getQuestions(@PathVariable("type") String type, 
                        @RequestParam(value = "format", required = false) String format){
   /* Some code */
}
```

### 44. Spring MVC中的Model是什么？

- 模型是具有用于渲染的数据的参考。
- 它总是被创建并传递给 Spring MVC 中的视图。如果映射的控制器方法将模型作为参数，则该模型实例会自动注入该方法。
- 在注入模型上设置的任何属性都将被保留并传递给视图。

### 45.@Autowired注解有什么用？

`@Autowired`注释用于通过其类型以及方法和字段来注入 bean。这有助于 Spring 框架通过将 bean 注入和协作到另一个 bean 来解决依赖关系。例如，考虑下面的代码片段：

```plaintext
import org.Springframework.beans.factory.annotation.Autowired;
import java.util.*;
public class InterviewBit {
   // Autowiring/Injecting FormatterUtil as dependency to InterviewBit class
  @Autowired
  private FormatterUtil formatterUtil;
  
  public Date something( String value ){
     Date dateFormatted = formatterUtil.formatDate(value);
     return dateFormatted
   }
}
/**
* Util class to format any string value to valid date format
*/
public class FormatterUtil {
   
   public Date formatDate(String value){
       //code to format date
   }
}
```

### 46.@ModelAttribute注解的作用是什么？

注释在将方法参数绑定到与模型对应的相应属性中起着非常重要的作用。然后它在演示页面上反映相同。注释的作用还取决于开发人员使用它的目的。如果在方法级别使用它，则该方法负责为其添加属性。在参数级别使用时，它表示要从模型层检索参数值。

### 47. Spring MVC中web.xml的重要性是什么？

`web.xml`也称为部署描述符，它定义了 servlet 及其映射、过滤器和生命周期侦听器。它还用于配置 ContextLoaderListener。每当部署应用程序时，Servlet 容器都会创建一个 ContextLoaderListener 实例，这会导致 WebApplicationContext 的加载。

### 48. Spring MVC 依赖注入有哪些类型？

DI（依赖注入）有两种类型：

- 基于构建：
  - 这种类型的 DI 在 Spring IoC（控制反转）容器调用依赖于其他类的参数化构造函数时完成。
  - 这不能部分实例化值并确保完全完成依赖注入。
  - 有两种可能的方法来实现这一点：

**注解配置：**这种方法使用 POJO 对象和注解进行配置。例如，考虑下面的代码片段：

```plaintext
@Configuration
@ComponentScan("com.interviewbit.constructordi")
public class SpringAppConfig {
   @Bean
   public Shape shapes() {
       return new Shapes("Rectangle");
   }
   @Bean
   public Dimension dimensions() {
       return new Dimension(4,3);
   }
}
```

这里，注解用于通知Spring运行时`@Bean`注解指定的类是bean的提供者，需要`com.interviewbit.constructordi`通过`@ComponentScan`注解对包进行上下文扫描的过程。接下来，我们将定义一个 Figure 类组件，如下所示：

```plaintext
@Component
public class Figure {
   private Shape shape;
   private Dimension dimension;
   
   @Autowired
   public Figure(Shape shape, Dimension dimension) {
       this.shape = shape;
       this.dimension = dimension;
   }
}
```

Spring 在执行上下文扫描时遇到了这个 Figure 类，它通过调用带有注释的构造函数来初始化这个类的实例`@Autowired`。Shape 和 Dimension 实例是通过调用类中带有注释的方法获得`@Bean`的`SpringAppConfig`。Engine和Transmission的实例将通过调用Config类的@Bean注解方法获得。最后，我们需要使用我们的 POJO 配置来引导 ApplicationContext：

```plaintext
ApplicationContext context = new AnnotationConfigApplicationContext(SpringAppConfig.class);
Figure figure = context.getBean(Figure.class);
```

**XML 配置**：这是使用 XML 配置文件配置 Spring 运行时的另一种方式。例如，考虑 springAppConfig.xml 文件中的以下代码片段：

```plaintext
<bean id="toyota" class="com.interviewbit.constructordi.Figure">
   <constructor-arg index="0" ref="shape"/>
   <constructor-arg index="1" ref="dimension"/>
</bean>
<bean id="shape" class="com.interviewbit.constructordi.Shape">
   <constructor-arg index="0" value="Rectangle"/>
</bean>
<bean id="dimension" class="com.interviewbit.constructordi.Dimension">
   <constructor-arg index="0" value="4"/>
   <constructor-arg index="1" value="3"/>
</bean>
```

`constructor-arg`标签可以接受文字值或另一个 bean 的引用以及显式索引和类型。索引和类型参数用于解决歧义情况下的冲突。
在引导这个类时，`ApplicationContext`需要使用`ClassPathXmlApplicationContext`如下所示的 Spring：

```plaintext
ApplicationContext context = new ClassPathXmlApplicationContext("springAppConfig.xml");
Figure figure = context.getBean(Figure.class);
```

- 基于二传手：
  - 这种形式的 DI 是在 Spring IoC 容器在调用非参数化构造函数执行 bean 实例化之后调用 bean 的 setter 方法时实现的。
  - 使用setter注入可以实现循环依赖。
  - `<property>`为了实现这种类型的DI，我们需要通过标签下的配置文件进行配置。例如，考虑一个`InterviewBit`设置属性的类，`articles`如下所示：

```plaintext
package com.interviewbit.model;
import com.interviewbit.model.Article;
public class InterviewBit {
   // Object of the Article interface
   Article article;
   public void setArticle(Article article)
   {
       this.article = article;
   }
}
```

在 bean 配置文件中，我们将进行如下设置： 

```plaintext
<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">
   <bean id="InterviewBit" class="com.interviewbit.model.InterviewBit">
       <property name="article">
           <ref bean="JsonArticle" />
       </property>
   </bean>
   <bean id="JsonArticle" class="com.interviewbit.bean.JsonArticle" />
</beans>
```

'JsonArticle' bean 通过该`setArticle`方法注入到 InterviewBit 类对象中。
在使用这两种依赖关系的情况下，通过考虑特异性性质，setter 依赖注入具有更多的偏好。

### 49. 会话范围的重要性是什么？

会话范围用于为 HTTP 会话创建 bean 实例。这意味着单个 bean 可用于服务多个 HTTP 请求。可以通过使用范围属性或使用@Scope 或@SessionScope 注释来定义bean 的范围。

- 使用范围属性：

```plaintext
<bean id="userBean" class="com.interviewbit.UserBean" scope="session"/>
```

- 使用@Scope 注解：

```plaintext
@Component
@Scope("session")
public class UserBean {
   //some methods and properties
}
```

- 使用@SessionScope：

```plaintext
@Component
@SessionScope
public class UserBean {
   //some methods and properties
}
```

### 50.@Required注解的重要性是什么？

注解用于指示 bean 的属性应通过自动装配或配置时 bean 定义期间的任何显式值来填充。例如，考虑下面的代码片段，我们需要具有年龄和姓名的值：

```plaintext
import org.Springframework.beans.factory.annotation.Required;
public class User {
   private int age;
   private String name;
   
   @Required
   public void setAge(int age) {
       this.age = age;
   }
   public Integer getAge() {
       return this.age;
   }
   
   @Required
   public void setName(String name) {
       this.name = name;
   }
   public String getName() {
       return this.name;
   }
}
```

### 51. 区分@Autowired 和@Inject 注释。

| @自动连线                                                    | @注入                                                        |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| 这个注解是 Spring 框架的一部分。                             | 此注释是 Java CDI 的一部分。                                 |
| 具有必需的属性。                                             | 没有必需的属性。                                             |
| 单例是自动装配 bean 的默认范围。                             | 原型是注入 bean 的默认范围。                                 |
| 如果有歧义，则将使用 @Qualifier 注释。                       | 如果有歧义，则需要使用 @Named 限定符。                       |
| 由于这个注解是由 Spring 框架提供的，如果你转移到另一个 Dependency injection 框架，将需要进行大量的重构。 | 由于此注解是 Java CDI 的一部分，因此它不依赖于框架，因此在框架发生更改时代码重构较少。 |

### 52. 单例 bean 是线程安全的吗？

不，单例 bean 不是线程安全的，因为线程安全的概念本质上是处理程序的执行，而单例只是一种用于创建对象的设计模式。bean 的线程安全性质取决于其实现的性质。

### 53. 如何在 bean 中实现线程安全？

线程安全可以通过将 bean 的范围更改为请求、会话或原型来实现，但要以性能为代价。这纯粹是基于项目要求。

### 54.@Repository注解有什么意义？

@Repository 注解表示组件用作存储库，充当存储、搜索或检索数据的手段。这些可以添加到 DAO 类中。

### 55、dispatcher servlet是如何实例化的？

Dispatcher servlet 通过 servlet 容器（例如 Tomcat）进行实例化。Dispatcher Servlet 应该在 web.xml 中定义 DispatcherServlet 由 Tomcat 等 Servlet 容器实例化。Dispatcher Servlet 可以在 web.xml 中定义，如下所示：

```plaintext
<?xml version="1.0" encoding="UTF-8"?>
<web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd">

 <!-- Define Dispatcher Servlet -->
 <servlet>
   <servlet-name>appServlet</servlet-name>
   <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
   <init-param>
     <param-name>contextConfigLocation</param-name>
     <param-value>/WEB-INF/spring/appServlet/servlet-context.xml</param-value>
   </init-param>
   <load-on-startup>1</load-on-startup>
 </servlet>

 <servlet-mapping>
   <servlet-name>InterviewBitServlet</servlet-name>
   <url-pattern>/</url-pattern>
 </servlet-mapping>

</web-app>
```

这里，load-on-startup 标记为 1，这表明只要 Spring MVC 应用程序到 servlet 容器，就会实例化 DispatcherServlet。在此过程中，它会查找 servlet-name-context.xml 文件并初始化文件中定义的 bean。

### 56. Spring MVC中的根应用上下文是如何加载的？

使用属于整个应用程序的 ContextLoaderListener 加载根应用程序上下文。Spring MVC 允许实例化多个 DispatcherServlet，每个 DispatcherServlet 都有多个特定于它们的上下文。它们也可以具有相同的根上下文。

### 57. Spring MVC 流程是怎样的？换句话说，当 Spring MVC 有传入请求时，DispatcherServlet 如何知道需要调用哪个 Controller？

Dispatcher Servlet 通过处理程序映射知道要调用哪个控制器。这些映射具有控制器和请求之间的映射。`BeanNameUrlHandlerMapping`并且`SimpleUrlHandlerMapping`是两个最常用的处理程序映射。

- BeanNameUrlHandlerMapping：当URL请求与bean名称匹配时，bean定义对应的类就是负责处理请求的实际控制器。
- SimpleUrlHandlerMapping：这里的映射非常明确。可以在此处指定 URL 的数量，并且每个 URL 都与控制器显式关联。

如果 Spring MVC 是使用注解配置的，则 @RequestMapping 注解用于此目的。@RequestMapping 注解是通过使用 URI 路径、HTTP 方法、查询参数和 HTTP 标头来配置的。

### 58、视图对模型的访问从哪里来？

视图需要访问模型以呈现输出，因为模型包含用于呈现的所需数据。模型与处理客户端请求并最终将响应封装到模型对象中的控制器相关联。

### 59. 为什么我们需要 BindingResults？

BindingResults 是`org.Springframework.validation`包中一个重要的 Spring 接口。该接口的调用过程非常简单易行，在检测提交表单中的错误方面起着至关重要的作用。但是，开发人员必须注意在需要验证的对象之后使用 BindingResult 参数。例如：

```plaintext
@PostMapping("/interviewbit")
public String registerCourse(@Valid RegisterUser registerUser,
 BindingResult bindingResult, Model model) {
   if (bindingResult.hasErrors()) {
       return "home";
   }
   model.addAttribute("message", "Valid inputs");
   return "home";
}
```

Spring会通过检查参数上的@Valid注解来了解找到对应的验证器。

### 60.什么是Spring拦截器？

Spring 拦截器用于对 Spring MVC 中由 Spring Controller 处理的 Web 请求进行预处理和后处理。这可以通过`HandlerInterceptor`接口来实现。这些处理程序用于操作传递给控制器或视图的模型属性。
可以为特定的 URL 映射注册 Spring 处理程序拦截器，以便它只能拦截那些请求。自定义处理程序拦截器必须实现`HandlerInterceptor`具有 3 个可以实现的回调方法的接口：

- 预句柄（）
- 后处理（）
- 完成后（）

这个接口的唯一问题是这个接口的所有方法都需要实现，而不管它的要求。`HandlerInterceptorAdapter`如果我们的处理程序类扩展了内部实现`HandlerInterceptor`接口并提供默认空白实现的类，则可以避免这种情况。

### 61. 是否需要在类路径中保留spring-mvc.jar 或者它已经作为spring-core 的一部分存在？

`spring-mv.jar`不属于弹簧芯。这意味着如果我们必须在项目中使用 Spring MVC 框架，则该 jar 必须包含在项目的类路径中。对于 Java 应用程序，`spring-mvc.jar`位于`/WEB-INF/lib`文件夹内。

### 62. <context:annotation-config> 和 <context:component-scan> 标签有什么区别？

`<context:annotation-config>`用于在应用程序上下文中激活预先注册的 bean 中的应用注释。它还注册配置文件中定义的 bean，并扫描 bean 中的注释并激活它们。

该`<context:component-scan>`标记执行`<context:annotation-config>`扫描包和在应用程序上下文中注册 bean 的任务。

> `<context:annotation-config>`= 扫描并激活预注册 bean 中的注释。
> `<context:component-scan> `=注册Bean +扫描并激活包中的注释。

### 63. Spring Web MVC Framework中表单数据校验是如何进行的？

Spring MVC 使用实现了 Validator 接口的验证器对象来完成数据验证的任务。在我们创建的自定义验证器类中，我们可以使用 ValidationUtils 类的实用方法`rejectIfEmptyOrWhitespace()`或`rejectIfEmpty()`执行表单字段的验证。

```plaintext
@Component
public class UserValidator implements Validator
{
   public boolean supports(Class clazz) {
       return UserVO.class.isAssignableFrom(clazz);
   }
 
   public void validate(Object target, Errors errors)
   {
       ValidationUtils.rejectIfEmptyOrWhitespace(errors, "name", "error.name", "Name is required.");
       ValidationUtils.rejectIfEmptyOrWhitespace(errors, "age", "error.age", "Age is required.");
       ValidationUtils.rejectIfEmptyOrWhitespace(errors, "phone", "error.phone", "Phone is required.");
   }
}
```

在需要验证的字段中，如果出现错误，验证器方法将创建字段错误并将其绑定到该字段。

要将自定义验证器激活为 spring bean，然后：

- 我们必须在自定义验证器类上添加 @Component 注释，并通过添加以下更改来启动包含验证器声明的包的组件扫描：

```plaintext
<context:component-scan base-package="com.interviewbit.validators"/>
```

要么

验证器类可以直接在上下文文件中注册为 bean，如下所示：

```plaintext
<bean id="userValidator" class="com.interviewbit.validators.UserValidator" />
```

### 64. spring bean中如何获取ServletConfig和ServletContext对象？

这可以通过实现 spring-aware 接口或使用 @Autowired 注释来完成。

```plaintext
@Autowired
private ServletContext servletContext;
@Autowired
private ServletConfig servletConfig;
```

### 65. 区分 Bean 工厂和应用程序上下文。

BeanFactory 和 ApplicationContext 都是 Java 接口。不同之处在于 ApplicationContext 扩展了 BeanFactory。BeanFactory 提供 IoC 和 DI 基本功能，而 ApplicationContext 提供更高级的功能。以下是这两者之间的区别：

| 类别          | 豆厂                                                         | 应用程序上下文                                               |
| :------------ | :----------------------------------------------------------- | :----------------------------------------------------------- |
| 国际化 (i18n) | 不提供对 i18n 的支持。                                       | 提供对 i18n 的支持。                                         |
| 活动发布      | 通过使用 ContextStartedEvent 和 ContextStoppedEvent 分别在启动和停止时发布上下文，提供向侦听器 bean 发布事件的能力。 | ApplicationContext 通过 ApplicationListener 接口和 ApplicationEvent 类支持事件处理。 |
| 实现          | XMLBeanFactory 是 BeanFactory 的流行实现。                   | ClassPathXmlApplicationContext 是 ApplicationContext 的流行实现。此外，Java 使用 WebApplicationContext 扩展接口并添加 getServletContext() 方法。 |
| 自动装配      | 对于自动装配，bean 必须在 AutoWiredBeanPostProcessor API 中注册。 | 在这里，可以做XML配置来实现自动装配。                        |

### 66. Spring MVC 中如何支持 i18n 和本地化？

Spring MVC`LocaleResolver`支持 i18n 和本地化。支持国际化和本地化。需要在应用程序中配置以下 bean：

- **SessionLocaleResolver：**此 bean 在从用户会话中的预定义属性中获取和解析语言环境方面起着至关重要的作用。

句法：

```plaintext
<bean id="localeResolver"class="org.Springframework.web.servlet.i18n.SessionLocaleResolver">
   <property name="defaultLocale" value="en" />
</bean>
```

- **LocaleChangeInterceptor：**这个 bean 对于解析传入请求的参数很有用。

句法：

```plaintext
<bean id="localeChangeInterceptor"class="org.Springframework.web.servlet.i18n.LocaleChangeInterceptor">
   <property name="paramName" value="lang" />
</bean>
```

- **DefaultAnnotationHandlerMapping：**这是指 HandlerMapping 接口实现，它根据在类型或方法级别的 @RequestMapping 中指定的 HTTP 路径映射处理程序/拦截器。

句法：

```plaintext
<bean class="org.Springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping">
   <property name="interceptors">
       <list>
           <ref bean="localeChangeInterceptor" />
       </list>
   </property>
</bean>
```

### 67、你对MultipartResolver的理解是什么？

MultipartResolver 用于处理 Spring Web 应用程序中的文件上传场景。在 Spring 中有 2 个具体的实现，它们是：

- CommonsMultipartResolver 适用于 Jakarta Commons FileUpload
- StandardServletMultipartResolver 用于 Servlet 3.0 Part API

为了实现这一点，我们需要在 DispatcherServlet 的应用程序上下文中创建一个 id="multipartResolver" 的 bean。这样做可确保 DispatcherServlet 处理的所有请求在检测到多部分请求时都应用此解析器。如果 DispatcherServlet 检测到多部分请求，它会通过已配置的 MultipartResolver 解析请求，并将请求作为包装/抽象的 HttpServletRequest 传递。然后控制器将此请求转换为`MultipartHttpServletRequest`接口以访问 Multipart 文件。下图清楚地说明了流程：

![img](https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/845/original/MultipartResolver.jpg?1628748693)

### 68. 如何在 Spring 应用程序中使用 Tomcat JNDI DataSource？

要使用在 JNDI（Java 命名和目录接口）DataSource 中配置的 servlet 容器，必须在 spring bean 配置文件中配置 DataSource bean，然后将其作为依赖项注入到 bean 中。发布此消息后，DataSource bean 可用于通过 JdbcTemplate 执行数据库操作。注册 MySQL DataSource bean 的语法：

```plaintext
<bean id="dataSource" class="org.springframework.jndi.JndiObjectFactoryBean">
   <property name="jndiName" value="java:comp/env/jdbc/MySQLDB"/>
</bean>
```

### 69. 如果用户先选中复选框，其他字段出现验证错误，然后在收到错误后取消选中复选框，那么复选框输入的选择状态是什么？

验证通常在 HTTP POST 请求期间执行。在 HTTP 请求期间，如果复选框的状态未选中，则 HTTP 包含复选框的请求参数，因此不会获取更新的选择。这可以通过使用以`_`Spring MVC 开头的隐藏表单字段来解决。

### 结论：

在这篇文章中，我们看到了面试中最常被问到的春季面试问题。Spring 是一个非常强大的框架，允许构建企业级 Web 应用程序。使用 Spring 开发的应用程序通常快速、可扩展且透明。因此，Spring 已被庞大的 Java 开发人员社区所接受，从而使其成为任何 Java 开发人员工作角色中不可避免的一部分。了解 Spring 可确保开发人员在他们的职业生涯中也能稳步进步。

提示：我们还建议阅读[此处](https://spring.io/guides)发布的指南。

## 春季多选题

1.

需要注册以下哪些选项才能在启动时加载应用程序的根上下文？

上下文加载器监听器

ContextLoaderStarter

根上下文监听器

RootContextTrigger

2.

Spring中关闭IoC容器的方法是什么？

registerHook(关机)

关机钩子（真）

registerShutdownHook()

shutdownHandlerHook()

3.

Spring中的autowire有哪些类型？选择正确的选项。

byName、byType、析构函数和自动检测

byMethod、byName、自动更正和自动检测

byName、byType、byValue 和自动检测

byName、byType、构造函数和自动检测

4.

哪种方法允许在 Spring 中启动新事务？

开始会话（）

获取交易（）

开始新事务（）

获取会话（）

5.

什么属性用于处理 Web 请求流？

servlet 映射

小服务程序属性

小服务程序流

servlet 流请求

6.

联合点执行完成后会运行什么建议？

@AfterFinish

@AfterJoint

@AfterPoint

@后

7.

以下代码的输出是什么？

```plaintext
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.AfterThrowing;
@Aspect
public class SampleAspectClass {
   
   @AfterThrowing(pointcut="com.interviewbit.Operations.someOperation()", throwing="ex")
   public void doRecoveryActions(DataAccessException e){
       throw new IllegalArgumentException();
   }
}
```

IllegalArgumentException

BeanCreationException

运行时错误

空指针异常

8.

哪种方法会从 List 到 List 未经检查的转换导致编译器发出警告？

createNativeQuery()

找到所有（）

全部更新（）

批处理插入（）

9.

什么注释用于查找事务并通过抱怨没有 Hibernate 会话绑定到线程而失败？

@TransactionFail

@TransactionHandler

@TransactionResolver

@Transactional

10.

工厂 bean 使用什么属性来加载休眠配置文件？

配置位置

配置

配置文件

hbm-配置

11.

下列关于 Spring 的说法正确的是？

Spring 允许开发人员开发企业级 Web 应用程序。

Spring 允许开发人员以模块化的方式进行编码。

Spring 确保应用程序测试变得简单。

上述所有的

12.

byName 类型的自动装配有什么作用？

byName 模式意味着没有自动装配，需要添加显式引用。

byName 模式确保自动装配是通过属性名称完成的。Spring 将属性与配置文件中定义的同名 bean 匹配并连接。

在这种模式下，Spring 首先由构造函数自动装配，如果没有找到，它会尝试按类型自动装配。

此模式类似于 byType 模式，但仅限于非参数化构造函数。

13.

以下哪个类用于将数据库行映射到 Spring 中的 java 对象？

行映射器

结果集

行集映射器

结果集映射器

14.

什么类用于提供 DispatcherServlet 的类行为？

存储库

抽象动作

抽象控制器

控制器

15.

下面哪个是 Spring 中的 Handler 方法注解？

@RequestMapping

@控制器

@服务

@解决

16.

使用 @RequestMapping 的处理程序方法中使用了哪些方法参数？

@控制器

@豆角，扁豆

@RequestParam

@服务

17.

ViewResolvers 中的哪一个将视图名称解析为应用程序的目录？

内部解析器

内部视图解析器

内部请求解析器

内部资源视图解析器

18.

以下哪个注释表示字段不能为空？

@不是空的

@NotNull

@NeverNull

上述所有的

19.

什么注解以正则表达式的形式接收值？

@图案

@密码

@电子邮件

@有效的

20.

什么是用来通知会话处理完成的？

绑定结果

Http状态

会话状态

会议

**使用 Scaler 进入顶级产品公司**了解更多



![点标记 b3add1cc88e4996b2df6e0aedb9f0d1b65fa73c51b7ada8fbee3895a2aa11802.svg](https://assets.interviewbit.com/assets/ibpp/point-markers-b3add1cc88e4996b2df6e0aedb9f0d1b65fa73c51b7ada8fbee3895a2aa11802.svg.gz)

![点标记 b3add1cc88e4996b2df6e0aedb9f0d1b65fa73c51b7ada8fbee3895a2aa11802.svg](https://assets.interviewbit.com/assets/ibpp/point-markers-b3add1cc88e4996b2df6e0aedb9f0d1b65fa73c51b7ada8fbee3895a2aa11802.svg.gz)

![点标记 b3add1cc88e4996b2df6e0aedb9f0d1b65fa73c51b7ada8fbee3895a2aa11802.svg](https://assets.interviewbit.com/assets/ibpp/point-markers-b3add1cc88e4996b2df6e0aedb9f0d1b65fa73c51b7ada8fbee3895a2aa11802.svg.gz)

![点标记 b3add1cc88e4996b2df6e0aedb9f0d1b65fa73c51b7ada8fbee3895a2aa11802.svg](https://assets.interviewbit.com/assets/ibpp/point-markers-b3add1cc88e4996b2df6e0aedb9f0d1b65fa73c51b7ada8fbee3895a2aa11802.svg.gz)



[![定标器徽标 27a9b9093de1d977bad45ed9dff8addbd1bb0f14bb4f34399bdcf7a2b71a4e2a.svg](https://assets.interviewbit.com/assets/scaler/svg/scaler-logo-27a9b9093de1d977bad45ed9dff8addbd1bb0f14bb4f34399bdcf7a2b71a4e2a.svg.gz)](https://www.scaler.com/academy?utm_source=ib&utm_campaign=ib_menu&utm_medium=nav_menu)

[![img](https://assets.interviewbit.com/assets/ibpp/brand-inv-a62b6669d8645925b8094c7322d36b2039344b7af7a6a252a64acd867556b610.svg.gz)](https://www.interviewbit.com/)

- [博客](https://www.interviewbit.com/blog/)
- 

- [社区](https://www.interviewbit.com/discussion/)
- 

- [关于我们](https://www.interviewbit.com/pages/about_us/)
- 

- [常问问题](https://www.interviewbit.com/pages/faq/)
- 

- [联系我们](https://www.interviewbit.com/pages/contact_us/)
- 

- [条款](https://www.interviewbit.com/pages/terms/)
- 

- [隐私政策](https://www.interviewbit.com/pages/privacy/)
- 



- 

- 
- 
- 

- - [**练习题**](https://www.interviewbit.com/practice/)
  - [编程](https://www.interviewbit.com/courses/programming/)
  - [脚本](https://www.interviewbit.com/courses/shell/)
  - [系统设计](https://www.interviewbit.com/courses/system-design/)
  - [数据库](https://www.interviewbit.com/courses/databases/)
  - [谜](https://www.interviewbit.com/puzzles/)
- - [**快速通道课程**](https://www.interviewbit.com/courses/fast-track/)
  - [Python](https://www.interviewbit.com/courses/fast-track-python/)
  - [爪哇](https://www.interviewbit.com/courses/fast-track-java/)
  - [C++](https://www.interviewbit.com/courses/fast-track-cpp/)
  - [Javascript](https://www.interviewbit.com/courses/fast-track-js/)

- **在线面试位编译器**

- [在线 C 编译器](https://www.interviewbit.com/online-c-compiler/)
- [在线 C++ 编译器](https://www.interviewbit.com/online-cpp-compiler/)
- [在线 Java 编译器](https://www.interviewbit.com/online-java-compiler/)
- [在线 Javascript 编译器](https://www.interviewbit.com/online-javascript-compiler/)
- [在线 Python 编译器](https://www.interviewbit.com/online-python-compiler/)



- **面试准备**

- [系统设计问题](https://www.interviewbit.com/courses/system-design/)
- [谷歌面试问题](https://www.interviewbit.com/google-interview-questions/)
- [Facebook 面试问题](https://www.interviewbit.com/facebook-interview-questions/)
- [亚马逊面试问题](https://www.interviewbit.com/amazon-interview-questions/)
- [微软面试问题](https://www.interviewbit.com/microsoft-interview-questions/)
- [Javascript 面试问题](https://www.interviewbit.com/javascript-interview-questions/)
- [jQuery 面试问题](https://www.interviewbit.com/jquery-interview-questions/)
- [角度面试问题](https://www.interviewbit.com/angular-interview-questions/)
- [数据结构面试题](https://www.interviewbit.com/data-structure-interview-questions/)
- [Directi面试问题](https://www.interviewbit.com/directi-interview-questions/)
- [雅虎面试问题](https://www.interviewbit.com/yahoo-interview-questions/)
- [领英面试问题](https://www.interviewbit.com/linkedin-interview-questions/)
- [易趣面试问题](https://www.interviewbit.com/ebay-interview-questions/)
- [Flipkart 面试问题](https://www.interviewbit.com/flipkart-interview-questions/)
- [甲骨文面试问题](https://www.interviewbit.com/oracle-interview-questions/)
- [Adobe 面试问题](https://www.interviewbit.com/adobe-interview-questions/)
- [C 面试问题](https://www.interviewbit.com/c-interview-questions/)
- [PHP面试问题](https://www.interviewbit.com/php-interview-questions/)
- [C Sharp 面试问题](https://www.interviewbit.com/c-sharp-interview-questions/)
- [Web API 面试题](https://www.interviewbit.com/web-api-interview-questions/)
- [Hibernate 面试题](https://www.interviewbit.com/hibernate-interview-questions/)
- [Node Js 面试题](https://www.interviewbit.com/node-js-interview-questions/)
- [Cpp面试问题](https://www.interviewbit.com/cpp-interview-questions/)
- [哎呀面试问题](https://www.interviewbit.com/oops-interview-questions/)
- [Devops 面试问题](https://www.interviewbit.com/devops-interview-questions/)
- [机器学习面试题](https://www.interviewbit.com/machine-learning-interview-questions/)
- [Docker 面试问题](https://www.interviewbit.com/docker-interview-questions/)
- [Mysql面试题](https://www.interviewbit.com/mysql-interview-questions/)
- [Css 面试题](https://www.interviewbit.com/css-interview-questions/)
- [Laravel 面试问题](https://www.interviewbit.com/laravel-interview-questions/)
- [Asp Net 面试题](https://www.interviewbit.com/asp-net-interview-questions/)
- [Django 面试问题](https://www.interviewbit.com/django-interview-questions/)
- [点网面试题](https://www.interviewbit.com/dot-net-interview-questions/)
- [Kubernetes 面试问题](https://www.interviewbit.com/kubernetes-interview-questions/)
- [操作系统面试题](https://www.interviewbit.com/operating-system-interview-questions/)
- [React Native 面试问题](https://www.interviewbit.com/react-native-interview-questions/)
- [Aws 面试问题](https://www.interviewbit.com/aws-interview-questions/)
- [Git 面试问题](https://www.interviewbit.com/git-interview-questions/)
- [Java 8 面试题](https://www.interviewbit.com/java-8-interview-questions/)
- [Mongodb 面试题](https://www.interviewbit.com/mongodb-interview-questions/)
- [DBMS 面试题](https://www.interviewbit.com/dbms-interview-questions/)
- [Spring Boot 面试题](https://www.interviewbit.com/spring-boot-interview-questions/)
- [Power Bi 面试题](https://www.interviewbit.com/power-bi-interview-questions/)
- [Pl Sql 面试问题](https://www.interviewbit.com/pl-sql-interview-questions/)
- [Tableau 面试问题](https://www.interviewbit.com/tableau-interview-questions/)
- [Linux 面试问题](https://www.interviewbit.com/linux-interview-questions/)
- [Ansible 面试问题](https://www.interviewbit.com/ansible-interview-questions/)
- [Java 面试问题](https://www.interviewbit.com/java-interview-questions/)
- [詹金斯面试问题](https://www.interviewbit.com/jenkins-interview-questions/)
- [敏捷面试问题](https://www.interviewbit.com/agile-interview-questions/)
