# Spring框架

- Spring 是一个功能强大的开源、松散耦合、轻量级的[Java 框架](https://www.interviewbit.com/java-interview-questions/)，
- 旨在降低开发企业级应用程序的复杂性。
- 这个框架也被称为“框架的框架”，因为 Spring 提供了对各种其他重要框架的支持，如 JSF、Hibernate、Structs、EJB 等。
- 大约有 20 个模块，可概括为以下类型：
  - 核心容器
  - 数据访问/集成
  - 网络
  - AOP（面向方面编程）
  - 仪器仪表
  - 消息传递
  - 测试



# Spring设计模式

参考：

* 2022-4-2

* [spring 设计模式](https://www.baeldung.com/spring-framework-design-patterns)

设计模式是软件开发的基础部分。这些方法不仅可以解决重复发生的问题，还能帮助开发者通过识别设计模式来理解框架的设计。

本文关注四种Spring框架中最常见的设计模式

1. 单例模式
2. 工厂方法模式
3. 代理模式
4. 模板模式

看看Spring如何使用这些模式去减少开发者的负担并帮助用户快速实施繁琐的任务

## 2. 单例模式

单例模式是一种确保每个应用程序只存在一个对象实例的机制。这种模式在管理共享资源或提供横切服务（例如日志记录）时很有用。

### 2.1. Singleton Beans

通常，单例对于应用程序来说是全局唯一的，但是在 Spring 中，这个约束被放宽了。相反，Spring 将单例限制为每个 Spring IoC 容器一个对象。实际上，这意味着 Spring 只会为每个应用程序上下文的每种类型创建一个 bean。

Spring 的方法不同于对单例的严格定义，因为一个应用程序可以有多个 Spring 容器。因此，如果我们有多个容器，同一类的多个对象可以存在于单个应用程序中。

![]![img](https://www.baeldung.com/wp-content/uploads/2020/02/Singleton.png)

默认情况下，Spring 将所有 bean 创建为单例。

## 策略模式

AOP选择使用哪种代理模式就是使用的策略模式

* AopProxy是策略接口
* JdkDynamicAopProxy、CglibAopProxy是两个实现了AopProxy接口的策略类

## 工厂模式

### 简单工厂模式

### 工厂方法模式



# SpringAOP

**目的**：减少重复代码

**实现原理：**代理模式（动态代理+cglib）

**编程中，对象与对象之间，方法与方法之间，模块与模块之间都是一个个切面**。

**关键词**：

1. 连接点： 所有可能的需要注入切面的地方。如方法前后、类初始化、属性初始化前后等等。
2. 切点 需要做某些处理（如打印日志、处理缓存等等）的连接点。如何来指明一个切点？spring使用了AspectJ的切点表达式语言来定义Spring切面。
3. 通知： 定义在什么时候做什么事情。spring支持5种方法上的通知类型
4. 切面（Aspect）：通知+切点的集合，定义在什么地方什么时间做什么事情。
5. 引入（Introduction）： 允许我们向现有的类添加新方法属性。这不就是把切面（也就是新方法属性：通知定义的）用到目标类中吗
6. 目标（Target）： 引入中提到的目标类，也就是要被通知的对象。也就是真正的业务逻辑，他可以在毫不知情的情况下，被咱们织入切面。而自己专注于业务本身的逻辑。
7. 织入（Weaving）： 把切面应用到目标对象来创建新的代理对象的过程。
8. 

## 实现 动态代理模式

* 当实现接口时，使用JDK动态代理
* 没有实现接口时，使用cglib代理



**为其他对象提供一种代理以控制对这个对象的访问**

* 静态代理：由程序员创建或特定工具自动生成源代码，再对其编译。在程序运行前，代理类的.class文件就已经存在了。

* 动态代理：在程序运行时，运用反射机制动态创建而成，无需手动编写代码。动态代理不仅简化了编程工作，而且提高了软件系统的可扩展性，因为Java反射机制可以生成任意类型的动态代理类。

**代理原理**：

1. 代理对象内部含有对真实对象的引用，从而可以操作真实对象，
2. 同时代理对象提供与真实对象相同的接口以便在任何时刻都能代替真实对象。
3. 同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装。



# IoC inverse of control

1.**谁控制谁？**：在以前，对象的创建和销毁都是由用户控制的，用了ioc之后，对象的创建和销毁就都交给容器来控制了，用户就不用管这些，只关注业务需求就好了；

控制反转

* 控制反转就是把对象或程序的一部分转交给容器或框架

* 有多种机制可以实现控制反转，比如策略模式、服务定位器模式、工厂模式、依赖注入等

### 参考文档

* https://www.baeldung.com/inversion-control-and-dependency-injection-in-spring



## IoC容器

* Spring 容器构成了 Spring Framework 的核心。
* Spring 容器使用依赖注入 (DI) 通过创建对象、将它们连接在一起以及配置和管理它们的整体生命周期来管理应用程序组件。
* Spring 容器执行任务的指令可以通过 XML 配置、Java 注释或 Java 代码提供。

* IoC容器是实现了控制反转的框架们的共同特性
* 在Spring中，*ApplicationContext* 接口就代表了IOC容器 。
* Spring容器担负着实例化、配置和组装注入beans等对象的职责，同时还要管理它们的生命周期。

Spring框架提供了几种 *ApplicationContext*接口的实现。*ClassPathXmlApplicationContext*和 *FileSystemXmlApplicationContext*对应独立的应用，*WebApplicationContext* 对应web应用。

为了组装beans，容器使用以xml或注解形式存储的配置元数据

下面是一种手动实例化容器的方法

```java
ApplicationContext context
  = new ClassPathXmlApplicationContext("applicationContext.xml");
```

上述案例中，为了设置属性，我们可以使用元数据。接着容器就会在运行时读取元数据并组装beans。

Spring 中的依赖注入可以通过构造函数、setter 或字段来完成。

## Beans生命周期

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/461189abf3044e94a888a4b9d8b058d0~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

Bean生命周期如下：

1. IoC 容器从 XML 文件中的 bean 定义实例化 bean。
2. 然后 Spring 使用 bean 定义中指定的依赖注入填充所有属性。
3. 获取bean ID的bean工厂容器调用`setBeanName()`，对应的bean必须实现`BeanNameAware`接口。
4. 然后工厂`setBeanFactory()`通过传递自身的实例来调用（如果 BeanFactoryAware 接口在 bean 中实现）。
5. 如果`BeanPostProcessors`与 bean 相关联，则`preProcessBeforeInitialization()`调用方法。
6. 如果指定了一个 init-method，那么它将被调用。
7. 最后，`postProcessAfterInitialization()`如果有任何 BeanPostProcessor 与需要在创建后运行的 bean 关联，则将调用方法。
8. 使用Bean
9. 容器销毁前，调用bean的销毁方法

# java依赖注入



##  引言
一个老板雇了一个程序员，为他编写一个看电影的方法。
老板最开始家境贫寒，只有走路去，程序员将方法实现为
```java
public void watchMovie(){
	Ststem.out.println("go to cinema on foot;" );
}
```
突然有一天，老板一夜暴富，买了一辆车，那么以后就可以开车去看电影了，程序员将方法实现改为
```java
public void watchMovie(){
	Ststem.out.println("go to cinema by car;" );
}
```
又过了一段时间，老板发现身边潮流变成了自行车出行，要求程序员继续修改，程序员又将方法实现改为
```java
public void watchMovie(){
	Ststem.out.println("go to cinema by bike;" );
}
```
长此以往，每次都要改，程序员觉得实在太麻烦了，既然刁老板这么爱改，怎么去电影院干脆不写死了，留给老板定。这在写方法的时候很容易想到解决方案：定义一个形参，通过传参的方法确定去电影院的方式
```java
public void watchMovie(String transportation){
	Ststem.out.println("go to cinema " + transportation);
}
```
如此一来，以后就不用每次修改代码了
## 依赖
一个类依赖于另一个类的定义
**举例**
在SpringBoot中，Controller和ServiceImpl之间就是一种依赖关系，前者需要使用后者提供的服务
假如没有依赖注入，Controller想要使用ServiceImpl最简单直接的方式是new一个实例
```java
class PeopleController{
	PeopleServiceImpl p = new PeopleServiceImpl;
	p.watchMovie();
}
class PeopleServiceImpl{
	public void watchMovie(){
		Ststem.out.println("go to cinema by car;" );
    }
}
```
## 问题

那么问题来了，就像引言里提到的那样，看电影可以有多种实现方式，开车、骑车等等，根据单一职责原则，这些不同的方法实现应该写在不同的PeopleServiceImpl类里，按照上面的写法，Controller每次选择不同的出行方式都要实例化一个新的类，这就需要修改PeopleController里的源代码。

这个问题该如何解决呢？
## 依赖注入
同样的，跟引言里设置形参的思路相同，在PeopleController里也不把实例化哪个类直接定死，而是交给外部决定。或者说把实例化依赖的方式更改为外部注入依赖。（这也是实现控制反转IoC的重要方式，将对类的控制交给外部，也就是Spring容器），这就是依赖注入
## 具体实现
依赖注入有三种常见的方式,在介绍这三种方式之前，首先介绍另一个遗留的问题。

上述包含看电影方法的不同类都只有一个看电影方法，根据面向接口编程的原则，首先可以抽象出一个PeopleService接口，它提供了看电影的声明，以后想要添加别的实现方式只用实现这个接口就行了。


```java
@Service
interface PeopleService{
	public void watchMovie();
}
```
这个接口也是后续实现依赖注入必不可少的组成。因为在上面的看电影方法设置形参时，我们默认交通工具是一种String。但在依赖注入时，由于不知道将来会将哪个类注入进Controller，所以无法在形参中确定数据类型。有了这个接口之后，就可以将数据类型统一声明为PeopleService。因为实现了这个接口的类都可以用PeopleService声明
### 基于构造器
```java
class PeopleController{
	private PeopleService p;
	PeopleController(PeopleService peopleService){
		this.p = peopleService;
	}
}
```
### 基于setter的依赖注入
```java
class PeopleController{
	private PeopleService p;
	public void setService(PeopleService peopleService){
	this.p = peopleService;
	}
}
```

### 基于field的依赖注入
使用 @Autowired注解进行依赖注入
```java
public class PeopleController {
    @Autowired
    private PeopleService p;
}
```
这种方法看起来更加简单，但不推荐使用，因为有下列缺陷

* 该方法使用反射来注入依赖项，这比基于构造函数或基于 setter 的注入成本更高。
* 使用这种方法继续添加多个依赖项真的很容易。如果我们使用构造函数注入，有多个参数会让我们认为类做不止一件事，这可能违反单一职责原则
* 当同一个接口有多个实现时，需要进一步配置

扩展阅读[JavaGuide](https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html#%E6%B3%A8%E5%85%A5-bean-%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%9C%89%E5%93%AA%E4%BA%9B)
* Autowired 属于 Spring 内置的注解，默认的注入方式为byType（根据类型进行匹配），也就是说会优先根据接口类型去匹配并注入 Bean （接口的实现类）。

* 这会有什么问题呢？ 当一个接口存在多个实现类的话，byType这种方式就无法正确注入对象了，因为这个时候 Spring 会同时找到多个满足条件的选择，默认情况下它自己不知道选择哪一个。
* 这种情况下，注入方式会变为 byName（根据名称进行匹配），这个名称通常就是类名（首字母小写）。就比如说下面代码中的 smsService 就是我这里所说的名称，这样应该比较好理解了吧。

**Java Dependency Injection** 设计模式允许我们移除硬编码依赖，使我们的应用松耦合、可扩展、可维护。我们可以实现依赖注入来移除从编译到运行时的依赖处理处理.

**依赖**：一个类依赖于另一个类的定义

比如Controller依赖ServiceImpl，想要使用ServiceImpl提供的服务

常规的处理依赖的方式，new一个实例

```java
class PeopleController{
	PeopleServiceImpl p = new PeopleServiceImpl;
}
```

**缺点**：

* 紧耦合
* 硬编码 想要修改只能改源代码重新编译

场景，假设ServiceImpl提供的一项服务是去看电影

```java
class PeopleServiceImpl{
	public void watchMovie(){
		go to cinema on foot;
    }
}
```

原本的实现是走路去电影院，现在希望多一个开车去电影院，并在PeopleController使用

解决办法是

1. 新建一个 PeopleServiceImpl2，
2. 重新写watchMovie方法，
3. 修改PeopleController中的实例

假如将来又有了一个新的坐车去电影院，那上述步骤又要重新完成。每次有新的需求都要重新走一遍1-3。

这种情况就要考虑怎么把这些重复的工作封装起来

**解决**：

首先考虑实例化，由于上面定死了实例化方式，导致每次使用新的方法都要重新修改

这里最先想到的就是把实例化封装起来，通过外部传参的形式实例化

这是很容易想到的。



## 优点|缺点

- 可配置的组成让应用更容易扩展 
- 使用模拟对象使单元测试更简单
- 

### Disadvantages of Java Dependency Injection

Java Dependency injection has some disadvantages too:

- If overused, it can lead to maintenance issues because the effect of changes are known at runtime.
- Dependency injection in java hides the service class dependencies that can lead to runtime errors that would have been caught at compile time.

# Spring面试题

### 

### 6.解释构造函数和setter注入的区别？

- 在构造函数注入中，部分注入是不允许的，而在 setter 注入中是允许的。
- 构造函数注入不会覆盖 setter 属性，而 setter 注入则不然。
- 如果完成任何修改，构造函数注入会创建一个新实例。在 setter 注入中无法创建新实例。
- 如果 bean 有很多属性，那么构造函数注入是首选。如果它的属性很少，则首选 setter 注入。

### 7. 什么是 Spring Bean？

- 它们是构成用户应用程序主干的对象，由 Spring IoC 容器管理。
- Spring bean 由 IoC 容器实例化、配置、连接和管理。
- Bean 是使用用户提供给容器的配置元数据创建的（通过 XML 或 java 注释配置）。

### 8、配置元数据是如何提供给spring容器的？

提供配置元数据的方式有 3 种。它们如下：

- **基于 XML 的配置：** bean 配置及其依赖项在 XML 配置文件中指定。这以 bean 标记开始，如下所示：

```plaintext
   <bean id="interviewBitBean" class="org.intervuewBit.firstSpring.InterviewBitBean">
    <property name="name" value="InterviewBit"></property>
   </bean>
```

- 基于注释的配置：

  可以通过在相关类、方法或字段声明上使用注释将 bean 配置到组件类本身，而不是 XML 方法。

  - 默认情况下，注解连接在 Spring 容器中是不活动的。这必须在 Spring XML 配置文件中启用，如下所示

```plaintext
<beans>
<context:annotation-config/>
<!-- bean definitions go here -->
</beans>
```

- 基于 Java 的配置：

   Spring Framework 引入了关键特性作为新的 Java 配置支持的一部分。这利用了

  @Configuration

  注释类和

  @Bean

  注释方法。

  注意：

  - @Bean 注解与 <bean/> 元素的作用相同。
  - 使用 @Configuration 注解的类允许通过简单地调用同一类中的其他 @Bean 方法来定义 bean 间的依赖关系。

### 9. Spring 中可用的 bean 作用域有哪些？

Spring 框架有五个范围支持。他们是：

- **单例：**使用它时 bean 定义的范围将是每个 IoC 容器的单个实例。
- **原型：**在这里，单个 bean 定义的范围可以是任意数量的对象实例。
- **请求：** bean 定义的范围是一个 HTTP 请求。
- **Session：**这里，bean定义的范围是HTTP-session。
- **Global-session：**这里bean定义的范围是一个Global HTTP session。

注意：最后三个范围仅在用户使用 Web 感知 ApplicationContext 容器时可用。



### 12.什么是自动装配并命名它的不同模式？

IoC 容器自动装配应用程序 bean 之间的关系。Spring 让协作者通过检查 BeanFactory 的内容来解决必须自动连接的 bean。
这个过程的不同模式是：

- **no**：这意味着**没有自动装配**，是默认设置。应使用显式 bean 引用进行接线。
- **byName**：根据bean的**名字**注入bean依赖。这会将其属性与配置中由相同名称定义的 bean 匹配并连接。
- **byType**：这会根据**type**注入 bean 依赖项。
- **constructor ：在这里，它****通过调用类的构造函数**来注入 bean 依赖项。它有大量的参数。
- **autodetect**：首先容器尝试通过构造函数使用 autowire 进行连接，如果不可能，则尝试通过 byType 自动连接。

### 13. 自动装配有什么限制？

- **覆盖可能性**：使用 覆盖自动装配的设置`<constructor-arg>`来指定依赖关系。`<property>`
- **数据类型限制**：原始数据类型、字符串和类不能自动装配。

## Spring Boot 面试题

### 14. 你对“Spring Boot”这个词是怎么理解的？

Spring Boot 是一个开源的、基于 java 的框架，它为快速应用程序开发提供支持，并为开发独立和生产就绪的 Spring 应用程序提供了一个平台，只需要很少的配置。

### 15. 解释使用 Spring Boot 进行应用程序开发的优势。

- Spring Boot 有助于创建可以使用 java.jar 启动的独立应用程序（不需要配置 WAR 文件）。
- Spring Boot 还为 Maven 配置提供了精确的“启动”POM。
- 可以直接嵌入 Undertow、Tomcat、Jetty 或其他 Web 服务器。
- 自动配置：提供一种基于类路径上存在的依赖项自动配置应用程序的方法。
- Spring Boot 的开发旨在减少代码行数。
- 它提供了生产就绪的支持，如监控和使用 Spring Boot 开发的应用程序更容易启动。

### 16.区分Spring和Spring Boot。

- Spring Framework 提供了多种功能，如依赖注入、数据绑定、面向方面编程 (AOP)、数据访问等，有助于更轻松地开发 Web 应用程序，而 Spring Boot 通过简化或管理各种松散耦合的 Spring 块很乏味并且有可能变得混乱。
- Spring Boot 简化了常用的 Spring 依赖项，并直接从命令行运行应用程序。它也不需要应用程序容器，它有助于监控多个组件并在外部配置它们。

### 17. Spring Boot 有哪些特点？

- **Spring Boot CLI** – 这允许您使用 Groovy / Maven 编写 Spring Boot 应用程序并避免样板代码。
- **Starter Dependency** – 在这个特性的帮助下，Spring Boot 将常见的依赖聚合在一起，最终提高生产力并减轻负担
- **Spring Initializer** – 这是一个 Web 应用程序，可帮助开发人员创建内部项目结构。开发人员在使用此功能时不必手动设置项目结构。
- **自动配置**——这有助于根据您正在处理的项目加载默认配置。通过这种方式，可以避免不必要的 WAR 文件。
- **Spring Actuator** – Spring Boot 使用执行器提供“管理端点”，帮助开发人员完成应用程序内部、指标等。
- **日志记录和安全**性——这确保了所有使用 Spring Boot 制作的应用程序都得到了适当的保护，没有任何麻烦。

## Spring AOP、Spring JDBC、Spring Hibernate 面试题

### 29.什么是Spring AOP Proxy模式？

- 代理模式是一种常用的设计模式，其中代理是一个看起来像另一个对象但在幕后为其添加特殊功能的对象。
- Spring AOP 遵循基于代理的模式，这是由 AOP 框架创建的，用于在运行时实现切面契约。
- 标准 JDK 动态代理是默认的 AOP 代理，它允许代理任何接口。Spring AOP 还可以使用代理类而不是接口所需的 CGLIB 代理。如果业务对象没有实现接口，则默认使用 CGLIB 代理。

### 30. Spring JDBC API 有哪些类？

- 以下是课程
  - Jdbc模板
  - SimpleJdbc模板
  - 命名参数JdbcTemplate
  - SimpleJdbcInsert
  - SimpleJdbcCall
- 最常用的是JdbcTemplate。这在内部使用了 JDBC API，优点是我们不需要创建连接、语句、启动事务、提交事务和关闭连接来执行不同的查询。所有这些都由 JdbcTemplate 自己处理。开发人员可以专注于直接执行查询。

### 31. Spring JdbcTemplate如何获取记录？

这可以通过使用 JdbcTemplate 的查询方法来完成。有两个接口可以帮助做到这一点：

- 结果集提取器：
  - 它只定义了一种`extractData`接受`ResultSet`实例作为参数并返回列表的方法。
  - 句法：

```plaintext
public T extractData(ResultSet rs) throws SQLException,DataAccessException;
```

- 行映射器：
  - 这是 ResultSetExtractor 的增强版，节省了大量代码。
  - 它允许映射一行与用户定义类的实例的关系。
  - 它在内部迭代 ResultSet 并将其添加到结果集合中，从而节省了大量用于获取记录的代码。

### 32.什么是Hibernate ORM框架？

- 对象关系映射 (ORM) 是将应用程序域模型对象映射到关系数据库表的现象，反之亦然。
- Hibernate 是最常用的基于 Java 的 ORM 框架。

### 33、使用Spring访问Hibernate的两种方式是什么？

- 使用 Hibernate 模板和回调的控制反转方法。
- 扩展`HibernateDAOSupport`和应用 AOP 拦截器节点。

### 34.什么是Hibernate验证器框架？

- 数据验证是任何应用程序的关键部分。我们可以在以下位置找到数据验证：
  - 将对象发送到服务器之前的 UI 层
  - 在处理它之前在服务器端
  - 在将数据持久化到数据库之前
- 验证是一个跨领域的关注点/任务，因此作为良好的实践，我们应该尽量将它与我们的业务逻辑分开。JSR303 和 JSR349 通过使用注解为 bean 验证提供规范。
- 该框架提供了 JSR303 和 JSR349 规范的参考实现。

### 35.什么是HibernateTemplate类？

- 在 Hibernate 3.0.1 之前，Spring 提供了 2 个类，即：`HibernateDaoSupport`从 Hibernate 获取 Session 和`HibernateTemplate`用于 Spring 事务管理目的。
- 但是，从 Hibernate 3.0.1 开始，通过使用`HibernateTemplate`类我们可以使用`SessionFactory getCurrentSession()`方法来获取当前会话，然后使用它来获得事务管理的好处。
- `HibernateTemplate`具有异常翻译的好处，但可以通过使用带有服务类的@Repository 注释轻松实现。

## Spring MVC 面试题

### 36.什么是Spring MVC框架？

- Spring MVC 是请求驱动的框架，是 Spring 框架的核心组件之一。
- 它带有随时可用的松散耦合组件和元素，极大地帮助开发人员构建灵活和健壮的 Web 应用程序。
- MVC（模型 - 视图 - 控制器）架构分离并提供应用程序不同方面之间的松散耦合——输入逻辑（模型）、业务逻辑（控制器）和 UI 逻辑（视图）。

### 37. Spring MVC 框架相对于其他 MVC 框架有什么好处？

- 清晰的角色分离——每个角色都有一个专门的专用对象。
- 可重用的业务代码逻辑——使用 Spring MVC，无需复制代码。现有对象可以用作命令而不是复制它们以扩展特定的框架基类。
- Spring MVC 框架提供可定制的绑定和验证。
- 还提供可定制的语言环境和主题分辨率。
- Spring MVC 也支持可定制的处理程序映射和视图解析。

### 38. Spring MVC 中的 DispatcherServlet 是什么？换句话说，你能解释一下 Spring MVC 架构吗？

Spring MVC 框架是围绕一个称为 DispatcherServlet 的中央 servlet 构建的，它处理所有 HTTP 请求和响应。DispatcherServlet 做的远不止这些：

- 它与 IoC 容器无缝集成，允许您以更轻松的方式使用 Spring 的每个功能。
- DispatcherServlet 联系 HandlerMapping 以调用适当的 Controller 来处理接收到的请求。然后，控制器调用适当的服务方法来设置或处理模型数据。服务处理数据并将视图名称返回给 DispatcherServlet。DispatcherServlet 然后在 ViewResolver 的帮助下为请求获取定义的视图。一旦决定了视图，DispatcherServlet 将模型数据传递给视图，最终在浏览器上呈现。

![img](https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/844/original/DispatcherServlet_in_Spring_MVC.png?1628699617)

### 39.什么是View Resolver模式并解释它在Spring MVC中的意义？

- 它是一种 J2EE 模式，允许应用程序动态选择在浏览器（视图）上呈现数据的技术。
  - 任何技术，如 HTML、JSP、XSLT、JSF 或任何其他此类技术都可以用作 View。
- View Resolver 拥有不同视图的信息。Controller 返回 View 的名称，然后由 DispatcherServlet 传递给 View Resolver 以选择适当的 View 技术，然后显示数据。
- Spring MVC 中使用的默认 ViewResolver 是`InternalResourceViewResolver`.

### 40.@Controller注解是干什么用的？

- @Controller 是用于定义控制器的构造型 Spring MVC 注释。

### 41. 可以不使用@Controller 或@RestController 注解创建控制器吗？

- 是的！您可以通过使用注释对 Spring MVC 控制器类进行注释来创建没有 @Controller 或 @RestController 注释的控制器`@Component`。在这种情况下，请求映射到处理程序方法的真正工作是使用@RequestMapping 注解完成的。

### 42.什么是ContextLoaderListener，它有什么作用？

- ContextLoaderListener 加载并创建 ApplicationContext，因此开发人员无需编写显式代码来创建它。简而言之，它是一个有助于引导 Spring MVC 的侦听器。
  - 应用程序上下文是 Spring bean 所在的位置。对于 Web 应用程序，有一个称为 WebAppliationContext 的子类。
- ApplicationContext 的生命周期通过使用 ContextLoaderListener 与 ServletContext 的生命周期相关联。WebApplicationContext 中的 ServletContext 可以使用 getServletContext() 方法获得。

### 43.@RequestParam和@PathVariable注解有什么区别？

- 尽管这两个注释都用于从 URL 中提取一些数据，但它们之间存在关键区别。
  - @RequestParam 用于提取“？”之后的任何**查询参数** 在网址中。
  - @PathVariable 用于提取作为 URI 本身的一部分存在的数据。]
  - 例如，如果给定的 URL 是 http://localhost:8080/InterviewBit/Spring/SpringMVC/?format=json，那么您可以使用 @RequestParam 注释和 /Spring/{type} 访问查询参数“format” @PathVariable，它将为您提供 SpringMVC。

```plaintext
@RequestMapping("/Spring/{type}")
public void getQuestions(@PathVariable("type") String type, 
                        @RequestParam(value = "format", required = false) String format){
   /* Some code */
}
```

### 44. Spring MVC中的Model是什么？

- 模型是具有用于渲染的数据的参考。
- 它总是被创建并传递给 Spring MVC 中的视图。如果映射的控制器方法将模型作为参数，则该模型实例会自动注入该方法。
- 在注入模型上设置的任何属性都将被保留并传递给视图。

### 45.@Autowired注解有什么用？

`@Autowired`注释用于通过其类型以及方法和字段来注入 bean。这有助于 Spring 框架通过将 bean 注入和协作到另一个 bean 来解决依赖关系。例如，考虑下面的代码片段：

```plaintext
import org.Springframework.beans.factory.annotation.Autowired;
import java.util.*;
public class InterviewBit {
   // Autowiring/Injecting FormatterUtil as dependency to InterviewBit class
  @Autowired
  private FormatterUtil formatterUtil;
  
  public Date something( String value ){
     Date dateFormatted = formatterUtil.formatDate(value);
     return dateFormatted
   }
}
/**
* Util class to format any string value to valid date format
*/
public class FormatterUtil {
   
   public Date formatDate(String value){
       //code to format date
   }
}
```

### 46.@ModelAttribute注解的作用是什么？

注释在将方法参数绑定到与模型对应的相应属性中起着非常重要的作用。然后它在演示页面上反映相同。注释的作用还取决于开发人员使用它的目的。如果在方法级别使用它，则该方法负责为其添加属性。在参数级别使用时，它表示要从模型层检索参数值。

### 47. Spring MVC中web.xml的重要性是什么？

`web.xml`也称为部署描述符，它定义了 servlet 及其映射、过滤器和生命周期侦听器。它还用于配置 ContextLoaderListener。每当部署应用程序时，Servlet 容器都会创建一个 ContextLoaderListener 实例，这会导致 WebApplicationContext 的加载。

### 48. Spring MVC 依赖注入有哪些类型？

DI（依赖注入）有两种类型：

- 基于构建：
  - 这种类型的 DI 在 Spring IoC（控制反转）容器调用依赖于其他类的参数化构造函数时完成。
  - 这不能部分实例化值并确保完全完成依赖注入。
  - 有两种可能的方法来实现这一点：

**注解配置：**这种方法使用 POJO 对象和注解进行配置。例如，考虑下面的代码片段：

```plaintext
@Configuration
@ComponentScan("com.interviewbit.constructordi")
public class SpringAppConfig {
   @Bean
   public Shape shapes() {
       return new Shapes("Rectangle");
   }
   @Bean
   public Dimension dimensions() {
       return new Dimension(4,3);
   }
}
```

这里，注解用于通知Spring运行时`@Bean`注解指定的类是bean的提供者，需要`com.interviewbit.constructordi`通过`@ComponentScan`注解对包进行上下文扫描的过程。接下来，我们将定义一个 Figure 类组件，如下所示：

```plaintext
@Component
public class Figure {
   private Shape shape;
   private Dimension dimension;
   
   @Autowired
   public Figure(Shape shape, Dimension dimension) {
       this.shape = shape;
       this.dimension = dimension;
   }
}
```

Spring 在执行上下文扫描时遇到了这个 Figure 类，它通过调用带有注释的构造函数来初始化这个类的实例`@Autowired`。Shape 和 Dimension 实例是通过调用类中带有注释的方法获得`@Bean`的`SpringAppConfig`。Engine和Transmission的实例将通过调用Config类的@Bean注解方法获得。最后，我们需要使用我们的 POJO 配置来引导 ApplicationContext：

```plaintext
ApplicationContext context = new AnnotationConfigApplicationContext(SpringAppConfig.class);
Figure figure = context.getBean(Figure.class);
```

**XML 配置**：这是使用 XML 配置文件配置 Spring 运行时的另一种方式。例如，考虑 springAppConfig.xml 文件中的以下代码片段：

```plaintext
<bean id="toyota" class="com.interviewbit.constructordi.Figure">
   <constructor-arg index="0" ref="shape"/>
   <constructor-arg index="1" ref="dimension"/>
</bean>
<bean id="shape" class="com.interviewbit.constructordi.Shape">
   <constructor-arg index="0" value="Rectangle"/>
</bean>
<bean id="dimension" class="com.interviewbit.constructordi.Dimension">
   <constructor-arg index="0" value="4"/>
   <constructor-arg index="1" value="3"/>
</bean>
```

`constructor-arg`标签可以接受文字值或另一个 bean 的引用以及显式索引和类型。索引和类型参数用于解决歧义情况下的冲突。
在引导这个类时，`ApplicationContext`需要使用`ClassPathXmlApplicationContext`如下所示的 Spring：

```plaintext
ApplicationContext context = new ClassPathXmlApplicationContext("springAppConfig.xml");
Figure figure = context.getBean(Figure.class);
```

- 基于二传手：
  - 这种形式的 DI 是在 Spring IoC 容器在调用非参数化构造函数执行 bean 实例化之后调用 bean 的 setter 方法时实现的。
  - 使用setter注入可以实现循环依赖。
  - `<property>`为了实现这种类型的DI，我们需要通过标签下的配置文件进行配置。例如，考虑一个`InterviewBit`设置属性的类，`articles`如下所示：

```plaintext
package com.interviewbit.model;
import com.interviewbit.model.Article;
public class InterviewBit {
   // Object of the Article interface
   Article article;
   public void setArticle(Article article)
   {
       this.article = article;
   }
}
```

在 bean 配置文件中，我们将进行如下设置： 

```plaintext
<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">
   <bean id="InterviewBit" class="com.interviewbit.model.InterviewBit">
       <property name="article">
           <ref bean="JsonArticle" />
       </property>
   </bean>
   <bean id="JsonArticle" class="com.interviewbit.bean.JsonArticle" />
</beans>
```

'JsonArticle' bean 通过该`setArticle`方法注入到 InterviewBit 类对象中。
在使用这两种依赖关系的情况下，通过考虑特异性性质，setter 依赖注入具有更多的偏好。

### 49. 会话范围的重要性是什么？

会话范围用于为 HTTP 会话创建 bean 实例。这意味着单个 bean 可用于服务多个 HTTP 请求。可以通过使用范围属性或使用@Scope 或@SessionScope 注释来定义bean 的范围。

- 使用范围属性：

```plaintext
<bean id="userBean" class="com.interviewbit.UserBean" scope="session"/>
```

- 使用@Scope 注解：

```plaintext
@Component
@Scope("session")
public class UserBean {
   //some methods and properties
}
```

- 使用@SessionScope：

```plaintext
@Component
@SessionScope
public class UserBean {
   //some methods and properties
}
```

### 50.@Required注解的重要性是什么？

注解用于指示 bean 的属性应通过自动装配或配置时 bean 定义期间的任何显式值来填充。例如，考虑下面的代码片段，我们需要具有年龄和姓名的值：

```plaintext
import org.Springframework.beans.factory.annotation.Required;
public class User {
   private int age;
   private String name;
   
   @Required
   public void setAge(int age) {
       this.age = age;
   }
   public Integer getAge() {
       return this.age;
   }
   
   @Required
   public void setName(String name) {
       this.name = name;
   }
   public String getName() {
       return this.name;
   }
}
```

### 51. 区分@Autowired 和@Inject 注释。

| @自动连线                                                    | @注入                                                        |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| 这个注解是 Spring 框架的一部分。                             | 此注释是 Java CDI 的一部分。                                 |
| 具有必需的属性。                                             | 没有必需的属性。                                             |
| 单例是自动装配 bean 的默认范围。                             | 原型是注入 bean 的默认范围。                                 |
| 如果有歧义，则将使用 @Qualifier 注释。                       | 如果有歧义，则需要使用 @Named 限定符。                       |
| 由于这个注解是由 Spring 框架提供的，如果你转移到另一个 Dependency injection 框架，将需要进行大量的重构。 | 由于此注解是 Java CDI 的一部分，因此它不依赖于框架，因此在框架发生更改时代码重构较少。 |

### 52. 单例 bean 是线程安全的吗？

不，单例 bean 不是线程安全的，因为线程安全的概念本质上是处理程序的执行，而单例只是一种用于创建对象的设计模式。bean 的线程安全性质取决于其实现的性质。

### 53. 如何在 bean 中实现线程安全？

线程安全可以通过将 bean 的范围更改为请求、会话或原型来实现，但要以性能为代价。这纯粹是基于项目要求。

### 54.@Repository注解有什么意义？

@Repository 注解表示组件用作存储库，充当存储、搜索或检索数据的手段。这些可以添加到 DAO 类中。

### 55、dispatcher servlet是如何实例化的？

Dispatcher servlet 通过 servlet 容器（例如 Tomcat）进行实例化。Dispatcher Servlet 应该在 web.xml 中定义 DispatcherServlet 由 Tomcat 等 Servlet 容器实例化。Dispatcher Servlet 可以在 web.xml 中定义，如下所示：

```plaintext
<?xml version="1.0" encoding="UTF-8"?>
<web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd">

 <!-- Define Dispatcher Servlet -->
 <servlet>
   <servlet-name>appServlet</servlet-name>
   <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
   <init-param>
     <param-name>contextConfigLocation</param-name>
     <param-value>/WEB-INF/spring/appServlet/servlet-context.xml</param-value>
   </init-param>
   <load-on-startup>1</load-on-startup>
 </servlet>

 <servlet-mapping>
   <servlet-name>InterviewBitServlet</servlet-name>
   <url-pattern>/</url-pattern>
 </servlet-mapping>

</web-app>
```

这里，load-on-startup 标记为 1，这表明只要 Spring MVC 应用程序到 servlet 容器，就会实例化 DispatcherServlet。在此过程中，它会查找 servlet-name-context.xml 文件并初始化文件中定义的 bean。

### 56. Spring MVC中的根应用上下文是如何加载的？

使用属于整个应用程序的 ContextLoaderListener 加载根应用程序上下文。Spring MVC 允许实例化多个 DispatcherServlet，每个 DispatcherServlet 都有多个特定于它们的上下文。它们也可以具有相同的根上下文。

### 57. Spring MVC 流程是怎样的？换句话说，当 Spring MVC 有传入请求时，DispatcherServlet 如何知道需要调用哪个 Controller？

Dispatcher Servlet 通过处理程序映射知道要调用哪个控制器。这些映射具有控制器和请求之间的映射。`BeanNameUrlHandlerMapping`并且`SimpleUrlHandlerMapping`是两个最常用的处理程序映射。

- BeanNameUrlHandlerMapping：当URL请求与bean名称匹配时，bean定义对应的类就是负责处理请求的实际控制器。
- SimpleUrlHandlerMapping：这里的映射非常明确。可以在此处指定 URL 的数量，并且每个 URL 都与控制器显式关联。

如果 Spring MVC 是使用注解配置的，则 @RequestMapping 注解用于此目的。@RequestMapping 注解是通过使用 URI 路径、HTTP 方法、查询参数和 HTTP 标头来配置的。

### 58、视图对模型的访问从哪里来？

视图需要访问模型以呈现输出，因为模型包含用于呈现的所需数据。模型与处理客户端请求并最终将响应封装到模型对象中的控制器相关联。

### 59. 为什么我们需要 BindingResults？

BindingResults 是`org.Springframework.validation`包中一个重要的 Spring 接口。该接口的调用过程非常简单易行，在检测提交表单中的错误方面起着至关重要的作用。但是，开发人员必须注意在需要验证的对象之后使用 BindingResult 参数。例如：

```plaintext
@PostMapping("/interviewbit")
public String registerCourse(@Valid RegisterUser registerUser,
 BindingResult bindingResult, Model model) {
   if (bindingResult.hasErrors()) {
       return "home";
   }
   model.addAttribute("message", "Valid inputs");
   return "home";
}
```

Spring会通过检查参数上的@Valid注解来了解找到对应的验证器。

### 60.什么是Spring拦截器？

Spring 拦截器用于对 Spring MVC 中由 Spring Controller 处理的 Web 请求进行预处理和后处理。这可以通过`HandlerInterceptor`接口来实现。这些处理程序用于操作传递给控制器或视图的模型属性。
可以为特定的 URL 映射注册 Spring 处理程序拦截器，以便它只能拦截那些请求。自定义处理程序拦截器必须实现`HandlerInterceptor`具有 3 个可以实现的回调方法的接口：

- 预句柄（）
- 后处理（）
- 完成后（）

这个接口的唯一问题是这个接口的所有方法都需要实现，而不管它的要求。`HandlerInterceptorAdapter`如果我们的处理程序类扩展了内部实现`HandlerInterceptor`接口并提供默认空白实现的类，则可以避免这种情况。

### 61. 是否需要在类路径中保留spring-mvc.jar 或者它已经作为spring-core 的一部分存在？

`spring-mv.jar`不属于弹簧芯。这意味着如果我们必须在项目中使用 Spring MVC 框架，则该 jar 必须包含在项目的类路径中。对于 Java 应用程序，`spring-mvc.jar`位于`/WEB-INF/lib`文件夹内。

### 62. <context:annotation-config> 和 <context:component-scan> 标签有什么区别？

`<context:annotation-config>`用于在应用程序上下文中激活预先注册的 bean 中的应用注释。它还注册配置文件中定义的 bean，并扫描 bean 中的注释并激活它们。

该`<context:component-scan>`标记执行`<context:annotation-config>`扫描包和在应用程序上下文中注册 bean 的任务。

> `<context:annotation-config>`= 扫描并激活预注册 bean 中的注释。
> `<context:component-scan> `=注册Bean +扫描并激活包中的注释。

### 63. Spring Web MVC Framework中表单数据校验是如何进行的？

Spring MVC 使用实现了 Validator 接口的验证器对象来完成数据验证的任务。在我们创建的自定义验证器类中，我们可以使用 ValidationUtils 类的实用方法`rejectIfEmptyOrWhitespace()`或`rejectIfEmpty()`执行表单字段的验证。

```plaintext
@Component
public class UserValidator implements Validator
{
   public boolean supports(Class clazz) {
       return UserVO.class.isAssignableFrom(clazz);
   }
 
   public void validate(Object target, Errors errors)
   {
       ValidationUtils.rejectIfEmptyOrWhitespace(errors, "name", "error.name", "Name is required.");
       ValidationUtils.rejectIfEmptyOrWhitespace(errors, "age", "error.age", "Age is required.");
       ValidationUtils.rejectIfEmptyOrWhitespace(errors, "phone", "error.phone", "Phone is required.");
   }
}
```

在需要验证的字段中，如果出现错误，验证器方法将创建字段错误并将其绑定到该字段。

要将自定义验证器激活为 spring bean，然后：

- 我们必须在自定义验证器类上添加 @Component 注释，并通过添加以下更改来启动包含验证器声明的包的组件扫描：

```plaintext
<context:component-scan base-package="com.interviewbit.validators"/>
```

要么

验证器类可以直接在上下文文件中注册为 bean，如下所示：

```plaintext
<bean id="userValidator" class="com.interviewbit.validators.UserValidator" />
```

### 64. spring bean中如何获取ServletConfig和ServletContext对象？

这可以通过实现 spring-aware 接口或使用 @Autowired 注释来完成。

```plaintext
@Autowired
private ServletContext servletContext;
@Autowired
private ServletConfig servletConfig;
```

### 65. 区分 Bean 工厂和应用程序上下文。

BeanFactory 和 ApplicationContext 都是 Java 接口。不同之处在于 ApplicationContext 扩展了 BeanFactory。BeanFactory 提供 IoC 和 DI 基本功能，而 ApplicationContext 提供更高级的功能。以下是这两者之间的区别：

| 类别          | 豆厂                                                         | 应用程序上下文                                               |
| :------------ | :----------------------------------------------------------- | :----------------------------------------------------------- |
| 国际化 (i18n) | 不提供对 i18n 的支持。                                       | 提供对 i18n 的支持。                                         |
| 活动发布      | 通过使用 ContextStartedEvent 和 ContextStoppedEvent 分别在启动和停止时发布上下文，提供向侦听器 bean 发布事件的能力。 | ApplicationContext 通过 ApplicationListener 接口和 ApplicationEvent 类支持事件处理。 |
| 实现          | XMLBeanFactory 是 BeanFactory 的流行实现。                   | ClassPathXmlApplicationContext 是 ApplicationContext 的流行实现。此外，Java 使用 WebApplicationContext 扩展接口并添加 getServletContext() 方法。 |
| 自动装配      | 对于自动装配，bean 必须在 AutoWiredBeanPostProcessor API 中注册。 | 在这里，可以做XML配置来实现自动装配。                        |

### 66. Spring MVC 中如何支持 i18n 和本地化？

Spring MVC`LocaleResolver`支持 i18n 和本地化。支持国际化和本地化。需要在应用程序中配置以下 bean：

- **SessionLocaleResolver：**此 bean 在从用户会话中的预定义属性中获取和解析语言环境方面起着至关重要的作用。

句法：

```plaintext
<bean id="localeResolver"class="org.Springframework.web.servlet.i18n.SessionLocaleResolver">
   <property name="defaultLocale" value="en" />
</bean>
```

- **LocaleChangeInterceptor：**这个 bean 对于解析传入请求的参数很有用。

句法：

```plaintext
<bean id="localeChangeInterceptor"class="org.Springframework.web.servlet.i18n.LocaleChangeInterceptor">
   <property name="paramName" value="lang" />
</bean>
```

- **DefaultAnnotationHandlerMapping：**这是指 HandlerMapping 接口实现，它根据在类型或方法级别的 @RequestMapping 中指定的 HTTP 路径映射处理程序/拦截器。

句法：

```plaintext
<bean class="org.Springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping">
   <property name="interceptors">
       <list>
           <ref bean="localeChangeInterceptor" />
       </list>
   </property>
</bean>
```

### 67、你对MultipartResolver的理解是什么？

MultipartResolver 用于处理 Spring Web 应用程序中的文件上传场景。在 Spring 中有 2 个具体的实现，它们是：

- CommonsMultipartResolver 适用于 Jakarta Commons FileUpload
- StandardServletMultipartResolver 用于 Servlet 3.0 Part API

为了实现这一点，我们需要在 DispatcherServlet 的应用程序上下文中创建一个 id="multipartResolver" 的 bean。这样做可确保 DispatcherServlet 处理的所有请求在检测到多部分请求时都应用此解析器。如果 DispatcherServlet 检测到多部分请求，它会通过已配置的 MultipartResolver 解析请求，并将请求作为包装/抽象的 HttpServletRequest 传递。然后控制器将此请求转换为`MultipartHttpServletRequest`接口以访问 Multipart 文件。下图清楚地说明了流程：

![img](https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/845/original/MultipartResolver.jpg?1628748693)

### 68. 如何在 Spring 应用程序中使用 Tomcat JNDI DataSource？

要使用在 JNDI（Java 命名和目录接口）DataSource 中配置的 servlet 容器，必须在 spring bean 配置文件中配置 DataSource bean，然后将其作为依赖项注入到 bean 中。发布此消息后，DataSource bean 可用于通过 JdbcTemplate 执行数据库操作。注册 MySQL DataSource bean 的语法：

```plaintext
<bean id="dataSource" class="org.springframework.jndi.JndiObjectFactoryBean">
   <property name="jndiName" value="java:comp/env/jdbc/MySQLDB"/>
</bean>
```

### 69. 如果用户先选中复选框，其他字段出现验证错误，然后在收到错误后取消选中复选框，那么复选框输入的选择状态是什么？

验证通常在 HTTP POST 请求期间执行。在 HTTP 请求期间，如果复选框的状态未选中，则 HTTP 包含复选框的请求参数，因此不会获取更新的选择。这可以通过使用以`_`Spring MVC 开头的隐藏表单字段来解决。

### 结论：

在这篇文章中，我们看到了面试中最常被问到的春季面试问题。Spring 是一个非常强大的框架，允许构建企业级 Web 应用程序。使用 Spring 开发的应用程序通常快速、可扩展且透明。因此，Spring 已被庞大的 Java 开发人员社区所接受，从而使其成为任何 Java 开发人员工作角色中不可避免的一部分。了解 Spring 可确保开发人员在他们的职业生涯中也能稳步进步。

提示：我们还建议阅读[此处](https://spring.io/guides)发布的指南。

## 春季多选题

1.

需要注册以下哪些选项才能在启动时加载应用程序的根上下文？

上下文加载器监听器

ContextLoaderStarter

根上下文监听器

RootContextTrigger

2.

Spring中关闭IoC容器的方法是什么？

registerHook(关机)

关机钩子（真）

registerShutdownHook()

shutdownHandlerHook()

3.

Spring中的autowire有哪些类型？选择正确的选项。

byName、byType、析构函数和自动检测

byMethod、byName、自动更正和自动检测

byName、byType、byValue 和自动检测

byName、byType、构造函数和自动检测

4.

哪种方法允许在 Spring 中启动新事务？

开始会话（）

获取交易（）

开始新事务（）

获取会话（）

5.

什么属性用于处理 Web 请求流？

servlet 映射

小服务程序属性

小服务程序流

servlet 流请求

6.

联合点执行完成后会运行什么建议？

@AfterFinish

@AfterJoint

@AfterPoint

@后

7.

以下代码的输出是什么？

```plaintext
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.AfterThrowing;
@Aspect
public class SampleAspectClass {
   
   @AfterThrowing(pointcut="com.interviewbit.Operations.someOperation()", throwing="ex")
   public void doRecoveryActions(DataAccessException e){
       throw new IllegalArgumentException();
   }
}
```

IllegalArgumentException

BeanCreationException

运行时错误

空指针异常

8.

哪种方法会从 List 到 List 未经检查的转换导致编译器发出警告？

createNativeQuery()

找到所有（）

全部更新（）

批处理插入（）

9.

什么注释用于查找事务并通过抱怨没有 Hibernate 会话绑定到线程而失败？

@TransactionFail

@TransactionHandler

@TransactionResolver

@Transactional

10.

工厂 bean 使用什么属性来加载休眠配置文件？

配置位置

配置

配置文件

hbm-配置

11.

下列关于 Spring 的说法正确的是？

Spring 允许开发人员开发企业级 Web 应用程序。

Spring 允许开发人员以模块化的方式进行编码。

Spring 确保应用程序测试变得简单。

上述所有的

12.

byName 类型的自动装配有什么作用？

byName 模式意味着没有自动装配，需要添加显式引用。

byName 模式确保自动装配是通过属性名称完成的。Spring 将属性与配置文件中定义的同名 bean 匹配并连接。

在这种模式下，Spring 首先由构造函数自动装配，如果没有找到，它会尝试按类型自动装配。

此模式类似于 byType 模式，但仅限于非参数化构造函数。

13.

以下哪个类用于将数据库行映射到 Spring 中的 java 对象？

行映射器

结果集

行集映射器

结果集映射器

14.

什么类用于提供 DispatcherServlet 的类行为？

存储库

抽象动作

抽象控制器

控制器

15.

下面哪个是 Spring 中的 Handler 方法注解？

@RequestMapping

@控制器

@服务

@解决

16.

使用 @RequestMapping 的处理程序方法中使用了哪些方法参数？

@控制器

@豆角，扁豆

@RequestParam

@服务

17.

ViewResolvers 中的哪一个将视图名称解析为应用程序的目录？

内部解析器

内部视图解析器

内部请求解析器

内部资源视图解析器

18.

以下哪个注释表示字段不能为空？

@不是空的

@NotNull

@NeverNull

上述所有的

19.

什么注解以正则表达式的形式接收值？

@图案

@密码

@电子邮件

@有效的

20.

什么是用来通知会话处理完成的？

绑定结果

Http状态

会话状态

会议

**使用 Scaler 进入顶级产品公司**了解更多



![点标记 b3add1cc88e4996b2df6e0aedb9f0d1b65fa73c51b7ada8fbee3895a2aa11802.svg](https://assets.interviewbit.com/assets/ibpp/point-markers-b3add1cc88e4996b2df6e0aedb9f0d1b65fa73c51b7ada8fbee3895a2aa11802.svg.gz)

![点标记 b3add1cc88e4996b2df6e0aedb9f0d1b65fa73c51b7ada8fbee3895a2aa11802.svg](https://assets.interviewbit.com/assets/ibpp/point-markers-b3add1cc88e4996b2df6e0aedb9f0d1b65fa73c51b7ada8fbee3895a2aa11802.svg.gz)

![点标记 b3add1cc88e4996b2df6e0aedb9f0d1b65fa73c51b7ada8fbee3895a2aa11802.svg](https://assets.interviewbit.com/assets/ibpp/point-markers-b3add1cc88e4996b2df6e0aedb9f0d1b65fa73c51b7ada8fbee3895a2aa11802.svg.gz)

![点标记 b3add1cc88e4996b2df6e0aedb9f0d1b65fa73c51b7ada8fbee3895a2aa11802.svg](https://assets.interviewbit.com/assets/ibpp/point-markers-b3add1cc88e4996b2df6e0aedb9f0d1b65fa73c51b7ada8fbee3895a2aa11802.svg.gz)



[![定标器徽标 27a9b9093de1d977bad45ed9dff8addbd1bb0f14bb4f34399bdcf7a2b71a4e2a.svg](https://assets.interviewbit.com/assets/scaler/svg/scaler-logo-27a9b9093de1d977bad45ed9dff8addbd1bb0f14bb4f34399bdcf7a2b71a4e2a.svg.gz)](https://www.scaler.com/academy?utm_source=ib&utm_campaign=ib_menu&utm_medium=nav_menu)

[![img](https://assets.interviewbit.com/assets/ibpp/brand-inv-a62b6669d8645925b8094c7322d36b2039344b7af7a6a252a64acd867556b610.svg.gz)](https://www.interviewbit.com/)

- [博客](https://www.interviewbit.com/blog/)
- 

- [社区](https://www.interviewbit.com/discussion/)
- 

- [关于我们](https://www.interviewbit.com/pages/about_us/)
- 

- [常问问题](https://www.interviewbit.com/pages/faq/)
- 

- [联系我们](https://www.interviewbit.com/pages/contact_us/)
- 

- [条款](https://www.interviewbit.com/pages/terms/)
- 

- [隐私政策](https://www.interviewbit.com/pages/privacy/)
- 



- 

- 
- 
- 

- - [**练习题**](https://www.interviewbit.com/practice/)
  - [编程](https://www.interviewbit.com/courses/programming/)
  - [脚本](https://www.interviewbit.com/courses/shell/)
  - [系统设计](https://www.interviewbit.com/courses/system-design/)
  - [数据库](https://www.interviewbit.com/courses/databases/)
  - [谜](https://www.interviewbit.com/puzzles/)
- - [**快速通道课程**](https://www.interviewbit.com/courses/fast-track/)
  - [Python](https://www.interviewbit.com/courses/fast-track-python/)
  - [爪哇](https://www.interviewbit.com/courses/fast-track-java/)
  - [C++](https://www.interviewbit.com/courses/fast-track-cpp/)
  - [Javascript](https://www.interviewbit.com/courses/fast-track-js/)

- **在线面试位编译器**

- [在线 C 编译器](https://www.interviewbit.com/online-c-compiler/)
- [在线 C++ 编译器](https://www.interviewbit.com/online-cpp-compiler/)
- [在线 Java 编译器](https://www.interviewbit.com/online-java-compiler/)
- [在线 Javascript 编译器](https://www.interviewbit.com/online-javascript-compiler/)
- [在线 Python 编译器](https://www.interviewbit.com/online-python-compiler/)



- **面试准备**

- [系统设计问题](https://www.interviewbit.com/courses/system-design/)
- [谷歌面试问题](https://www.interviewbit.com/google-interview-questions/)
- [Facebook 面试问题](https://www.interviewbit.com/facebook-interview-questions/)
- [亚马逊面试问题](https://www.interviewbit.com/amazon-interview-questions/)
- [微软面试问题](https://www.interviewbit.com/microsoft-interview-questions/)
- [Javascript 面试问题](https://www.interviewbit.com/javascript-interview-questions/)
- [jQuery 面试问题](https://www.interviewbit.com/jquery-interview-questions/)
- [角度面试问题](https://www.interviewbit.com/angular-interview-questions/)
- [数据结构面试题](https://www.interviewbit.com/data-structure-interview-questions/)
- [Directi面试问题](https://www.interviewbit.com/directi-interview-questions/)
- [雅虎面试问题](https://www.interviewbit.com/yahoo-interview-questions/)
- [领英面试问题](https://www.interviewbit.com/linkedin-interview-questions/)
- [易趣面试问题](https://www.interviewbit.com/ebay-interview-questions/)
- [Flipkart 面试问题](https://www.interviewbit.com/flipkart-interview-questions/)
- [甲骨文面试问题](https://www.interviewbit.com/oracle-interview-questions/)
- [Adobe 面试问题](https://www.interviewbit.com/adobe-interview-questions/)
- [C 面试问题](https://www.interviewbit.com/c-interview-questions/)
- [PHP面试问题](https://www.interviewbit.com/php-interview-questions/)
- [C Sharp 面试问题](https://www.interviewbit.com/c-sharp-interview-questions/)
- [Web API 面试题](https://www.interviewbit.com/web-api-interview-questions/)
- [Hibernate 面试题](https://www.interviewbit.com/hibernate-interview-questions/)
- [Node Js 面试题](https://www.interviewbit.com/node-js-interview-questions/)
- [Cpp面试问题](https://www.interviewbit.com/cpp-interview-questions/)
- [哎呀面试问题](https://www.interviewbit.com/oops-interview-questions/)
- [Devops 面试问题](https://www.interviewbit.com/devops-interview-questions/)
- [机器学习面试题](https://www.interviewbit.com/machine-learning-interview-questions/)
- [Docker 面试问题](https://www.interviewbit.com/docker-interview-questions/)
- [Mysql面试题](https://www.interviewbit.com/mysql-interview-questions/)
- [Css 面试题](https://www.interviewbit.com/css-interview-questions/)
- [Laravel 面试问题](https://www.interviewbit.com/laravel-interview-questions/)
- [Asp Net 面试题](https://www.interviewbit.com/asp-net-interview-questions/)
- [Django 面试问题](https://www.interviewbit.com/django-interview-questions/)
- [点网面试题](https://www.interviewbit.com/dot-net-interview-questions/)
- [Kubernetes 面试问题](https://www.interviewbit.com/kubernetes-interview-questions/)
- [操作系统面试题](https://www.interviewbit.com/operating-system-interview-questions/)
- [React Native 面试问题](https://www.interviewbit.com/react-native-interview-questions/)
- [Aws 面试问题](https://www.interviewbit.com/aws-interview-questions/)
- [Git 面试问题](https://www.interviewbit.com/git-interview-questions/)
- [Java 8 面试题](https://www.interviewbit.com/java-8-interview-questions/)
- [Mongodb 面试题](https://www.interviewbit.com/mongodb-interview-questions/)
- [DBMS 面试题](https://www.interviewbit.com/dbms-interview-questions/)
- [Spring Boot 面试题](https://www.interviewbit.com/spring-boot-interview-questions/)
- [Power Bi 面试题](https://www.interviewbit.com/power-bi-interview-questions/)
- [Pl Sql 面试问题](https://www.interviewbit.com/pl-sql-interview-questions/)
- [Tableau 面试问题](https://www.interviewbit.com/tableau-interview-questions/)
- [Linux 面试问题](https://www.interviewbit.com/linux-interview-questions/)
- [Ansible 面试问题](https://www.interviewbit.com/ansible-interview-questions/)
- [Java 面试问题](https://www.interviewbit.com/java-interview-questions/)
- [詹金斯面试问题](https://www.interviewbit.com/jenkins-interview-questions/)
- [敏捷面试问题](https://www.interviewbit.com/agile-interview-questions/)
