# 类加载

## calssloader

​		**虚拟机把描述类的数据从class字节码文件加载到内存，并对数据进行检验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。**

### 加载过程

家宴准备了西式菜

1. **加载** 把class字节码从各个来源通过加载器装进内存
2. **验证** 保证加载进来的字节流合乎虚拟机规范，不会造成安全错误
3. **准备** 为类变量分配内存，并且赋予初值
4. **解析**  将常量池中的符号引用替换成直接饮用
5. **初始化** 对类变量进行初始化，是执行构造器的基础

### 双亲委派

多个类加载器之间存在父子关系的时候，某个class类具体由哪个加载器进行加载的问题。

* 当一个类加载的时候，它不会首先去加载，而是委托给自己的父类去加载，
* 父类又委托给自己的父类。
* 所有的类加载都会委托给顶层的父类 Bootstrap Classloader
* 父类无法完成时子类加载器才会自己完成

**作用**：

1. 避免类的重复加载
2. 避免核心类被不不同的类加载到内存中造成冲突和混乱，从而保护了java核心库的安全

| 加载器                    | 范围                                                       |      |
| ------------------------- | ---------------------------------------------------------- | ---- |
| 启动类加载器Boostrap      | <Java_Home>/lib,r如java.io\|java.util\|java.lang           |      |
| 扩展类加载器Extention     | 以javax开头，<Java_Home>/lib/ext目录下                     |      |
| 应用程序加载器Application | 用户路径classpath上指定的类库，自己编写的类以及第三方jar包 |      |
| 自定义加载器Custom        | 为了某些特殊目的实现的自定义加载器                         |      |

### 应该场景

**依赖冲突**：

![image-20220822095304982](H:\gitfile\modiman.github.io\docs\_posts\imgs\image-20220822095304982.png)



├─业务
│  ├─fastjson1
│  ├─中间件
│  │  └─fastjson2
│  └─微服务
│      └─fastjson2

在这种业务逻辑中，业务层有自己的依赖fastjson1.0，中间件和微服务又有各自版本的fastjson2,3

根据maven依赖处理机制，只会加载fastjson1

**解决方案**：通过自定义类加载器，为每个中间件自定义一个加载器，这些加载器之间的关系是平行的，彼此没有依赖关系。

这样每个中间件的classloader就可以加载各自版本 的fastjson。因为一个类的全限定名以及加载该类的加载器两者共同形成了这个类在JVM中的惟一标识，这也 是阿里pandora实现依赖隔离的基础。
