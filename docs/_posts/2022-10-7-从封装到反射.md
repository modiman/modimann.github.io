## 引言

### 变量

假设写一段打印向量维度的代码，多次打印某个值

```java
print(100);
//业务逻辑
print(100);
//业务逻辑
print(100);
```

这里需要修改打印值的时候，需要修改三处，为了避免这种重复工作，可以用一个变量a表示常量

```java
a = 100
print(a);
//业务逻辑
print(a);
//业务逻辑
print(a);
```

这样以后想要打印不同的值，只要修改`a = 100 `这一处就行了，这时第一级封装

### 方法

考虑上面这处代码段，如果每次需要这个业务逻辑都把这个代码段复制粘贴过去，就会出现很多冗余代码，极不美观，解决办法依然是封装，把这段代码写进一个方法，哪里用到只要调用这个方法即可，这时第二级封装

```java
public void printNum(int a){
    a = 100
    print(a);
    //业务逻辑
    print(a);
    //业务逻辑
    print(a);
}
```

如此一来，以后需要这个逻辑处理，只需简单的调用`printNum(100)`即可，原始的代码段只在方法中出现了一次而不是哪里用到写哪里，提高了代码复用率。

### 类

有时候需要被服用的代码段不仅仅是几个变量或是某个方法，而是若干变量和方法的组合，如何将它们组织成一种方便使用的数据结构？答案是类，一种由`成员变量`,`方法`和`构造器`组成的数据结构。

```java
class PrintNum{
    int a;
	public PrintNum(){}
    public PrintNum(int a){this.a = a;}
    public void printNum(int b){
        b = 100
        print(b);
        //业务逻辑
        print(b);
        //业务逻辑
        print(b);
    }
}
```

通过这样的定义，我们只需要实例化一个`PrintNum`类型的对象```PrintNum p = new PrintNum();```就可以同时使用p的成员变量和方法，进一步提高了封装等级和代码复用率。

## 反射

​         上面的封装都考虑到了一件事：某些变量的值可能需要在实际被调用的时候才知道，所以不能在业务逻辑中写死，而是留一个形参以供调用者自己定义。现在考虑这样一种情况：项目里有很多类可以使用，在程序运行之前不知道要实例化谁（也就是程序员编代码的时候并不知道用户用哪些不用哪些，那就没办法提前实例化了），或者说要在运行时根据用户的输入决定实例化哪个类。说起来有点抽象，举个吃苹果的例子，程序需要根据用户的选择来决定实例化一个苹果还是别的以供食用：

```java
public class Eat{
    public Eat(){}
    public void eat(){
		print("请输入您要吃的食物");
        Scanner sc = new Scanner(System.in);
        String food = sc.next();
        if(food.equals("apple")){
            Apple apple = new Apple();
            apple.eat();
        }
        else{
			SomethingElse se= new SomethingElse(); 
            es.eat();
        }
    }
}
```

​      上面这段代码由于事先不知道要实例化谁，使用判断语句来处理这个逻辑，缺点很明显，有多少个选项就要有多少个逻辑判断，代码主键臃肿。现在思考有没有一种方法能够在运行时更加优雅的实例化一个类，就像封装方法那样留出一个形参来决定实例化哪个类。

答案是有：反射。

首先依然考虑封装，有没有一种方法将所有的类都组织起来以供使用。就像类是一个把成员变量、构造器和方法组织起来的数据结构一样，有没有一种数据结构能把所有的类组织起来？答案是**Class类**，具体地说，每一个**Class类**的实例都对应一个类。

**知识点**

* 项目中有多少类就有多少个对应的Class实例
* 想要实例化哪个类只需要获取对应的Class对象即可

![image-20221007164218924](H:\gitfile\modiman.github.io\docs\_posts\imgs\image-20221007164218924.png)

![image-20221007164218924](https://github.com/modiman/modiman.github.io/blob/gh-pages/docs/_posts/imgs/image-20221007164218924.png?raw=true)



那么在运行时，只要获取到了用户的需求，就可以定制实例化对象。

### Class类

### 获取Class实例

获取class实例常用三种方法

1. `类名.class`：这种获取方式只有在编译前已经声明了该类的类型才能获取到 Class 对象

```java
Class clazz = Students.class;
```

2. `实例.getClass()`：通过实例化对象获取该实例的 Class 对象

```java
Students sp = new Students();
Class clazz = sp.getClass();
```

3. `Class.forName(className)`：通过类的**全限定名**获取该类的 Class 对象

```java
Class clazz = Class.forName("com.bean.Students");
```

### **构造类的实例化对象**

通过反射构造一个类的实例方式有`2`种：

1. Class 对象调用`newInstance()`方法

```java
Class clazz = Class.forName("com.bean.Students");
Students stu = (Students) clazz.newInstance();
stu.getInfo();
// [null 的年龄是：0]
复制代码
```

即使 Students 已经显式定义了构造方法，通过 newInstance() 创建的实例中，所有属性值都是对应类型的初始值，因为 newInstance() 构造实例会调用默认无参构造器。

2. Constructor 构造器调用`newInstance()`方法

```java
Class clazz = Class.forName("com.bean.Students");
Constructor constructor = clazz.getConstructor(String.class, int.class);
constructor.setAccessible(true);
Students stu = (SmallPineapple) constructor.newInstance("苏世", 25);
stu.getInfo();
// [苏世 的年龄是：25]
```

通过Class对象调用 newInstance() 会走默认无参构造方法，如果想通过显式构造方法构造实例，需要提前从Class中调用getConstructor()方法获取对应的构造器，通过构造器去实例化对象。



## 应用场景

### Spring IOC

Spring IOC的一种重要实现方式-依赖注入（DI）就需要使用反射的方式

首先Spring项目由一堆Bean组成，Bean本质上就是包括Controller、Model、Service等等在内的所有类

因为由用户管理这些Bean的实例化会使项目变得臃肿，所以Spring将对Bean的控制权交给了容器，这就叫控制反转

从本质上讲，java项目的运行逻辑就是实例化要使用的类得到对象，对这些对象进行操作。

在Spring中也不例外，使用model类的Bean封装数据，使用Service型的Bean处理业务逻辑，使用Controller型的Bean控制前后端的交互

之前已经说过，Spring将Bean的控制权交给了容器，那么容器什么时候实例化Bean?

### 两种加载

* 立即加载：容器在项目启动时实例化所有的类并将对象存放进容器
* 懒加载：容器在第一次使用Bean的时候才加载类



### IOC中的反射

Spring使用xml配置bean，容器可以根据xml中Bean的全限定名获取Class实例得到Bean实例



### AOP

AOP，面向切面编程，将业务逻辑剥离分层，分成一个一个的切面，将那些可以复用的非核心逻辑如日志从显式存在于代码中改为动态代理添加的方式，既能使代码更简洁，又能解耦合

AOP基于**动态代理**实现，动态代理基于反射实现

动态代理，运行时增强。比如有一个实现了某个接口的类，想要给他的某个方法添加一些功能，就可以使用动态代理创建一个同样实现了这个接口的代理类，重写要增强的方法并加入要添加的功能

以日志为例说明。在一个类中，有多个方法（连接点)，现在想给其中的几个方法（切点)添加日志功能，


首先要知道日志添加在方法执行前还是执行后已经具体怎么做（处理)，之后根据定义一个由切点和处理组成的切面类

# 封装继承多态

* [源码](https://github.com/modiman/CodeOfNotes/tree/main/oop)

假设要抽象表示这个世界，以生物为例

每个生物都应该有一些基本属性（成员变量）、有一些行为能力（成员方法）

首先是人

```java
public class People{
    //一些基本属性
    private String type;
    private String name;
    private boolean famale;
    private int age;
    private People father;

    //构造器 
    public People(){

    }

    //行为
    public void run(){
        System.out.println("run");
    }
    public void speak(){
        System.out.println("speak");
    }
    public void write(){
        System.out.println("write");
    }

}
```

cat

```java
public class Cat {
     //一些基本属性
     private String type;
     private String name;
     private boolean famale;
     private int age;
     private Cat father;
   //构造器 
    public Cat(){

    }

    //行为
    public void run(){
        System.out.println("run");
    }
    public void speak(){
        System.out.println("speak");
    }
}
```

发现一些规律：

* 很多类是有一些公共属性的，如name、type、famale,那么每次都在类中写出这些是否冗余？**解决方案**：继承，定义一个模板类，把那些公共属性集中起来，子类只要继承这个类就自动继承了他的成员变量

**抽象一个生物类**

```java
public class Creature {
    private String type;
    private String name;
    boolean famale;
    private int age;
    
}

```

有时候不仅仅公共属性需要继承，方法也需要继承。

问题在于方法不同于属性，方法涉及到了一系列具体逻辑的处理。可每个继承的子类实现同一件事情未必使用相同的方式（世界的参差）。比如run方法，人用两条腿，猫用四条腿。在这种情况下，父类可以不直接实现run方法，而是只定义一个方法名，告诉继承他的子类他应该有这个行为，具体怎么做自己决定。

于是抽象方法和抽象类出现了

* 抽象方法指只有方法名**没有也不能有**方法体的方法
* 抽象类指有抽象方法存在的类

```java
public abstract class Creature {
    private String type;
    private String name;
    boolean famale;
    private int age; 
    
    public abstract void run();
    public abstract void eat();
}

```

**新的问题，java只能单继承**

​          思考一个问题，有一个父类A，两个子类C和D分别继承了A并各自重写了A的a方法，那么如果D同时继承B和C将不知道该去继承谁的a方法，为了避免这种菱形继承的问题，java只允许单继承。

​        菱形继承好像对上面的抽象类并不会产生影响，因为抽象类只有方法名，没有方法体。

可是由于java只能单继承，思考以下情景

* 一个类想要继承多个类的方法
* 只需要继承方法不用属性

于是**接口**应运而生了

接口更是像是一个专门描述行为的数据结构，描述一个类想要成为这个类必须具有哪些行为。

抽象类表示is a,接口表示like a

定义一个Livable接口

```java
public interface Livable {
    public void run();
    public void speak();
}
```

这种通过不同方式实现接口中的方法的操作就叫做**多态**。

接口的出现促进了面向接口编程的发展，更好的践行了**开闭原则**（即对拓展开放，对修改关闭）
