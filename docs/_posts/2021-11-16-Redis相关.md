# 安装

1. 将压缩包放到想放的位置

2. 解压  

   ```bash
   tar xzvf redis-6.2.3.tar.gz
   ```

   

3. 进入redis根目录

   ```bash
    cd redis-6.2.3
   ```

4. 

   ```bash
   make
   ```

   如果这一步出错，改用

   ```bash
   make MALLOC=libc
   ```

5. 此时在根目录下已经可以启动服务

   ```bash
   redis-server  # 启动服务器
   redis-cli   # 启动客户端
   ```

6. 添加环境变量以便从任意路径启动

   ```bash
   echo "export REDIS_HOME=/home/modige/softs/redis-6.2.3" >>/etc/profile
   echo "export PTAH=$PATH:$REDIS_HOME" >>/etc/profile
   ```

   ## 备份与恢复

   https://www.runoob.com/redis/redis-backup.html

# 基本数据类型

## 集合set

### 插入

```redis
sadd setname setvalue
```

### 删除集合

```redis
del setname
```

### 返回集合所有元素

```
smembers setname
```

### 删除指定元素

```redis
srem setname itemname
```

### 集合成员数

```redis
scard setname
```



## 列表List

### 插入

```
lpush 
```

## 列表长度

```
LLen
```

### 批量查询

```
lrange listname start end 
```

# Redis16个常见应用场景

## 1. 缓存 

String 类型 

例如：热点数据缓存（例如报表、明星出轨），对象缓存、全页缓存、可以提升热点数据的访问数据

### 2、数据共享分布式

String 类型，因为 Redis 是分布式的独立服务，可以在多个应用之间共享

例如：分布式Session

```xml
<dependency> 
 <groupId>org.springframework.session</groupId> 
 <artifactId>spring-session-data-redis</artifactId> 
</dependency>
```

### 3.分布式锁

String类型setnx方法，只有不存在是才能添加成功，返回true

```java
public static boolean getLock(String key) {
    Long flag = jedis.setnx(key, "1");
    if (flag == 1) {
        jedis.expire(key, 10);
    }
    return flag == 1;
}

public static void releaseLock(String key) {
    jedis.del(key);
}
```

### 4. 全局ID

int类型，incrby，利用原子性



incrby userid 1000

分库分表的场景，一次性拿一段

### 5. 计数器

int类型  ，incr方法

例如：文章的阅读量、微博点赞数、允许一定的延迟，先写入Redis再同步到数据库

### 6.限流

int类型  incr方法

以访问者的ip和其他信息作为key，访问一次增加一次技术超过次数则返回false

### 7. 位统计



String类型的bitcount

字符是以8位二进制存储的

```bash
set k1 a
setbit k1 6 1
setbit k1 7 0
get k1 
/* 6 7 代表的a的二进制位的修改
a 对应的ASCII码是97，转换为二进制数据是01100001
b 对应的ASCII码是98，转换为二进制数据是01100010

因为bit非常节省空间（1 MB=8388608 bit），可以用来做大数据量的统计。
*/
```

例如：在线用户统计，留存用户统计

```bash
setbit onlineusers 01 
setbit onlineusers 11 
setbit onlineusers 20
```

支持按位与、按位或等等操作

```bash
BITOPANDdestkeykey[key...] ，对一个或多个 key 求逻辑并，并将结果保存到 destkey 。       
BITOPORdestkeykey[key...] ，对一个或多个 key 求逻辑或，并将结果保存到 destkey 。 
BITOPXORdestkeykey[key...] ，对一个或多个 key 求逻辑异或，并将结果保存到 destkey 。 
BITOPNOTdestkeykey ，对给定 key 求逻辑非，并将结果保存到 destkey 。
```

计算出7天都在线的用户

```bash
BITOP "AND" "7_days_both_online_users" "day_1_online_users" "day_2_online_users" ...  "day_7_online_users"
```

### 8.购物车

String或hash,所有String可以做的hash都可以做

### 9.用户消息时间线timeline

list 双向链表，直接作为timeline就好，插入有序

### 10.消息队列

List提供了两个阻塞的弹出操作:blpop/brpop,可以设置超时时间

* blpop

```shell
blpop key1 timeout# 移除并获取列表的第一个元素，如果列表没有元素会阻塞列表直到等待超时会发现可弹出元素为止
```

* brpop

```shell
brpop key timeout # 移除并获取列表的最后一个元素
```

上面的操作实际上就是java的阻塞队列。

### 11.抽奖

自带一个随机获得值

```
spop myset
```

### 12. 点赞 签到 打卡

假如上面的微博ID是t1001，用户ID是u3001

* 用 like:t1001 来维护 t1001 这条微博的所有点赞用户
* 点赞了这条微博：```sadd like:t1001 u3001```
* 取消点赞：```srem like:t1001 u3001```

- 是否点赞：```sismember like:t1001 u3001```
- 点赞的所有用户：```smembers like:t1001```
- 点赞数：```scard like:t1001```

是不是比数据库简单多了。

### 13.商品标签

老规矩，用 tags:i5001 来维护商品所有的标签。

- ```sadd tags:i5001``` 画面清晰细腻
- ```sadd tags:i5001``` 真彩清晰显示屏
- ```sadd tags:i5001``` 流程至极

### 14. 商品筛选

```
// 获取差集
sdiff set1 set2
// 获取交集（intersection ）
sinter set1 set2
// 获取并集
sunion set1 set2
```

假如：iPhone11 上市了

```
sadd brand:apple iPhone11

sadd brand:ios iPhone11

sad screensize:6.0-6.24 iPhone11

sad screentype:lcd iPhone 11
```

赛选商品，苹果的、ios的、屏幕在6.0-6.24之间的，屏幕材质是LCD屏幕

```
sinter brand:apple brand:ios screensize:6.0-6.24 screentype:lcd
```

### 15 用户关注 推荐模型

follow 关注 fans 粉丝

[相互关注：](https://mp.weixin.qq.com/s?__biz=MzI4NTM1NDgwNw==&mid=2247500365&idx=1&sn=7abfd8b30427d4ac15bb351c3dbb640c&scene=21#wechat_redirect)

- [sadd 1:follow 2](https://mp.weixin.qq.com/s?__biz=MzI4NTM1NDgwNw==&mid=2247500365&idx=1&sn=7abfd8b30427d4ac15bb351c3dbb640c&scene=21#wechat_redirect)
- [sadd 2:fans 1](https://mp.weixin.qq.com/s?__biz=MzI4NTM1NDgwNw==&mid=2247500365&idx=1&sn=7abfd8b30427d4ac15bb351c3dbb640c&scene=21#wechat_redirect)
- [sadd 1:fans 2](https://mp.weixin.qq.com/s?__biz=MzI4NTM1NDgwNw==&mid=2247500365&idx=1&sn=7abfd8b30427d4ac15bb351c3dbb640c&scene=21#wechat_redirect)
- [sadd 2:follow 1](https://mp.weixin.qq.com/s?__biz=MzI4NTM1NDgwNw==&mid=2247500365&idx=1&sn=7abfd8b30427d4ac15bb351c3dbb640c&scene=21#wechat_redirect)

[我关注的人也关注了他(取交集)：](https://mp.weixin.qq.com/s?__biz=MzI4NTM1NDgwNw==&mid=2247500365&idx=1&sn=7abfd8b30427d4ac15bb351c3dbb640c&scene=21#wechat_redirect)

- [sinter 1:follow 2:fans](https://mp.weixin.qq.com/s?__biz=MzI4NTM1NDgwNw==&mid=2247500365&idx=1&sn=7abfd8b30427d4ac15bb351c3dbb640c&scene=21#wechat_redirect)

[可能认识的人：](https://mp.weixin.qq.com/s?__biz=MzI4NTM1NDgwNw==&mid=2247500365&idx=1&sn=7abfd8b30427d4ac15bb351c3dbb640c&scene=21#wechat_redirect)

- [用户1可能认识的人(差集)：sdiff 2:follow 1:follow](https://mp.weixin.qq.com/s?__biz=MzI4NTM1NDgwNw==&mid=2247500365&idx=1&sn=7abfd8b30427d4ac15bb351c3dbb640c&scene=21#wechat_redirect)
- [用户2可能认识的人：sdiff 1:follow 2:follow](https://mp.weixin.qq.com/s?__biz=MzI4NTM1NDgwNw==&mid=2247500365&idx=1&sn=7abfd8b30427d4ac15bb351c3dbb640c&scene=21#wechat_redirect)****

### 16、排行榜

id 为6001 的新闻点击数加1：

- 

```
zincrby hotNews:20190926 1 n6001
```

获取今天点击最多的15条：

- 

```
zrevrange hotNews:20190926 0 15 withscores
```

# Redis面试题

* 帅地玩编程

## 1. 谈下你对Redis的了解

Redis(全程：remote dictionary server，远程字典服务)是一个开源的使用ANSIC语言编写，支持网络、基于内存亦可持久化的日志型、key-value数据库，并提供多种语言的API

## 2. Redis一般都有哪些使用场景

适合的场景

* 缓存
* 排行榜
* 计数器 、限速器（统计在线人数、浏览量、播放量）
* 好友关系（点赞、共同好友）
* 简单的消息队列（订阅发布）
* session服务器

不适合的场景

* 数据访问频率低
* 数据量大

## 3. 常见功能

1. 数据缓存功能
2. 分布式锁的功能
3. 支持数据持久化
4. 支持事务
5. 支持消息队列

## 4. 支持的数据类型

###  String  字符串

###  Hash 

### List

### Set

### Zset

## 5. Redis为什么这么快

1. 完全基于内存，绝大部分请求是存粹的内存操作，非常快速
2. 数据结构简单，对数据操作也简单
3. 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者我多线程切换导致的CPU消耗，不用考虑各种锁的问题，不存在加锁放锁操作，没有因为可能出现死锁而导致的性能消耗
4. 使用多路I/o服用模型，非阻塞IO

## 6. 什么是缓存穿透，怎么解决

缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透

### 解决办法

1. 缓存空对象：如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟

### 缓存空对象带来的问题
1. 空值做了缓存，意味着缓存中存了更多的键，需要更多的内存空间，比较有效的方法是针对这类数据设置一个较短的过期时间，让其自动剔除
2. 缓存和存储的数据会有一段时间窗口的不一致，可能会对业务有一定影响。例如：过期时间设置为5分钟，如果此时存储添加了这个数据，那此段时间就会出现缓存和存储数据的不一致，此时可以利用消息系统或其他方式清除掉缓存层中的空对象
3. 布隆过滤器：将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。

## 7.什么是缓存雪崩，该如何解决

如果缓存集中在一段时间内失效，发生大量的缓存穿透，所有的查询都落在数据库上，造成了缓存雪崩

### 解决办法

1. 加锁排队：在缓存失效后，通过加锁或者队列来控制读数据写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待
2. 数据加热：可以通过缓存reload机制，预先去更新缓存，在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀
3. 做二级缓存，或者双缓存策略：cache1为原始缓存，cache2为拷贝缓存，cache1失效时，可以访问cache2，cache1缓存失效时间设置为短期，cache2设置为长期
4. 在缓存的时候给过期时间加上一个随机值，这样就会大幅度的减少缓存在同一时间过期

##  8. 怎么保证缓存和数据库数据的一致性

1. 从理论上说，只要设置了合理的键的过期时间就能保证一致。因为只要缓存数据过期了就会被删除。随后读的时候，因为缓存里没有，就可以查数据库的数据，然后将数据库查出来的数据写入缓存中。除了设置过期时间，我们还需要做更多的措施来避免数据库与缓存处于不一致的情况发生
2. 新增、更改、删除数据库操作时同步更新Redis，可以使用事务机制来保证数据的一致性

## 9. Redis持久化有几种方式

持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。Redis提供了两种持久化的方式RPD（默认）和AOF

### RDB（Redis DataBase）

按照与i



