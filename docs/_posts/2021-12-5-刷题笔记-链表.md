#### [剑指 Offer II 024. 反转链表](https://leetcode-cn.com/problems/UHnkqh/)

难度简单34

给定单链表的头节点 `head` ，请反转链表，并返回反转后的链表的头节点。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)

```
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg)

## 思路

* 准备两个中间变量next和pre
* next永远指向原始链表中头结点的后一个节点，目的是记录原始链表位置
* pre永远指向新链表头节点，目的是记录新链表位置
* 新链表的构造采用**头插法**

## 代码

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        
        ListNode pre = null;
        ListNode next = null;
        while(head!=null){
            next = head.next;
            head.next = pre;
            pre = head;
            head = next;
        }
        return pre;

    }
}
```



#### [92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

难度中等1092

给你单链表的头指针 `head` 和两个整数 `left` 和 `right` ，其中 `left <= right` 。请你反转从位置 `left` 到位置 `right` 的链表节点，返回 **反转后的链表** 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg)

```
输入：head = [1,2,3,4,5], left = 2, right = 4
输出：[1,4,3,2,5]
```

**示例 2：**

```
输入：head = [5], left = 1, right = 1
输出：[5]
```

 

**提示：**

- 链表中节点数目为 `n`
- `1 <= n <= 500`
- `-500 <= Node.val <= 500`
- `1 <= left <= right <= n`

## 思路

* 用leftpre记录left的前一个节点，用rightnext记录right的下一个节点
* 切割链表，将待翻转的部分独立处理
* 切割的方法是将leftpre和right指向null

       ```java
       leftpre.next = null;
       rightnode.next = null;
       ```

* 重新连接被反转后的链表

```java
leftpre.next = right;
rightnode.next = rightnext;
```

* 为了避免判断链表边界，以便确定leftpre的位置，定义一个虚拟头结点,这个节点永远指向链表头节点

```java
ListNode leftpre = new ListNode(-1);
leftpre.next = head;
```

* 这个虚拟头结点的位置也需要记录下来，作为最后的返回值
* 待翻转链表部分的结尾不必记录，反转之后的leftnode就是尾节点，rightnode则是头结点
* **如果把头结点位置记录下来作为返回值会出错，因为如果头结点包含在待翻转的部分，再返回这一节点有可能不是完整的原链表**

## 代码

```java
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        
        ListNode list = head;
        //添加一个虚拟头结点，避免边界判断

        ListNode leftpre = new ListNode(-1);
      
        leftpre.next = head;
        ListNode res = leftpre;
        //找到left的前面一个节点
        for(int i=1;i<left;i++){
            leftpre = leftpre.next;
        }
        //记录开始节点
        ListNode leftnode = leftpre.next;
        ListNode rightnode = leftpre;
        //寻找结束节点
        for(int i=0;i<right-left+1;i++){
            rightnode = rightnode.next;
        }

        ListNode rightnext = rightnode.next;
        
        //切断联系,将待反转的部分独立出来
        rightnode.next = null;
        leftpre.next = null;

        reverseList(leftnode);
        //接回链表
        leftpre.next = rightnode;
        leftnode.next = rightnext;
        return res.next;
    }

    void reverseList(ListNode head){

        ListNode pre = null;
        ListNode cur = head;
        while(cur!=null){
            ListNode next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
    }
}
```

