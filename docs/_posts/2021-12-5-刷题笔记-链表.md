#### [剑指 Offer II 024. 反转链表](https://leetcode-cn.com/problems/UHnkqh/)

难度简单34

给定单链表的头节点 `head` ，请反转链表，并返回反转后的链表的头节点。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)

```
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg)

## 思路

* 准备两个中间变量next和pre
* next永远指向原始链表中头结点的后一个节点，目的是记录原始链表位置
* pre永远指向新链表头节点，目的是记录新链表位置
* 新链表的构造采用**头插法**

## 代码

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        
        ListNode pre = null;
        ListNode next = null;
        while(head!=null){
            next = head.next;
            head.next = pre;
            pre = head;
            head = next;
        }
        return pre;

    }
}
```



#### [92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

难度中等1092

给你单链表的头指针 `head` 和两个整数 `left` 和 `right` ，其中 `left <= right` 。请你反转从位置 `left` 到位置 `right` 的链表节点，返回 **反转后的链表** 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg)

```
输入：head = [1,2,3,4,5], left = 2, right = 4
输出：[1,4,3,2,5]
```

**示例 2：**

```
输入：head = [5], left = 1, right = 1
输出：[5]
```

 

**提示：**

- 链表中节点数目为 `n`
- `1 <= n <= 500`
- `-500 <= Node.val <= 500`
- `1 <= left <= right <= n`

## 思路

* 用leftpre记录left的前一个节点，用rightnext记录right的下一个节点
* 切割链表，将待翻转的部分独立处理
* 切割的方法是将leftpre和right指向null

       ```java
       leftpre.next = null;
       rightnode.next = null;
       ```

* 重新连接被反转后的链表

```java
leftpre.next = right;
rightnode.next = rightnext;
```

* 为了避免判断链表边界，以便确定leftpre的位置，定义一个虚拟头结点,这个节点永远指向链表头节点

```java
ListNode leftpre = new ListNode(-1);
leftpre.next = head;
```

* 这个虚拟头结点的位置也需要记录下来，作为最后的返回值
* 待翻转链表部分的结尾不必记录，反转之后的leftnode就是尾节点，rightnode则是头结点
* **如果把头结点位置记录下来作为返回值会出错，因为如果头结点包含在待翻转的部分，再返回这一节点有可能不是完整的原链表**

## 代码

```java
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        
        ListNode list = head;
        //添加一个虚拟头结点，避免边界判断

        ListNode leftpre = new ListNode(-1);
      
        leftpre.next = head;
        ListNode res = leftpre;
        //找到left的前面一个节点
        for(int i=1;i<left;i++){
            leftpre = leftpre.next;
        }
        //记录开始节点
        ListNode leftnode = leftpre.next;
        ListNode rightnode = leftpre;
        //寻找结束节点
        for(int i=0;i<right-left+1;i++){
            rightnode = rightnode.next;
        }

        ListNode rightnext = rightnode.next;
        
        //切断联系,将待反转的部分独立出来
        rightnode.next = null;
        leftpre.next = null;

        reverseList(leftnode);
        //接回链表
        leftpre.next = rightnode;
        leftnode.next = rightnext;
        return res.next;
    }

    void reverseList(ListNode head){

        ListNode pre = null;
        ListNode cur = head;
        while(cur!=null){
            ListNode next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
    }
}
```

#### [剑指 Offer II 027. 回文链表](https://leetcode-cn.com/problems/aMhZSa/)

难度简单19

给定一个链表的 **头节点** `head` **，**请判断其是否为回文链表。

如果一个链表是回文，那么链表节点序列从前往后看和从后往前看是相同的。

 

**示例 1：**

**![img](https://pic.leetcode-cn.com/1626421737-LjXceN-image.png)**

```
输入: head = [1,2,3,3,2,1]
输出: true
```

**示例 2：**

**![img](https://pic.leetcode-cn.com/1626422231-wgvnWh-image.png)**

```
输入: head = [1,2]
输出: false
```

 

**提示：**

- 链表 L 的长度范围为 `[1, 105]`
- `0 <= node.val <= 9`

 ## 思路

* 快慢指针找到链表的中间节点（若为偶数则定为左边最后一个）
* 将链表右半部分逆置
* 比较左右两部分是否完全相同
* 回复链表
* 返回结果

## 代码

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public boolean isPalindrome(ListNode head) {

        //将链表后半部分逆置后与前半部分比较
        if(head.next==null) return true;
        ListNode fast=head,slow=head;
        int len = 1;
        //快慢指针查找链表中间节点
        //快指针走两步慢指针走一步
        //快指针走不满两步说明链表长度为偶数，慢指针停在左半部分最后一位
        while(fast.next!=null&&fast.next.next!=null){
               fast = fast.next.next;
               slow = slow.next;
        }
        //记录右半部分第一位，即左半部分最后一位的后一位    
        ListNode right= slow.next;
        //将左右两部分切割
        slow.next = null;

        //ListNode pre = null;
        ListNode next = null;

        //翻转右半部分，反转后的头结点指向左半部分最后一位
        while(right!=null){
            next = right.next;
            right.next =slow;
            slow = right;
            right = next;

        }

        next = slow;
        right = head;
        boolean res = true;
        while(slow!=null&&right!=null){
            if(slow.val!=right.val){
                res = false;
                break;
            }
            slow = slow.next;
            right = right.next;
        }

//回复链表
        slow = next;
        next.next = null;

        
        while(slow!=null){
            right = slow.next;
            slow.next = next;
            next = slow;
            slow = right;
        }
        return res;

    }
}
```

#### [138. 复制带随机指针的链表](https://leetcode-cn.com/problems/copy-list-with-random-pointer/)

难度中等

给你一个长度为 `n` 的链表，每个节点包含一个额外增加的随机指针 `random` ，该指针可以指向链表中的任何节点或空节点。

构造这个链表的 **[深拷贝](https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin)**。 深拷贝应该正好由 `n` 个 **全新** 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 `next` 指针和 `random` 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。**复制链表中的指针都不应指向原链表中的节点** 。

例如，如果原链表中有 `X` 和 `Y` 两个节点，其中 `X.random --> Y` 。那么在复制链表中对应的两个节点 `x` 和 `y` ，同样有 `x.random --> y` 。

返回复制链表的头节点。

用一个由 `n` 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 `[val, random_index]` 表示：

- `val`：一个表示 `Node.val` 的整数。
- `random_index`：随机指针指向的节点索引（范围从 `0` 到 `n-1`）；如果不指向任何节点，则为 `null` 。

你的代码 **只** 接受原链表的头节点 `head` 作为传入参数。

 

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png)

```
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
```

**示例 2：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e2.png)

```
输入：head = [[1,1],[2,1]]
输出：[[1,1],[2,1]]
```

**示例 3：**

**![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e3.png)**

```
输入：head = [[3,null],[3,0],[3,null]]
输出：[[3,null],[3,0],[3,null]]
```

**示例 4：**

```
输入：head = []
输出：[]
解释：给定的链表为空（空指针），因此返回 null。
```

 

**提示：**

- `0 <= n <= 1000`
- `-10000 <= Node.val <= 10000`
- `Node.random` 为空（null）或指向链表中的节点。

## 思路（方法一）

空间复杂度：O(N) ，一个哈希表；  时间复杂度O（N）两次遍历

* 第一次遍历，引入一个哈希表，存放新旧节点的对应关系，新生成的节点next和random指针指向null
* 第二次遍历，穿针引线，将新生成的节点连接起来

## 代码

```java
/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/

class Solution {
    public Node copyRandomList(Node head) {
        if (head==null) return null;
        Node flag = head;       
        HashMap<Node,Node> map = new HashMap<>();
        while(head!=null){
            Node newNode = new Node(head.val);
            map.put(head,newNode);
            head = head.next; 
        }
        head = flag;
        while(head!=null){
            map.get(head).next = map.get(head.next);
            map.get(head).random = map.get(head.random);
            head = head.next;
        }
        return map.get(flag);
    }
}
```

## 方法二，原地添加

* 为了保留新旧节点之间一一对应的关系，将每个新生成的节点放在原始节点之后，这样任然能根据原始节点查找新节点，与hashmap效果相同
* 即  1--2---3---null 变成1--1‘--2--2’--3--3’--null;
* 第二次遍历负责穿针引线，主要负责random指针的修改
* 第三遍负责将链表分割成新旧两个链表



## 代码

```java
/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/

class Solution {
    public Node copyRandomList(Node head) {
        if (head==null) return null;

        Node cur = head;
        Node next =  head;
      //生成新节点，并插入到原始节点之后
        //这样能保证在穿针引线时每个新节点对应的新节点都是原始节点的下一个节点或者null
        while(head!=null){
            Node newNode = new Node(head.val);
            newNode.next =  head.next;
            head.next = newNode;
            head = newNode.next; 
        }
       
        head = cur;
       //设置新节点的random指针
        while(head!=null){
            //需要注意的是判断原始节点的random是否为null,
            head.next.random = head.random==null?null:head.random.next;     
            head =head.next.next;
        }

        head = cur;
        Node res = head.next;
        Node curCopy = res;

    //切割链表，分解成原始链表与副本链表
        while(head!=null){
            next = head.next.next;  
            curCopy = head.next;
            head.next = next;
            curCopy.next =next==null?null:next.next; 
            head = next;
            
        }

            return res;  
    }
}
```

