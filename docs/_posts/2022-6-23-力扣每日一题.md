## 6-23 滑动窗口

#### [438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

难度中等923收藏分享切换为英文接收动态反馈

给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **异位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

**异位词** 指由相同字母重排列形成的字符串（包括相同的字符串）。

 

**示例 1:**

```
输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。
```

 **示例 2:**

```
输入: s = "abab", p = "ab"
输出: [0,1,2]
解释:
起始索引等于 0 的子串是 "ab", 它是 "ab" 的异位词。
起始索引等于 1 的子串是 "ba", 它是 "ab" 的异位词。
起始索引等于 2 的子串是 "ab", 它是 "ab" 的异位词。
```

方法一：滑动窗口
思路

根据题目要求，我们需要在字符串 ss 寻找字符串 pp 的异位词。因为字符串 pp 的异位词的长度一定与字符串 pp 的长度相同，所以我们可以在字符串 ss 中构造一个长度为与字符串 pp 的长度相同的滑动窗口，并在滑动中维护窗口中每种字母的数量；当窗口中每种字母的数量与字符串 pp 中每种字母的数量相同时，则说明当前窗口为字符串 pp 的异位词。

算法

在算法的实现中，我们可以使用数组来存储字符串 pp 和滑动窗口中每种字母的数量。

细节

当字符串 ss 的长度小于字符串 pp 的长度时，字符串 ss 中一定不存在字符串 pp 的异位词。但是因为字符串 ss 中无法构造长度与字符串 pp 的长度相同的窗口，所以这种情况需要单独处理。

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        if (s.length()<p.length()) return new ArrayList();
        List<Integer> res = new ArrayList();

        int[] pLetterCount = new int[26];
        int[] windowLetterCount = new int[26];

        for(int i=0;i<p.length();i++){
            pLetterCount[p.charAt(i)-'a'] ++ ;
            windowLetterCount[s.charAt(i)-'a']++;

        }
        if(Arrays.equals(pLetterCount,windowLetterCount)) res.add(0);

        for(int i=1;i<=s.length()-p.length();i++){
            windowLetterCount[s.charAt(i+p.length()-1)-'a']++;
            windowLetterCount[s.charAt(i-1)-'a']--;
    
            if(Arrays.equals(pLetterCount,windowLetterCount)) res.add(i);

        }
        return res;
    }
}
```





# [522. 最长特殊序列 II](https://leetcode.cn/problems/longest-uncommon-subsequence-ii/)

难度中等119

给定字符串列表 `strs` ，返回其中 **最长的特殊序列** 。如果最长特殊序列不存在，返回 `-1` 。

**特殊序列** 定义如下：该序列为某字符串 **独有的子序列（即不能是其他字符串的子序列）**。

 `s` 的 **子序列**可以通过删去字符串 `s` 中的某些字符实现。

- 例如，`"abc"` 是 `"aebdc"` 的子序列，因为您可以删除`"aebdc"`中的下划线字符来得到 `"abc"` 。`"aebdc"`的子序列还包括`"aebdc"`、 `"aeb"` 和 "" (空字符串)。

 

**示例 1：**

```
输入: strs = ["aba","cdc","eae"]
输出: 3
```

**示例 2:**

```
输入: strs = ["aaa","aaa","aa"]
输出: -1
```



## 思路

### 一个性质

如果一个子字符串是特殊序列，那么它的任意父字符串都是特殊序列。

换句话说，如果一个字符串拥有一个特殊序列子字符串，那么它本身就是一个特殊序列。

因此问题转化为求字符串数组中最长的特殊序列元素。

使用枚举法

1. 给字符串数组按字符串长度排序，长度递减（可以使用Array。sort配合lambda表达式）
2. 从左往右遍历数组，返回第一个特殊序列的长度

## 代码

```java
class Solution {
    public int findLUSlength(String[] strs) {

        Arrays.sort(strs, (s1, s2) -> s2.length() - s1.length());
        int res = -1;
        for (int i=0;i<strs.length;i++){
            boolean flag = false;
            for (int j =0;j<strs.length;j++){
                if (j!=i && isSubString(strs[i],strs[j])){
                   flag = true;
                }
            }
            if(!flag) return strs[i].length();
        }
  
        return res;

    }

    public boolean isSubString(String subString,String supString){
        int len = subString.length();
        int pSub =  0,pSup = 0;
        while (pSub<subString.length()&&pSup<supString.length()){
            if(subString.charAt(pSub++)!=supString.charAt(pSup++)) pSub--;
        }
        if (pSub==len) return true;
        return false;
    }
}
```

# [241. 为运算表达式设计优先级](https://leetcode.cn/problems/different-ways-to-add-parentheses/)

难度中等702

给你一个由数字和运算符组成的字符串 `expression` ，按不同优先级组合数字和运算符，计算并返回所有可能组合的结果。你可以 **按任意顺序** 返回答案。

生成的测试用例满足其对应输出值符合 32 位整数范围，不同结果的数量不超过 `104` 。

 

**示例 1：**

```
输入：expression = "2-1-1"
输出：[0,2]
解释：
((2-1)-1) = 0 
(2-(1-1)) = 2
```

**示例 2：**

```
输入：expression = "2*3-4*5"
输出：[-34,-14,-10,-10,10]
解释：
(2*(3-(4*5))) = -34 
((2*3)-(4*5)) = -14 
((2*(3-4))*5) = -10 
(2*((3-4)*5)) = -10 
(((2*3)-4)*5) = 10
```

 

**提示：**

- `1 <= expression.length <= 20`
- `expression` 由数字和算符 `'+'`、`'-'` 和 `'*'` 组成。
- 输入表达式中的所有整数值在范围 `[0, 99]`

## 思路：递归问题

**定义**：

n：字符串中运算数的数量

f(n):n个运算数对应的结果的数量

g(x,n-x)：将n拆分为x和n-x前后两部分，拆分得到的组合对应的结果的数量

则有状态方程

```
f(1) = 1
f(2) = 1
f(3) = g(1,2) + g(2,1)
f(4) = g(1,3) + g(2,2) + g(3,1)
f(5) = g(1,4) + g(2,3) + g(3,2) + g (4,1)
```

这样将问题转化为两个子问题：

将expression拆分成两部分，最终结果为两部分答案的排列组合

其中

```
g(x,y) = f(x) * f(y)
```

**举例**

`"2*3-4*5"`

共有四个运算数，三个运算符

可能的组合有

| 2     | 3-4*5 |
| ----- | ----- |
| 2*3   | 4*5   |
| 2*3-4 | 5     |

这样求两部分各自的结果，再排列组合即可，当某部分操作数大于2时可以继续拆分，这样就形成了一个递归问题。

上述问题有三种组合，组合1(2,3-4*5)两部分对应的结果分别为【2】【-5，-17】，两部分对应的运算符为\*,这样组合1对应的最终结果为【-10，-34】,对于其他两个组合进行同样的操作

## 代码

代码需要3部分

1. 字符处理函数：将字符串拆分成运算数与运算符
2. 字符运算函数：对于给定的两个运算数及其运算符，返回运算结果
3. 递归函数：递归求出结果并返回

python代码如下

```python
class Solution:
    def diffWaysToCompute(self, expression: str) -> List[int]:
        nums,ops = self.processExpress(expression)
        return self.getRes(nums,ops)
    def processExpress(self,s):
        operaors = []
        nums = []
        allOps = ['+','-','*']
        num = ''
        for i in range(len(s)):
            if s[i] not in allOps:
                num += s[i]
            else:
                nums.append(int(num))
                num = ''
                operaors.append(s[i])
        if len(num)>0:nums.append(int(num))

        return nums,operaors
    def operationNum(self,a,b,c):
        if c=='+':return a+b
        if c=='-':return a-b
        return a*b
    def getRes(self,nums , ops):
        res = []
        if(len(nums)==1): return nums
        elif(len(nums)==2):return [self.operationNum(nums[0],nums[1],ops[0])]
        for i in range(1,len(nums)):
            res1 = self.getRes(nums[0:i],ops[0:i-1])
            res2 = self.getRes(nums[i:],ops[i:])
            for a in res1:
                for b in res2:
                    res += [self.operationNum(a,b,ops[i-1])]
        return res

```

