## 6-23 滑动窗口

#### [438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

难度中等923收藏分享切换为英文接收动态反馈

给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **异位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

**异位词** 指由相同字母重排列形成的字符串（包括相同的字符串）。

 

**示例 1:**

```
输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。
```

 **示例 2:**

```
输入: s = "abab", p = "ab"
输出: [0,1,2]
解释:
起始索引等于 0 的子串是 "ab", 它是 "ab" 的异位词。
起始索引等于 1 的子串是 "ba", 它是 "ab" 的异位词。
起始索引等于 2 的子串是 "ab", 它是 "ab" 的异位词。
```

方法一：滑动窗口
思路

根据题目要求，我们需要在字符串 ss 寻找字符串 pp 的异位词。因为字符串 pp 的异位词的长度一定与字符串 pp 的长度相同，所以我们可以在字符串 ss 中构造一个长度为与字符串 pp 的长度相同的滑动窗口，并在滑动中维护窗口中每种字母的数量；当窗口中每种字母的数量与字符串 pp 中每种字母的数量相同时，则说明当前窗口为字符串 pp 的异位词。

算法

在算法的实现中，我们可以使用数组来存储字符串 pp 和滑动窗口中每种字母的数量。

细节

当字符串 ss 的长度小于字符串 pp 的长度时，字符串 ss 中一定不存在字符串 pp 的异位词。但是因为字符串 ss 中无法构造长度与字符串 pp 的长度相同的窗口，所以这种情况需要单独处理。

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        if (s.length()<p.length()) return new ArrayList();
        List<Integer> res = new ArrayList();

        int[] pLetterCount = new int[26];
        int[] windowLetterCount = new int[26];

        for(int i=0;i<p.length();i++){
            pLetterCount[p.charAt(i)-'a'] ++ ;
            windowLetterCount[s.charAt(i)-'a']++;

        }
        if(Arrays.equals(pLetterCount,windowLetterCount)) res.add(0);

        for(int i=1;i<=s.length()-p.length();i++){
            windowLetterCount[s.charAt(i+p.length()-1)-'a']++;
            windowLetterCount[s.charAt(i-1)-'a']--;
    
            if(Arrays.equals(pLetterCount,windowLetterCount)) res.add(i);

        }
        return res;
    }
}
```

## 递归处理链表
2. 两数相加
给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

 

示例 1：


输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
示例 2：

输入：l1 = [0], l2 = [0]
输出：[0]
示例 3：

输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]


提示：

每个链表中的节点数在范围 [1, 100] 内
0 <= Node.val <= 9
题目数据保证列表表示的数字不含前导零
### 思路
原地相加，将对应位置相加得到的结点存在l1，最后返回l1
**边界条件**
1. l1和l2都是链表的尾结点，那么只需要判断当前是否存在进位
 * 


# [522. 最长特殊序列 II](https://leetcode.cn/problems/longest-uncommon-subsequence-ii/)

难度中等119

给定字符串列表 `strs` ，返回其中 **最长的特殊序列** 。如果最长特殊序列不存在，返回 `-1` 。

**特殊序列** 定义如下：该序列为某字符串 **独有的子序列（即不能是其他字符串的子序列）**。

 `s` 的 **子序列**可以通过删去字符串 `s` 中的某些字符实现。

- 例如，`"abc"` 是 `"aebdc"` 的子序列，因为您可以删除`"aebdc"`中的下划线字符来得到 `"abc"` 。`"aebdc"`的子序列还包括`"aebdc"`、 `"aeb"` 和 "" (空字符串)。

 

**示例 1：**

```
输入: strs = ["aba","cdc","eae"]
输出: 3
```

**示例 2:**

```
输入: strs = ["aaa","aaa","aa"]
输出: -1
```



## 思路

### 一个性质

如果一个子字符串是特殊序列，那么它的任意父字符串都是特殊序列。

换句话说，如果一个字符串拥有一个特殊序列子字符串，那么它本身就是一个特殊序列。

因此问题转化为求字符串数组中最长的特殊序列元素。

使用枚举法

1. 给字符串数组按字符串长度排序，长度递减（可以使用Array。sort配合lambda表达式）
2. 从左往右遍历数组，返回第一个特殊序列的长度

## 代码

```java
class Solution {
    public int findLUSlength(String[] strs) {

        Arrays.sort(strs, (s1, s2) -> s2.length() - s1.length());
        int res = -1;
        for (int i=0;i<strs.length;i++){
            boolean flag = false;
            for (int j =0;j<strs.length;j++){
                if (j!=i && isSubString(strs[i],strs[j])){
                   flag = true;
                }
            }
            if(!flag) return strs[i].length();
        }
  
        return res;

    }

    public boolean isSubString(String subString,String supString){
        int len = subString.length();
        int pSub =  0,pSup = 0;
        while (pSub<subString.length()&&pSup<supString.length()){
            if(subString.charAt(pSub++)!=supString.charAt(pSup++)) pSub--;
        }
        if (pSub==len) return true;
        return false;
    }
}
```

# [241. 为运算表达式设计优先级](https://leetcode.cn/problems/different-ways-to-add-parentheses/)

难度中等702

给你一个由数字和运算符组成的字符串 `expression` ，按不同优先级组合数字和运算符，计算并返回所有可能组合的结果。你可以 **按任意顺序** 返回答案。

生成的测试用例满足其对应输出值符合 32 位整数范围，不同结果的数量不超过 `104` 。

 

**示例 1：**

```
输入：expression = "2-1-1"
输出：[0,2]
解释：
((2-1)-1) = 0 
(2-(1-1)) = 2
```

**示例 2：**

```
输入：expression = "2*3-4*5"
输出：[-34,-14,-10,-10,10]
解释：
(2*(3-(4*5))) = -34 
((2*3)-(4*5)) = -14 
((2*(3-4))*5) = -10 
(2*((3-4)*5)) = -10 
(((2*3)-4)*5) = 10
```

 

**提示：**

- `1 <= expression.length <= 20`
- `expression` 由数字和算符 `'+'`、`'-'` 和 `'*'` 组成。
- 输入表达式中的所有整数值在范围 `[0, 99]`

## 思路：递归问题

**定义**：

n：字符串中运算数的数量

f(n):n个运算数对应的结果的数量

g(x,n-x)：将n拆分为x和n-x前后两部分，拆分得到的组合对应的结果的数量

则有状态方程

```
f(1) = 1
f(2) = 1
f(3) = g(1,2) + g(2,1)
f(4) = g(1,3) + g(2,2) + g(3,1)
f(5) = g(1,4) + g(2,3) + g(3,2) + g (4,1)
```

这样将问题转化为两个子问题：

将expression拆分成两部分，最终结果为两部分答案的排列组合

其中

```
g(x,y) = f(x) * f(y)
```

**举例**

`"2*3-4*5"`

共有四个运算数，三个运算符

可能的组合有

| 2     | 3-4*5 |
| ----- | ----- |
| 2*3   | 4*5   |
| 2*3-4 | 5     |

这样求两部分各自的结果，再排列组合即可，当某部分操作数大于2时可以继续拆分，这样就形成了一个递归问题。

上述问题有三种组合，组合1(2,3-4*5)两部分对应的结果分别为【2】【-5，-17】，两部分对应的运算符为\*,这样组合1对应的最终结果为【-10，-34】,对于其他两个组合进行同样的操作

## 代码

代码需要3部分

1. 字符处理函数：将字符串拆分成运算数与运算符
2. 字符运算函数：对于给定的两个运算数及其运算符，返回运算结果
3. 递归函数：递归求出结果并返回

python代码如下

```python
class Solution:
    def diffWaysToCompute(self, expression: str) -> List[int]:
        nums,ops = self.processExpress(expression)
        return self.getRes(nums,ops)
    def processExpress(self,s):
        operaors = []
        nums = []
        allOps = ['+','-','*']
        num = ''
        for i in range(len(s)):
            if s[i] not in allOps:
                num += s[i]
            else:
                nums.append(int(num))
                num = ''
                operaors.append(s[i])
        if len(num)>0:nums.append(int(num))

        return nums,operaors
    def operationNum(self,a,b,c):
        if c=='+':return a+b
        if c=='-':return a-b
        return a*b
    def getRes(self,nums , ops):
        res = []
        if(len(nums)==1): return nums
        elif(len(nums)==2):return [self.operationNum(nums[0],nums[1],ops[0])]
        for i in range(1,len(nums)):
            res1 = self.getRes(nums[0:i],ops[0:i-1])
            res2 = self.getRes(nums[i:],ops[i:])
            for a in res1:
                for b in res2:
                    res += [self.operationNum(a,b,ops[i-1])]
        return res

```

# [208. 实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/)

难度中等1231

**[Trie](https://baike.baidu.com/item/字典树/9825209?fr=aladdin)**（发音类似 "try"）或者说 **前缀树** 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。

请你实现 Trie 类：

- `Trie()` 初始化前缀树对象。
- `void insert(String word)` 向前缀树中插入字符串 `word` 。
- `boolean search(String word)` 如果字符串 `word` 在前缀树中，返回 `true`（即，在检索之前已经插入）；否则，返回 `false` 。
- `boolean startsWith(String prefix)` 如果之前已经插入的字符串 `word` 的前缀之一为 `prefix` ，返回 `true` ；否则，返回 `false` 。

 

**示例：**

```
输入
["Trie", "insert", "search", "search", "startsWith", "insert", "search"]
[[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]
输出
[null, null, true, false, true, null, true]

解释
Trie trie = new Trie();
trie.insert("apple");
trie.search("apple");   // 返回 True
trie.search("app");     // 返回 False
trie.startsWith("app"); // 返回 True
trie.insert("app");
trie.search("app");     // 返回 True
```

 

**提示：**

- `1 <= word.length, prefix.length <= 2000`
- `word` 和 `prefix` 仅由小写英文字母组成
- `insert`、`search` 和 `startsWith` 调用次数 **总计** 不超过 `3 * 104` 次

## 思路

字典树由字典数结点构成

### 定义字典树结点

思考二叉树结点的数据结构，有两要素：本身的val、孩子结点

```java
TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
}
```

上述两个要素字典树的结点也需要具备，另外，还需要额外存放该节点是否为叶结点。类比二叉树，由于只有左右两个结点，只需定义left,right两个结点即可，而字典树的结点一般有多个，比如小写字符有26个，就需要定义一个长度为26的字典树结点数组。

* 标识该节点是否为叶子结点
* 用一个结点数组存放结点的子节点

**特殊的是，结点的值可以根据结点数组是否为空来推算，比如小写字母字典树，当root的结点数组索引为0的位置不为空时，证明字母a存在于字典树中**

```java
    class TrieNode{
        boolean end; //该节点是否为叶子结点
        TrieNode [] children = new TrieNode[26];  //每个节点默认有26个孩子结点，对应26个字母,数组长度由潜在的字符种类确定
    }
```

**另一个特殊之处是字典树的根节点本身不存放值**

```java
package com.example.book.leetcode;

/**
 * @author: modige
 * @date: 2022/7/14 22:26
 * @description:
 */
class Trie {
    TrieNode root;
    //字典树结点
    class TrieNode{
        boolean end; //该节点是否为叶子结点
        TrieNode [] children = new TrieNode[26];  //每个节点默认有26个孩子结点，对应26个字母
    }

    public Trie() {
        root = new TrieNode();
            }

    public void insert(String word) {
        TrieNode p = root;
        for(int i=0;i<word.length();i++){
            int index = word.charAt(i) - 'a';
            if(p.children[index]==null){

                p.children[index] = new TrieNode();
            }
            p = p.children[index];
        }
        p.end = true;//插入所有字母后将最后一个结点表示为叶子结点

    }

    public boolean search(String word) {
        TrieNode p = root;
        for (char c:word.toCharArray()){
            //逐字符到字典树中查找，中间有没找到的字符返回false
            int index = c - 'a';
            if(p.children[index]==null) return false;
            p = p.children[index];
        }

        return p.end;//如果遍历到的最后一个结点是叶子结点，返回true

    }

    public boolean startsWith(String prefix) {
        TrieNode p = root;
        for (char c:prefix.toCharArray()){
            //逐字符到字典树中查找，中间有没找到的字符返回false
            int index = c - 'a';
            if(p.children[index]==null) return false;
            p = p.children[index];
        }

        return true;//如果遍历到的最后一个结点是叶子结点，返回true

    }
}

/**
 * Your Trie object will be instantiated and called as such:
 * Trie obj = new Trie();
 * obj.insert(word);
 * boolean param_2 = obj.search(word);
 * boolean param_3 = obj.startsWith(prefix);
 */
```

## 深度优先

给出4个1-10的数字，通过加减乘除，得到数字为24就算胜利。

```java
import java.util.*;
 
 
public class Solution {
    /**
     * 
     * @param arr int整型一维数组 
     * @return bool布尔型
     */
    boolean flag = false;
    public boolean Game24Points (int[] arr) {
        // write code here
        dfs(arr, 1, arr[0]);
        return flag;
    }
    public void dfs(int[] arr, int start,int res){
            if(start >= arr.length){
                if(res == 24) flag = true;
                return;
            }
            dfs(arr, start+1, res+arr[start]);
            dfs(arr, start+1, res-arr[start]);
            dfs(arr, start+1, res*arr[start]);
            dfs(arr, start+1, res/arr[start]);
        }
}

```

