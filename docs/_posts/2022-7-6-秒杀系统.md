[toc]



# 秒杀逻辑

1. 商品列表

2. 商品详情      
   * 根据秒杀时间判断秒杀按钮是否点亮
   * 点击秒杀按钮
   * 该用户是否已经参与秒杀
   * 秒杀商品是否还有库存
   * 对应秒杀商品减库存
   * 生成订单
   * 生成秒杀订单
   * 
   * 跳转到支付页面
   
   思路：减少数据库访问 
   
   1. 系统初始化，把商品库存数量加载到Redis 
   2.  收到请求，Redis预减库存。库存不足，直接返回。
   3. 否则进入3，请求入队，立即返回排队中
   4. 请求出队，生成订单，减少库存 
   5. 客户端轮询，是否秒杀成功

### 新问题 Redis减库存

Redis没有做到原子性，使用分布式锁解决

**分布式锁** 进来一个线程先占位，当别的线程进来操作时，发现已经有人占位了，就会放弃或者稍后再试 线程操作执行完成后，需要调用del指令释放位子

为了防止业务执行过程中抛异常或者挂机导致del指定没法调用形成死锁，可以添加超时时间

# 秒杀系统问题

秒杀的特点就是**时间极短**、 **瞬间用户量大**。

大量的请求进来，我们需要考虑的点就很多了，**缓存雪崩**，**缓存击穿**，**缓存穿透**这些我之前提到的点都是有可能发生的，出现问题打挂DB那就很难受了，活动失败用户体验差，活动人气没了，最后背锅的还是**开发**。

## 秒杀开始前

### 按钮控制：

大家有没有发现没到秒杀前，一般按钮都是**置灰**的，只有时间到了，才能点击。

这是因为怕大家在时间快到的最后几秒秒疯狂请求服务器，然后还没到秒杀的时候基本上服务器就挂了。

这个时候就需要前端的配合，定时去请求你的后端服务器，获取最新的北京时间，到时间点再给按钮可用状态。

按钮可以点击之后也得给他置灰几秒，不然他一样在开始之后一直点的。**你敢说你们秒杀的时候不是这样的？**

### 库存预热：

**秒杀的本质，就是对库存的抢夺**，每个秒杀的用户来你都去数据库查询库存校验库存，然后扣减库存，撇开性能因素，你不觉得这样好繁琐，对业务开发人员都不友好，而且数据库顶不住啊

我们都知道数据库顶不住但是他的兄弟非关系型的数据库**Redis**能顶啊！

那不简单了，我们要开始秒杀前你通过定时任务或者运维同学**提前把商品的库存加载到Redis中**去，让整个流程都在Redis里面去做，然后等秒杀结束了，再异步的去修改库存就好了。

但是用了Redis就有一个问题了，我们上面说了我们采用**主从**，就是我们会去读取库存然后再判断然后有库存才去减库存，正常情况没问题，但是高并发的情况问题就很大了。

这里我就不画图了，我本来想画图的，想了半天我觉得语言可能更好表达一点。

**多品几遍！！！**就比如现在库存只剩下1个了，我们高并发嘛，4个服务器一起查询了发现都是还有1个，那大家都觉得是自己抢到了，就都去扣库存，那结果就变成了-3，是的只有一个是真的抢到了，别的都是超卖的。咋办？

### Lua： 

之前的文章就简单的提到了他，我今天就多一定点篇幅说一下吧。

> **Lua** 脚本功能是 Reids在 2.6 版本的最大亮点， 通过内嵌对 Lua 环境的支持， Redis 解决了长久以来不能高效地处理 **CAS** （check-and-set）命令的缺点， 并且可以通过组合使用多个命令， 轻松实现以前很难实现或者不能高效实现的模式。
>
> 两种：1， 写在客户端，优点：修改方便    2. 写在Redis

**Lua脚本是类似Redis事务，有一定的原子性，不会被其他命令插队，可以完成一些Redis事务性的操作。**这点是关键。

知道原理了，我们就写一个脚本把判断库存扣减库存的操作都写在一个脚本丢给Redis去做，那到0了后面的都Return False了是吧，一个失败了你修改一个开关，直接挡住所有的请求，然后再做后面的事情嘛。

#### 限流&降级&熔断&隔离：

这个为啥要做呢，不怕一万就怕万一，万一你真的顶不住了，**限流**，顶不住就挡一部分出去但是不能说不行，**降级**，降级了还是被打挂了，**熔断**，至少不要影响别的系统，**隔离**，你本身就独立的，但是你会调用其他的系统嘛，你快不行了你别拖累兄弟们啊。

## 秒杀开始后

### 资源静态化：

秒杀一般都是特定的商品还有页面模板，现在一般都是前后端分离的，所以页面一般都是不会经过后端的，但是前端也要自己的服务器啊，那就把能提前放入**cdn服务器**的东西都放进去，反正把所有能提升效率的步骤都做一下，减少真正秒杀时候服务器的压力。

#### 页面缓存

* 商品列表静态化
* 商品详情静态化
* 商品订单静态化
* 秒杀订单静态化

页面静态化

由跳转页面改为将页面存在redis、直接返回页面

1. 去redis查询对应的页面是否存在
2. 如果存在，直接返回以字符串形式存在的页面
3. 如果不存在，首先根据本地静态模板生成String型html，存入redis
4. 返回html

核心代码

```java
@RequestMapping(value = "/toList",produces = "text/html;charset=utf-8")
    @ResponseBody

    public String toLogin(HttpServletRequest request, HttpServletResponse
            response, Model model, @CookieValue("accountTicket") String ticket) {
        ValueOperations valueOperations = redisTemplate.opsForValue();
        //直接去redis查找，如果存在直接返回，不存在则先存进redis再返回，方便以后使用
        String html = (String)valueOperations.get("goodsList");
        if (!StringUtils.isEmpty(html)){
            return html;
        }
        Account account = accountService.getByAccountTicket(ticket,request,response);

        List<GoodsVo> goods = iGoodsService.findGoodsVo();

        model.addAttribute("user",account);
        model.addAttribute("goods",goods);
        WebContext context = new WebContext(request,response,request.getServletContext(),request.getLocale(),model.asMap());
        html = thymeleafViewResolver.getTemplateEngine().process("goodsList",context);
        System.out.println(html);
        //存进redis
        if (!StringUtils.isEmpty(html)){
            valueOperations.set("goodsList",html,60, TimeUnit.MINUTES);
        }
        return html;
    }
```

同理，将页面详情页面存入redis

#### 订单缓存

之前判断该用户是否购买过是通过查询数据库，现在将秒杀订单存进redis，判断时到redis查询结果

```java
String seckillOrderJson = (String)
                redisTemplate.opsForValue().get("order:" + user.getId() + ":" + goodsId);
if (seckillOrderJson!= null) {
            model.addAttribute("errmsg", RespBeanEnum.REPEATE_ERROR.getMessage());
            return "seckill/seckillFail";
        }
```

**需要注意的是删除订单时不要忘了将对应的订单从redis删除**



###  RabbitMQ

封装一个订单对象，

#### 生产者

将秒杀订单发送给队列

#### 消费者

接收秒杀订单，进行库存判断，生成订单并写入数据库

#### 注意

订单发送到消息队列到真正写进数据库并返回结果需要一段时间

**处理方案**：进度条、客户端轮询，到数据库查询结果

### Redis集群：

之前不是说单机的**Redis**顶不住嘛，那简单多找几个兄弟啊，秒杀本来就是读多写少，那你们是不是瞬间想起来我之前跟你们提到过的，**Redis集群**，**主从同步**、**读写分离**，我们还搞点**哨兵**，开启**持久化**直接无敌高可用！

### Nginx：

**Nginx**大家想必都不陌生了吧，这玩意是**高性能的web服务器**，并发也随便顶几万不是梦，但是我们的**Tomcat**只能顶几百的并发呀，那简单呀**负载均衡**嘛，一台服务几百，那就多搞点，在秒杀的时候多租点**流量机**。

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/16/16e72a449e417960~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

**恶意请求拦截**也需要用到它，一般单个用户请求次数太夸张，不像人为的请求在网关那一层就得拦截掉了，不然请求多了他抢不抢得到是一回事，服务器压力上去了，可能占用网络带宽或者把**服务器打崩、缓存击穿**等等。





### 限流：

* 点击秒杀之前需要输入验证码，验证码以算数计算的形式存在
* 限制IP访问次数，5秒内只允许访问5次

限流这里我觉得应该分为**前端限流**和**后端限流**。

**前端限流**：这个很简单，一般秒杀不会让你一直点的，一般都是点击一下或者两下然后几秒之后才可以继续点击，这也是保护服务器的一种手段。

**后端限流**：秒杀的时候肯定是涉及到后续的订单生成和支付等操作，但是都只是成功的幸运儿才会走到那一步，那一旦100个产品卖光了，return了一个false，前端直接秒杀结束，然后你后端也关闭后续无效请求的介入了。

Tip：真正的限流还会有限流组件的加入例如：阿里的Sentinel、Hystrix等。我这里就不展开了，就说一下物理的限流。



## 超卖

### 减库存之前判断库存是否足够

### 解决同一用户多次秒杀同一商品

1. 数据库建立唯一索引
2. 秒杀订单存入redis，查询更快捷



## 链接暴露

### 问题描述

秒杀url很容易通过抓包工具获取，竞争对手或黄牛党可以通过脚本或刷单工具发送下单请求，轻则活动还没开始商品便卖光，严重的服务器宕机，活动失败，GG。

### 解决方案

#### 秒杀链接加盐：

我们上面说了链接要是提前暴露出去可能有人直接访问url就提前秒杀了，那又有小伙伴要说了我做个时间的校验就好了呀，那我告诉你，知道链接的地址比起页面人工点击的还是有**很大优势**。

我知道url了，那我通过程序不断获取最新的北京时间，可以达到**毫秒级别**的，我就在00毫秒的时候请求，我敢说绝对比你人工点的成功率大太多了，而且我可以一毫秒发送N次请求，搞不好你卖100个产品我全拿了。


作者：敖丙
链接：https://juejin.cn/post/6844903999083151374
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## 消息队列

秒杀主要流程

![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d48a45b2a5124599acd1f96bf6365da7~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

秒杀并发量大，下单、支付并发量小

所以，我们在设计秒杀系统时，有必要把下单和支付功能从秒杀的主流程中拆分出来，特别是下单功能要做成**mq异步处理的**。而支付功能，比如支付宝支付，是业务场景本身保证的异步。

![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab1ac5478e2c40008c3d64b3ac4c17ee~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

呼应了消息队列的削峰功能。

消息队列三大应用场景（解耦、异步、削峰）

![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab1ac5478e2c40008c3d64b3ac4c17ee~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)如果使用mq，需要关注以下几个问题：

### 8.1 消息丢失问题

秒杀成功了，往mq发送下单消息的时候，有可能会失败。原因有很多，比如：网络问题、broker挂了、mq服务端磁盘问题等。这些情况，都可能会造成消息丢失。

那么，如何防止消息丢失呢？

答：加一张消息发送表。

![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3552c19d69c447fb92d8648a2300ea1c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)在生产者发送mq消息之前，先把该条消息写入消息发送表，初始状态是待处理，然后再发送mq消息。消费者消费消息时，处理完业务逻辑之后，再回调生产者的一个接口，修改消息状态为已处理。

如果生产者把消息写入消息发送表之后，再发送mq消息到mq服务端的过程中失败了，造成了消息丢失。

这时候，要如何处理呢？

答：使用job，增加重试机制。

![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f3a0f1696f84dd391a579cee00745b2~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)用job每隔一段时间去查询消息发送表中状态为待处理的数据，然后重新发送mq消息。

### 8.2 重复消费问题

本来消费者消费消息时，在ack应答的时候，如果网络超时，本身就可能会消费重复的消息。但由于消息发送者增加了重试机制，会导致消费者重复消息的概率增大。

那么，如何解决重复消息问题呢？

答：加一张消息处理表。![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0492180f81246e1acf05e938a25e8ec~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

消费者读到消息之后，先判断一下消息处理表，是否存在该消息，如果存在，表示是重复消费，则直接返回。如果不存在，则进行下单操作，接着将该消息写入消息处理表中，再返回。

有个比较关键的点是：下单和写消息处理表，要放在同一个事务中，保证原子操作。

### 8.3 垃圾消息问题

这套方案表面上看起来没有问题，但如果出现了消息消费失败的情况。比如：由于某些原因，消息消费者下单一直失败，一直不能回调状态变更接口，这样job会不停的重试发消息。最后，会产生大量的垃圾消息。

那么，如何解决这个问题呢？![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1101415a596143c7b9aba974776a2d35~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)每次在job重试时，需要先判断一下消息发送表中该消息的发送次数是否达到最大限制，如果达到了，则直接返回。如果没有达到，则将次数加1，然后发送消息。

这样如果出现异常，只会产生少量的垃圾消息，不会影响到正常的业务。

### 8.4 延迟消费问题

通常情况下，如果用户秒杀成功了，下单之后，在15分钟之内还未完成支付的话，该订单会被自动取消，回退库存。

那么，在15分钟内未完成支付，订单被自动取消的功能，要如何实现呢？

我们首先想到的可能是job，因为它比较简单。

但job有个问题，需要每隔一段时间处理一次，实时性不太好。

还有更好的方案？

答：使用延迟队列。

我们都知道rocketmq，自带了延迟队列的功能。

![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0209694409b484e843f664d8c2ec0ea~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)下单时消息生产者会先生成订单，此时状态为待支付，然后会向延迟队列中发一条消息。达到了延迟时间，消息消费者读取消息之后，会查询该订单的状态是否为待支付。如果是待支付状态，则会更新订单状态为取消状态。如果不是待支付状态，说明该订单已经支付过了，则直接返回。

还有个关键点，用户完成支付之后，会修改订单状态为已支付。

![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35957783759a40648032b548e5f655ad~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)


作者：苏三说技术
链接：https://juejin.cn/post/6990307911117307934
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## 整合Redis

报错DefaultSerializer requires a Serializable payload but received an object of type [model.Admin]

 要缓存的 Java 对象必须实现 Serializable 接口，因为 Spring 会将对象先[序列化](https://so.csdn.net/so/search?q=序列化&spm=1001.2101.3001.7020)再存入 Redis

### 解决方法:

 将缓存实体类继承 Serializable

```java
public class Admin implements Serializable
```

## Redis启动

```
redis-server.exe redis.windows.conf
```

## Redis设置密码

```
# 查看密码
config get requirepass
# 设置密码
config set requirepass 123456
```

## Redis配置

```yaml
spring:
  redis:
    #超时时间
    timeout: 10000ms
    #服务器地址
    host: localhost
    #服务器端口
    port: 6379
    #数据库
    database: 0
    #密码
    password: 123456
    lettuce:
      pool:
        #最大连接数，默认8
        max-active: 1024
        #最大连接阻塞等待时间，默认-1
        max-wait: 10000ms
        #最大空闲连接
        max-idle: 200
        #最小空闲连接
        min-idle: 5
```

## 分布式Session

* [掘金](https://juejin.cn/post/6850418120780824589)

由于系统会布置在多台服务器，用户发送请求时，Nginx会使用负载均衡策略（默认轮询）将请求发送到不同的服务器，这回导致用户刚在服务器A上登录，cookie信息也存储在服务器A上了，但如果下次被nginx分配到了服务器B，这时又要重新登陆

解决办法就是分布式session

解决办法列表：

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/17/1735a37e17e67100~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

1. Session赋值，既然Tomcat1有了，就可以复现2,3,4，（实现只需要修改Tomcat配置，不需要修改代码）
2. 前端存储：将session信息存在浏览器的cookie里、
3. Session粘滞：让nginx改用ip hash策略，这样同一个用户只请求一台服务器，session就不用复制了
4. 后端集中存储：将session存在Redis或者Mysql,

### 极简版：



将用户信息存入Redis

**原因**：Session具有过期失效的特点，不需要持久化，所以Redis这种数据存放在内存中的数据库速度比较快，同时也支持持久化。

使用的数据类型是String

## SpringBoot+Redis存放session

添加三条依赖后重启项目，此时登录即可自动将cookie保存到redis

```xml
    <!-- spring data redis 依赖 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>
        <!-- commons-pool2 对象池依赖 -->
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-pool2</artifactId>
        </dependency>
        <!-- spring-session 依赖 -->
        <dependency>
            <groupId>org.springframework.session</groupId>
            <artifactId>spring-session-data-redis</artifactId>
        </dependency>
```



**但这种方式向Redis中存放的是二进制形式的Cookie信息，可读性较差，一般自己写Redis配置类，手动定义session的序列化**

![image-20220708214634996](E:\gitfile\modiman.github.io\docs\_posts\image-20220708214634996.png)

Redis配置类RedisConfig.java

```java
package com.springboot.demo.config;

/**
 * @author: modige
 * @date: 2022/7/8 21:38
 * @description:
 */
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;

@Configuration
public class RedisConfig {
    @Bean
    public RedisTemplate<String,Object> redisTemplate(RedisConnectionFactory
                                                              connectionFactory){
        RedisTemplate<String,Object> redisTemplate = new RedisTemplate<>();
        //key序列器
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        //value序列器
        redisTemplate.setValueSerializer(new
                GenericJackson2JsonRedisSerializer());
        //Hash类型 key序列器
        redisTemplate.setHashKeySerializer(new StringRedisSerializer());
        //Hash类型 value序列器
        redisTemplate.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());
        redisTemplate.setConnectionFactory(connectionFactory);
        return redisTemplate;
    }
}

```

## 数据库分库分表

### 是什么

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2330da16bbc402e8caa72b52a767a00~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

### 为什么

## 异常处理

我们知道，系统中异常包括：编译时异常和运行时异常 RuntimeException ，前者通过捕获异常从而获 取异常信息，后者主要通过规范代码开发、测试通过手段减少运行时异常的发生。在开发中，不管是 dao层、service层还是controller层，都有可能抛出异常，在Springmvc中，能将所有类型的异常处理 从各处理过程解耦出来，既保证了相关处理过程的功能较单一，也实现了异常信息的统一处理和维护。 SpringBoot全局异常处理方式主要两种：

用 @ControllerAdvice 和 @ExceptionHandler 注解。 

使用 ErrorController类 来实现 区别： 

1. @ControllerAdvice 方式只能处理控制器抛出的异常。此时请求已经进入控制器中。 
2. ErrorController类 方式可以处理所有的异常，包括未进入控制器的错误，比如404,401等错误 
3. 如果应用中两者共同存在，则 @ControllerAdvice 方式处理控制器抛出的异常， ErrorController类 方式处理未进入控制器的异常
4. @ControllerAdvice 方式可以定义多个拦截方法，拦截不同的异常类，并且可以获取抛出的异常 信息，自由度更大。

