## 整合Redis

报错DefaultSerializer requires a Serializable payload but received an object of type [model.Admin]

 要缓存的 Java 对象必须实现 Serializable 接口，因为 Spring 会将对象先[序列化](https://so.csdn.net/so/search?q=序列化&spm=1001.2101.3001.7020)再存入 Redis

### 解决方法:

 将缓存实体类继承 Serializable

```java
public class Admin implements Serializable
```

## Redis启动

```
redis-server.exe redis.windows.conf
```

## Redis设置密码

```
# 查看密码
config get requirepass
# 设置密码
config set requirepass 123456
```

## Redis配置

```yaml
spring:
  redis:
    #超时时间
    timeout: 10000ms
    #服务器地址
    host: localhost
    #服务器端口
    port: 6379
    #数据库
    database: 0
    #密码
    password: 123456
    lettuce:
      pool:
        #最大连接数，默认8
        max-active: 1024
        #最大连接阻塞等待时间，默认-1
        max-wait: 10000ms
        #最大空闲连接
        max-idle: 200
        #最小空闲连接
        min-idle: 5
```

## SpringBoot+Redis存放session

添加三条依赖后重启项目，此时登录即可自动将cookie保存到redis

```xml
    <!-- spring data redis 依赖 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>
        <!-- commons-pool2 对象池依赖 -->
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-pool2</artifactId>
        </dependency>
        <!-- spring-session 依赖 -->
        <dependency>
            <groupId>org.springframework.session</groupId>
            <artifactId>spring-session-data-redis</artifactId>
        </dependency>
```



**但这种方式向Redis中存放的是二进制形式的Cookie信息，可读性较差，一般自己写Redis配置类，手动定义session的序列化**

![image-20220708214634996](E:\gitfile\modiman.github.io\docs\_posts\image-20220708214634996.png)

Redis配置类RedisConfig.java

```java
package com.springboot.demo.config;

/**
 * @author: modige
 * @date: 2022/7/8 21:38
 * @description:
 */
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;

@Configuration
public class RedisConfig {
    @Bean
    public RedisTemplate<String,Object> redisTemplate(RedisConnectionFactory
                                                              connectionFactory){
        RedisTemplate<String,Object> redisTemplate = new RedisTemplate<>();
        //key序列器
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        //value序列器
        redisTemplate.setValueSerializer(new
                GenericJackson2JsonRedisSerializer());
        //Hash类型 key序列器
        redisTemplate.setHashKeySerializer(new StringRedisSerializer());
        //Hash类型 value序列器
        redisTemplate.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());
        redisTemplate.setConnectionFactory(connectionFactory);
        return redisTemplate;
    }
}

```

## 秒杀逻辑

1. 商品列表
2. 商品详情      
   * 根据秒杀时间判断秒杀按钮是否点亮
   * 点击秒杀按钮
   * 该用户是否已经参与秒杀
   * 秒杀商品是否还有库存
   * 对应秒杀商品减库存
   * 生成订单
   * 生成秒杀订单
   * 跳转到支付页面
   * 

## 优化

### 页面缓存

页面静态化

由跳转页面改为将页面存在redis、直接返回页面

1. 去redis查询对应的页面是否存在
2. 如果存在，直接返回以字符串形式存在的页面
3. 如果不存在，首先根据本地静态模板生成String型html，存入redis
4. 返回html

核心代码

```java
@RequestMapping(value = "/toList",produces = "text/html;charset=utf-8")
    @ResponseBody

    public String toLogin(HttpServletRequest request, HttpServletResponse
            response, Model model, @CookieValue("accountTicket") String ticket) {
        ValueOperations valueOperations = redisTemplate.opsForValue();
        //直接去redis查找，如果存在直接返回，不存在则先存进redis再返回，方便以后使用
        String html = (String)valueOperations.get("goodsList");
        if (!StringUtils.isEmpty(html)){
            return html;
        }
        Account account = accountService.getByAccountTicket(ticket,request,response);

        List<GoodsVo> goods = iGoodsService.findGoodsVo();

        model.addAttribute("user",account);
        model.addAttribute("goods",goods);
        WebContext context = new WebContext(request,response,request.getServletContext(),request.getLocale(),model.asMap());
        html = thymeleafViewResolver.getTemplateEngine().process("goodsList",context);
        System.out.println(html);
        //存进redis
        if (!StringUtils.isEmpty(html)){
            valueOperations.set("goodsList",html,60, TimeUnit.MINUTES);
        }
        return html;
    }
```

同理，将页面详情页面存入redis
