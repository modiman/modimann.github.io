# 秒杀简介

* 这是一个模拟了高并发场景的商城系统，它具备秒杀功能，并在经过几个版本的迭代之后成为支持高并发的高性能系统。

* 为了解决秒杀场景下的高并发问题。引入了[redis]()作为缓存中间件，主要作用是缓存预热、预减库存等等。
* 针对高并发场景进行了页面优化，缓存页面至浏览器，前后端分离降低服务器压力，加快用户访问速度。
* 在安全性问题上，我使用双重MD5密码校验，隐藏了秒杀接口地址，设置了接口限流防刷。
* 最后还使用数学公式验证码不仅可以防恶意刷访问，还起到了削峰的作用。
* 通过Jmeter压力[测试]()，系统的QPS从150/s提升到2000/s。



一个实现了对活动商品进行抢购的javaWeb项目。

使用的框架是SpringBoot+mybatis+thymeleaf,数据库使用了mysql和redis

登录方面，使用redis实现分布式session,使用md进行简单的账号加密

为了加快页面加载速度，将静态资源存放在redis里

使用redis存放秒杀库存实现预减库存，在redis中使用lua脚本避免超卖现象

使用消息队列存放秒杀订单实现异步功能

压力测试

qps：2400



# 面试问题

## 项目具体实现

### 开始前

按钮**置灰**，只有时间到了，才能点击。

### 前端限流

* 图片验证码，减慢提交次数
* 5秒内只能点击一次
* 秒杀链接加盐，避免恶意请求
* 短时间内多次下单的ip，使用nginx封禁

### 资源静态化：

将公用静态资源放进redis

#### 页面缓存

* 商品列表静态化
* 商品详情静态化
* 商品订单静态化
* 秒杀订单静态化

页面静态化

由跳转页面改为将页面存在redis、直接返回页面

1. 去redis查询对应的页面是否存在
2. 如果存在，直接返回以字符串形式存在的页面
3. 如果不存在，首先根据本地静态模板生成String型html，存入redis
4. 返回html

同理，将页面详情页面存入redis

#### 订单缓存

之前判断该用户是否购买过是通过查询数据库，现在将秒杀订单存进redis，判断时到redis查询结果

```java
String seckillOrderJson = (String)
                redisTemplate.opsForValue().get("order:" + user.getId() + ":" + goodsId);
if (seckillOrderJson!= null) {
            model.addAttribute("errmsg", RespBeanEnum.REPEATE_ERROR.getMessage());
            return "seckill/seckillFail";
        }
```

**需要注意的是删除订单时不要忘了将对应的订单从redis删除**

### 预减库存



秒杀前**提前把商品的库存加载到Redis中**去，让整个流程都在Redis里面去做，然后等秒杀结束了，再异步的去修改库存就好了。

可能存在多个线程读到同样的数据，都扣减库存之后写回数据库，这就可能导致超卖现象

引入lua脚本，将读库存--减库存放在同一个脚本中，利用**同时只能执行一个脚本**的特性避免超卖

#### Lua： 

之前的文章就简单的提到了他，我今天就多一定点篇幅说一下吧。

> **Lua** 脚本功能是 Reids在 2.6 版本的最大亮点， 通过内嵌对 Lua 环境的支持， Redis 解决了长久以来不能高效地处理 **CAS** （check-and-set）命令的缺点， 并且可以通过组合使用多个命令， 轻松实现以前很难实现或者不能高效实现的模式。
>
> 两种：1， 写在客户端，优点：修改方便    2. 写在Redis

**Lua脚本是类似Redis事务，有一定的原子性，不会被其他命令插队，可以完成一些Redis事务性的操作。**这点是关键。

知道原理了，我们就写一个脚本把判断库存扣减库存的操作都写在一个脚本丢给Redis去做，那到0了后面的都Return False了是吧，一个失败了你修改一个开关，直接挡住所有的请求，然后再做后面的事情嘛。

```lua
# 判断库存键是否存在  其中keys由脚本调用者传入，keys[1]表示传进来的列表的第一项
if(redis.call('exists',KEYS[1])==1) then
    # 如果存在，将库存存放在变量stock中
    local stock =tonumber(redis.call('get',KEYS[1]));
    if(stock>0) then
        # 库存大于0 则 自减并返回
        redis.call('incrby',KEYS[1],-1);
        return stock;
    end;
        return -1;
end;
```

lua脚本预减库存并返回剩余库存

### 消息队列异步

RabbitMQ

减完库存对用户来说下单已经成功了，但对服务端来说写入mysql还需一段时间，为了让用户不用等待，只需直接给用户返回下单成功，然后把下单信息存进消息队列，后面慢慢消费写进mysql

封装一个订单对象，

#### 生产者

将秒杀订单发送给队列

#### 消费者

接收秒杀订单，进行库存判断，生成订单并写入数据库

#### 注意

订单发送到消息队列到真正写进数据库并返回结果需要一段时间

**处理方案**：进度条、客户端轮询，到数据库查询结果

### 高可用

#### Redis集群：

之前不是说单机的**Redis**顶不住嘛，那简单多找几个兄弟啊，秒杀本来就是读多写少，那你们是不是瞬间想起来我之前跟你们提到过的，**Redis集群**，**主从同步**、**读写分离**，我们还搞点**哨兵**，开启**持久化**直接无敌高可用！

#### Nginx：

**Nginx**大家想必都不陌生了吧，这玩意是**高性能的web服务器**，并发也随便顶几万不是梦，但是我们的**Tomcat**只能顶几百的并发呀，那简单呀**负载均衡**嘛，一台服务几百，那就多搞点，在秒杀的时候多租点**流量机**。

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/16/16e72a449e417960~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

**恶意请求拦截**也需要用到它，一般单个用户请求次数太夸张，不像人为的请求在网关那一层就得拦截掉了，不然请求多了他抢不抢得到是一回事，服务器压力上去了，可能占用网络带宽或者把**服务器打崩、缓存击穿**等等。

## 如何避免超卖

1. 数据库建立唯一索引
2. 秒杀订单存入redis，查询更快捷

### 新问题 Redis减库存

Redis没有做到原子性，使用分布式锁解决

**分布式锁** 进来一个线程先占位，当别的线程进来操作时，发现已经有人占位了，就会放弃或者稍后再试 线程操作执行完成后，需要调用del指令释放位子

为了防止业务执行过程中抛异常或者挂机导致del指定没法调用形成死锁，可以添加超时时间

## 消息队列

### 消息丢失

根本解决办法是加一张消息发送表。

| 丢失原因       | 解决办法                             |
| -------------- | ------------------------------------ |
| 网络故障未送达 | 发送后将消息写进发送表，状态为未送达 |
| 宕机没持久化   |                                      |
| 服务挂掉没消费 |                                      |

1. 把消息写入消息发送表，状态为未处理
2. 发送消息
3. 消费消息
4. 将消息状态改为已处理

增加一个子线程监控消息发送表，如果写入消息发送表之后消费失败，重新发送消息

### 重复消费

**原因**：成功消费后发送反馈信息发送失败，生产者误以为没有消费

**解决**：加一张消息处理表。

* 消费者读到消息之后，先判断一下消息处理表，是否存在该消息，
* 如果存在，表示是重复消费，则直接返回。
* 如果不存在，则进行下单操作，接着将该消息写入消息处理表中，再返回。

有个比较关键的点是：下单和写消息处理表，要放在同一个事务中，保证原子操作。

### 延迟消费

**背景**

* 下单但没有在限期内付款
* 下单又取消订单

**后果**：少卖

**解决**：使用延迟队列。

* 下单时消息生产者会先生成订单，此时状态为待支付，然后会向延迟队列中发一条消息。
* 达到了延迟时间，消息消费者读取消息之后，会查询该订单的状态是否为待支付。
  * 如果是待支付状态，则会更新订单状态为取消状态。
  *  如果不是待支付状态，说明该订单已经支付过了，则直接返回

还有个关键点，用户完成支付之后，会修改订单状态为已支付。

## 重复下单

* Mysql唯一性索引
* 分布式锁

## 数据一致性

缓存和数据库的数据一致性

两种场景

1. 只读缓存 使用`更新数据库+输出缓存`策略
2. 读写缓存 使用`更新数据库+更新缓存` 

* 更新数据库后删除缓存，下一次查询缓存找不到数据时会重新写入缓存

* 数据一致性

  项目比较简单，需要保证一致性就是库存和订单信息

  需要保证这两步里缓存和数据库的数据一致性

  由于使用了预减库存的处理思路，需要注意的就是在消费消息队列里的订单实际减库存这里保证一致性。

  保证缓存、数据库数据一致性有两种方式

  * 更新缓存、修改数据库(本项目做法)
  * 删除缓存、修改数据库

  对于后者

![img](https://ask.qcloudimg.com/http-save/170434/8a35bd7e3ff238b87f870b8080c61579.jpeg?imageView2/2/w/1620)

### 库存一致性

**为了避免超卖把库存存在了redis**

先更新缓存再写入数据库

1. 预减库存
2. 消费消息，Mysql减库存

### 订单一致性

**为了异步响应用户请求把秒杀订单放进了缓存**




1. 负载均衡怎么做的 
2. 项目怎么测试
3. 性能如何体现
4. 项目的网络传输 服务端发起请求需要http,http基于tcp，rabbitmq使用AMQP协议
5. jmeter压测如何
11. 秒杀时突然想增加库存怎么办


## 项目中的难点 少卖

两个场景

1. 下单未支付
2. 下单取消支付

业务难点：加库存

商务难点：用户抢到了没有买，影响别的用户体验

未支付可以使用延时队列，到时间自动加库存，同时从缓存删除之前生成的订单

秒杀订单迅速没有，秒杀结束，但实际上被秒杀的商品并未全部成交，这个问题无法避免，只能通过多次秒杀活动解决，毕竟就算下单并支付商品也未必最终成交。

# 优化方案

作者：码出宇宙
链接：https://www.nowcoder.com/discuss/966273
来源：牛客网



秒杀系统主要是有三个特点**高性能**、**高并发**、**高可用**。 

 从一次秒杀的流程出发，考虑秒杀系统的三个特点，那么就可以设计一个秒杀系统。 

##  1. 秒杀页面获取 

 优化方案： 

1.  动静分离。将页面的静态资源等部署到Nginx或者CDN，这样可以加快秒杀页面获取。 
2.  静态资源合并获取。通过将多个请求合并为单个请求，一次获取多个静态资源，这样可以加快秒杀页面获取。 
3.  服务降级。秒杀页面做服务降级处理，将商品推荐列表、评论等做降级处理，少显示或者不显示。秒杀页面需要登录才能查看，对未登录用户直接返回登录界面。 
4.  服务监控。对流量进行监控，使用令牌桶[算法]()等限流[算法]()对流量进行控制。有必要时将部分任务进行熔断。 
5.  页面[数据]()缓存。将页面[数据]()缓存到Redis中，减少[数据]()库操作。 
6.  秒杀连接加盐。使URL动态化，可以减少非法用户操作。 

##  2. 商品下单 

 优化方案： 

1.  前端/后端限流。前端/客户端防抖。限制时间间隔内的下单次数。 
2.  防机器人刷单。对下单操作增加填写验证码步骤，如：55+44=？、“你好”的小写拼音、选出所有飞机等问题，将非法请求过滤掉。 
3.  商品下单预扣库存。[数据]()库表设计的时候需要设置锁库存字段。进行秒杀的时候，减少库存将在Redis中使用分布式锁进行操作。其它后续操作可以使用RabbitMQ进行操作。 
4.  商品下单预扣库存（库存预热）可以添加延时队列。将超时商品转发到死信路由，然后进行操作。 
5.  商品下单可以进行异步操作，如双次验价等操作可以使用多线程。 

##  3. 支付 

 优化方案： 

1.  将支付划分为一个单独的系统，只开放对应的支付接口。因为支付系统是金融敏感的，所以应该保证支付系统的高可用。 
2.  回滚机制。建议使用分布式事务，对支付业务进行TCC事务，因为支付系统是金融敏感的。 

------

 于是，秒杀系统一般会引入MQ、Redis、MySQL、Nginx等中间件，需要对每个中间件进行**高性能**、**高并发**、**高可用**的分析。 

## 4.接口地址隐藏

先生成path再存进数据库，再查询。为什么这么做？

* 将接口路径与`用户id`+`商品id`绑定，防止机器人重复请求 

1. 前端请求得到真实path，将参数goodid传到后台`SeckillController.getPath()`
2. getPath(User user, Long goodsId)做如下处理
   1. 如果用户为空，表示没登录，返回错误
   2. 调用`orderService.createPath(user,goodsId)`方法生成一条用户、商品专属path
      1. `createPah`调用MD5Util.md5生成一条唯一路径，并存进redis
      2. 返回生成的路径
   3. 返回唯一路径id
3. 前端获取到后台生成的id，想后台的`doSeckill`方法发起请求
4. `doSeckill`调用` orderService.checkPath(user,goodsId,path);`检查路径是否正确
   1. checkpath判断用户是否登录
   2. 到redis获取user+goodid对应的path
   3. 与形参中的path对比是否相同
5. 检验成功，继续下一步逻辑

##  MQ 

 优化方案： 

1.  集群部署。MQ系统一般都是集群部署的，进行镜像集群部署，可以提升系统的可用性。 
2.  开启持久化。对MQ系统中的信息开启持久化，将其刷到硬盘内，防止宕机。 
3.  关闭消费自动ACK，需要进行手动ACK。防止信息消费异常。 

##  Redis 

 优化方案： 

1.  Redis进行读写分离，Master节点进行写操作，其他节点进行读操作。 
2.  Redis进行哨兵部署，让某一个节点宕机后可以迅速有机器顶替上。 
3.  Redis进行分片集群部署，让请求分布到每一台Redis机器上。 
4.  开启持久化日志。AOF和RDB根据业务状况进行调整。 
5.  一个系统可以有多个Redis集群，例如页面[数据]()和商品下单两个方面的Redis可以用多个集群的Redis。 

##  MySQL 

 优化方案： 

1.  根据业务建立索引。唯一索引、普通索引、联合索引等。 
2.  看业务是否有优化的地方，减少回表操作。 
3.  分库分表。MySQL应该进行集群部署，单台Redis一般只有2000QPS左右。 
   1.  分库。使用MyCat或者ShardingSphere等进行分库，将操作通过[算法]()分配到相对应的机器上面。 
   2.  分表。分表有垂直划分和水平划分两种。垂直划分是将部分字段分割到其它表上面。水平划分是将[数据]()水平划分到同一[数据]()库中的不同表上面，避免一个表上面的[数据]()过大。 
   3.  一般来说，建议分32个库，每个库分32张表，这样完全能够满足大部分企业的需求。 
4.  MySQL的瓶颈是磁盘IO，可以更换固态硬盘。 

##  Nginx 

 优化方案： 

1.  动静分离。将静态资源部署到Nginx中，无需到其它中间件中查询。 
2.  Nginx可以开启限流操作。令牌桶和露铜[算法]()都支持。 
3.  Nginx开启负载均衡，将服务请求打到不同的服务器上，降低单台服务器压力。 

------

 除了上面列出来的，还有很多的优化操作。 

##  热点[数据]()分离 

 热点商品和普通商品使用的系统可以隔离开来，这样即使秒杀系统宕机了，普通的商品下单也不会有任何问题。 

1.  秒杀商品放到热点[数据]()系统内。 
2.  直播商品也可以放到热点[数据]()系统内。 
3.  流量监控。可以将下单比较多的商品放到热点[数据]()系统内。 
4.  商家上报。商家可以将未来可能售卖较多的商品上报，放到热点[数据]()系统内。 
5.  [数据]()分析。分析以往[数据]()，得出一些未来可能售卖较多的商品，放到热点[数据]()系统内。 

------

##  性能优化 

 最后可以进行机器上面的性能优化。 

1.  更换CPU 
2.  更换内存 
3.  更换速度更快的硬盘 
4.  更新Linux系统内核 
5.  更新软件系统稳定版本 
6.  关闭Linux上面一些无用的服务



## 整合Redis

报错DefaultSerializer requires a Serializable payload but received an object of type [model.Admin]

 要缓存的 Java 对象必须实现 Serializable 接口，因为 Spring 会将对象先[序列化](https://so.csdn.net/so/search?q=序列化&spm=1001.2101.3001.7020)再存入 Redis

### 解决方法:

 将缓存实体类继承 Serializable

```java
public class Admin implements Serializable
```

## Redis启动

```
redis-server.exe redis.windows.conf
```

## Redis设置密码

```
# 查看密码
config get requirepass
# 设置密码
config set requirepass 123456
```

## Redis配置

```yaml
spring:
  redis:
    #超时时间
    timeout: 10000ms
    #服务器地址
    host: localhost
    #服务器端口
    port: 6379
    #数据库
    database: 0
    #密码
    password: 123456
    lettuce:
      pool:
        #最大连接数，默认8
        max-active: 1024
        #最大连接阻塞等待时间，默认-1
        max-wait: 10000ms
        #最大空闲连接
        max-idle: 200
        #最小空闲连接
        min-idle: 5
```

## 分布式Session

* [掘金](https://juejin.cn/post/6850418120780824589)

由于系统会布置在多台服务器，用户发送请求时，Nginx会使用负载均衡策略（默认轮询）将请求发送到不同的服务器，这回导致用户刚在服务器A上登录，cookie信息也存储在服务器A上了，但如果下次被nginx分配到了服务器B，这时又要重新登陆

解决办法就是分布式session

解决办法列表：

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/17/1735a37e17e67100~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

1. Session赋值，既然Tomcat1有了，就可以复现2,3,4，（实现只需要修改Tomcat配置，不需要修改代码）
2. 前端存储：将session信息存在浏览器的cookie里、
3. Session粘滞：让nginx改用ip hash策略，这样同一个用户只请求一台服务器，session就不用复制了
4. 后端集中存储：将session存在Redis或者Mysql,

### 极简版：



将用户信息存入Redis

**原因**：Session具有过期失效的特点，不需要持久化，所以Redis这种数据存放在内存中的数据库速度比较快，同时也支持持久化。

使用的数据类型是String

## SpringBoot+Redis存放session

添加三条依赖后重启项目，此时登录即可自动将cookie保存到redis

```xml
    <!-- spring data redis 依赖 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>
        <!-- commons-pool2 对象池依赖 -->
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-pool2</artifactId>
        </dependency>
        <!-- spring-session 依赖 -->
        <dependency>
            <groupId>org.springframework.session</groupId>
            <artifactId>spring-session-data-redis</artifactId>
        </dependency>
```



**但这种方式向Redis中存放的是二进制形式的Cookie信息，可读性较差，一般自己写Redis配置类，手动定义session的序列化**

![image-20220708214634996](E:\gitfile\modiman.github.io\docs\_posts\image-20220708214634996.png)

Redis配置类RedisConfig.java

```java
package com.springboot.demo.config;

/**
 * @author: modige
 * @date: 2022/7/8 21:38
 * @description:
 */
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;

@Configuration
public class RedisConfig {
    @Bean
    public RedisTemplate<String,Object> redisTemplate(RedisConnectionFactory
                                                              connectionFactory){
        RedisTemplate<String,Object> redisTemplate = new RedisTemplate<>();
        //key序列器
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        //value序列器
        redisTemplate.setValueSerializer(new
                GenericJackson2JsonRedisSerializer());
        //Hash类型 key序列器
        redisTemplate.setHashKeySerializer(new StringRedisSerializer());
        //Hash类型 value序列器
        redisTemplate.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());
        redisTemplate.setConnectionFactory(connectionFactory);
        return redisTemplate;
    }
}

```

## 数据库分库分表

### 是什么

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2330da16bbc402e8caa72b52a767a00~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

### 为什么

## 异常处理

我们知道，系统中异常包括：编译时异常和运行时异常 RuntimeException ，前者通过捕获异常从而获 取异常信息，后者主要通过规范代码开发、测试通过手段减少运行时异常的发生。在开发中，不管是 dao层、service层还是controller层，都有可能抛出异常，在Springmvc中，能将所有类型的异常处理 从各处理过程解耦出来，既保证了相关处理过程的功能较单一，也实现了异常信息的统一处理和维护。 SpringBoot全局异常处理方式主要两种：

用 @ControllerAdvice 和 @ExceptionHandler 注解。 

使用 ErrorController类 来实现 区别： 

1. @ControllerAdvice 方式只能处理控制器抛出的异常。此时请求已经进入控制器中。 
2. ErrorController类 方式可以处理所有的异常，包括未进入控制器的错误，比如404,401等错误 
3. 如果应用中两者共同存在，则 @ControllerAdvice 方式处理控制器抛出的异常， ErrorController类 方式处理未进入控制器的异常
4. @ControllerAdvice 方式可以定义多个拦截方法，拦截不同的异常类，并且可以获取抛出的异常 信息，自由度更大。

# 秒杀逻辑

## 登录

1. 输入账号密码，提交
2. 后台根据手机号查询数据库，根据MD5解析密码并比较
3. 如果正确，生成cookies，写入redis，返回登陆成功
4. 否则返回登录失败
5. 登陆成功跳转到商品详情

## 商品详情

1. 首先到redis查询是否有已经缓存的商品页面，如果有，直接返回，因为商品详情不涉及库存信息，所以所有用户可以共享同一个页面且不用更新
2. 如果没有，查询数据库，读取商品信息，渲染成页面，生成对应的model,同时保存用户id
3. 写入redis，数据结构为String,键为url,值为html
4. 返回商品详情页，展示商品详情，
5. 前端js判断，如果商品参加秒杀活动且当前在秒杀活动期间，按钮点亮
6. 点击秒杀按钮

## 秒杀

1. 验证秒杀路径信息，用户名是否存在，商品id是否合法？
2. 判断是否重复抢购，查看redis中是否已经存在该用户该商品的订单，如果是，返回重复抢购，结束
3. 判断库存是否为空，若是，返回空库，结束
4. 调用lua脚本到redis预减库存，返回当前库存
5. 如果当前库存<0,记录当前商品已经空库存，返回空库存，结束
6. 不满足上述条件，生成秒杀订单
7. 写进消息队列，返回成功

## 消息队列

1. 消息队列一直监听队列情况，

2. 从消息队列取出一条秒杀订单消息

3. 根据消息生成订单

4. 是否有库存

5. 是否重复抢购

6. 下单

   * 秒杀商品表 库存-1
   * 库存判断
   * 生成商品订单，写进数据库
   * 生成秒杀订单，写进数据库
   * 将该用户该商品的秒杀订单写进redis

   

思路：减少数据库访问 

1. 系统初始化，把商品库存数量加载到Redis 
2. 收到请求，Redis预减库存。库存不足，直接返回。
3. 否则进入3，请求入队，立即返回排队中
4. 请求出队，生成订单，减少库存 
5. 客户端轮询，是否秒杀成功



**这里引入消息队列是因为reids减完库存写入数据库的问题**，redis的QPS可以达到10w,而MySQL为5k左右，问题在于在redis减完库存之后，需要生成秒杀订单，这一步是要等写入mysql之后再返回结果还是先放进队列直接为用户返回秒杀成功。

这里选择消息队列起到的是异步的作用，因为对于用户来说，只要redis成功扣掉库存就可以认为秒杀成功了，后面的写进数据库的步骤与他无关，是管理员需要关心的，所以不用等待这一步完成之后再为用户返回结果（写入数据库需要时间代价，这并不需要用户负担）。

等消息队列中的秒杀消息被处理成秒杀订单并写入数据库之后再给用户发送一条短信提示下单成功，至此全过程结束。

