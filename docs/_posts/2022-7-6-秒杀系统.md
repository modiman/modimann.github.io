[toc]

# 面试问题

1. 项目如何优化 

2. 并发场景如何优化

3. 负载均衡怎么做的 

4. 项目怎么测试

5. 性能如何体现

6. 项目的网络传输 服务端发起请求需要http,http基于tcp，rabbitmq使用AMQP协议

7. 介绍一下项目的难点 

8.  库存没卖完怎么办（少卖） 就是有用户下单然后并没有付款，如何加库存

8. jmeter压测如何

8. 消息队列的作用

8. 如何减库存的

8. 秒杀时突然想增加库存怎么办

   

# 秒杀逻辑

## 登录

1. 输入账号密码，提交
2. 后台根据手机号查询数据库，根据MD5解析密码并比较
3. 如果正确，生成cookies，写入redis，返回登陆成功
4. 否则返回登录失败
5. 登陆成功跳转到商品详情

## 商品详情

1. 首先到redis查询是否有已经缓存的商品页面，如果有，直接返回，因为商品详情不涉及库存信息，所以所有用户可以共享同一个页面且不用更新
2. 如果没有，查询数据库，读取商品信息，渲染成页面，生成对应的model,同时保存用户id
3. 写入redis，数据结构为String,键为url,值为html
4. 返回商品详情页，展示商品详情，
5. 前端js判断，如果商品参加秒杀活动且当前在秒杀活动期间，按钮点亮
6. 点击秒杀按钮

## 秒杀

1. 验证秒杀路径信息，用户名是否存在，商品id是否合法？
2. 判断是否重复抢购，查看redis中是否已经存在该用户该商品的订单，如果是，返回重复抢购，结束
3. 判断库存是否为空，若是，返回空库，结束
4. 调用lua脚本到redis预减库存，返回当前库存
5. 如果当前库存<0,记录当前商品已经空库存，返回空库存，结束
6. 不满足上述条件，生成秒杀订单
7. 写进消息队列，返回成功

## 消息队列

1. 消息队列一直监听队列情况，

2. 从消息队列取出一条秒杀订单消息

3. 根据消息生成订单

4. 是否有库存

5. 是否重复抢购

6. 下单

   * 秒杀商品表 库存-1
   * 库存判断
   * 生成商品订单，写进数据库
   * 生成秒杀订单，写进数据库
   * 将该用户该商品的秒杀订单写进redis

   

思路：减少数据库访问 

1. 系统初始化，把商品库存数量加载到Redis 
2. 收到请求，Redis预减库存。库存不足，直接返回。
3. 否则进入3，请求入队，立即返回排队中
4. 请求出队，生成订单，减少库存 
5. 客户端轮询，是否秒杀成功



**这里引入消息队列是因为reids减完库存写入数据库的问题**，redis的QPS可以达到10w,而MySQL为5k左右，问题在于在redis减完库存之后，需要生成秒杀订单，这一步是要等写入mysql之后再返回结果还是先放进队列直接为用户返回秒杀成功。

这里选择消息队列起到的是异步的作用，因为对于用户来说，只要redis成功扣掉库存就可以认为秒杀成功了，后面的写进数据库的步骤与他无关，是管理员需要关心的，所以不用等待这一步完成之后再为用户返回结果（写入数据库需要时间代价，这并不需要用户负担）。

等消息队列中的秒杀消息被处理成秒杀订单并写入数据库之后再给用户发送一条短信提示下单成功，至此全过程结束。





# 秒杀系统问题

秒杀的特点就是**时间极短**、 **瞬间用户量大**。

大量的请求进来，我们需要考虑的点就很多了，**缓存雪崩**，**缓存击穿**，**缓存穿透**这些我之前提到的点都是有可能发生的，出现问题打挂DB那就很难受了，活动失败用户体验差，活动人气没了，最后背锅的还是**开发**。

## 秒杀开始前

### 按钮控制：

大家有没有发现没到秒杀前，一般按钮都是**置灰**的，只有时间到了，才能点击。

### 库存预热：

**秒杀的本质，就是对库存的抢夺**，每个秒杀的用户来你都去数据库查询库存校验库存，然后扣减库存，撇开性能因素，你不觉得这样好繁琐，对业务开发人员都不友好，而且数据库顶不住啊

我们都知道数据库顶不住但是他的兄弟非关系型的数据库**Redis**能顶啊！

那不简单了，我们要开始秒杀前你通过定时任务或者运维同学**提前把商品的库存加载到Redis中**去，让整个流程都在Redis里面去做，然后等秒杀结束了，再异步的去修改库存就好了。

但是用了Redis就有一个问题了，我们上面说了我们采用**主从**，就是我们会去读取库存然后再判断然后有库存才去减库存，正常情况没问题，但是高并发的情况问题就很大了。

这里我就不画图了，我本来想画图的，想了半天我觉得语言可能更好表达一点。

**多品几遍！！！**就比如现在库存只剩下1个了，我们高并发嘛，4个服务器一起查询了发现都是还有1个，那大家都觉得是自己抢到了，就都去扣库存，那结果就变成了-3，是的只有一个是真的抢到了，别的都是超卖的。咋办？

### Lua： 

之前的文章就简单的提到了他，我今天就多一定点篇幅说一下吧。

> **Lua** 脚本功能是 Reids在 2.6 版本的最大亮点， 通过内嵌对 Lua 环境的支持， Redis 解决了长久以来不能高效地处理 **CAS** （check-and-set）命令的缺点， 并且可以通过组合使用多个命令， 轻松实现以前很难实现或者不能高效实现的模式。
>
> 两种：1， 写在客户端，优点：修改方便    2. 写在Redis

**Lua脚本是类似Redis事务，有一定的原子性，不会被其他命令插队，可以完成一些Redis事务性的操作。**这点是关键。

知道原理了，我们就写一个脚本把判断库存扣减库存的操作都写在一个脚本丢给Redis去做，那到0了后面的都Return False了是吧，一个失败了你修改一个开关，直接挡住所有的请求，然后再做后面的事情嘛。

#### 限流&降级&熔断&隔离：

这个为啥要做呢，不怕一万就怕万一，万一你真的顶不住了，**限流**，顶不住就挡一部分出去但是不能说不行，**降级**，降级了还是被打挂了，**熔断**，至少不要影响别的系统，**隔离**，你本身就独立的，但是你会调用其他的系统嘛，你快不行了你别拖累兄弟们啊。

## 秒杀开始后

### 资源静态化：

秒杀一般都是特定的商品还有页面模板，现在一般都是前后端分离的，所以页面一般都是不会经过后端的，但是前端也要自己的服务器啊，那就把能提前放入**cdn服务器**的东西都放进去，反正把所有能提升效率的步骤都做一下，减少真正秒杀时候服务器的压力。

#### 页面缓存

* 商品列表静态化
* 商品详情静态化
* 商品订单静态化
* 秒杀订单静态化

页面静态化

由跳转页面改为将页面存在redis、直接返回页面

1. 去redis查询对应的页面是否存在
2. 如果存在，直接返回以字符串形式存在的页面
3. 如果不存在，首先根据本地静态模板生成String型html，存入redis
4. 返回html

同理，将页面详情页面存入redis

#### 订单缓存

之前判断该用户是否购买过是通过查询数据库，现在将秒杀订单存进redis，判断时到redis查询结果

```java
String seckillOrderJson = (String)
                redisTemplate.opsForValue().get("order:" + user.getId() + ":" + goodsId);
if (seckillOrderJson!= null) {
            model.addAttribute("errmsg", RespBeanEnum.REPEATE_ERROR.getMessage());
            return "seckill/seckillFail";
        }
```

**需要注意的是删除订单时不要忘了将对应的订单从redis删除**



###  RabbitMQ

封装一个订单对象，

#### 生产者

将秒杀订单发送给队列

#### 消费者

接收秒杀订单，进行库存判断，生成订单并写入数据库

#### 注意

订单发送到消息队列到真正写进数据库并返回结果需要一段时间

**处理方案**：进度条、客户端轮询，到数据库查询结果

### Redis集群：

之前不是说单机的**Redis**顶不住嘛，那简单多找几个兄弟啊，秒杀本来就是读多写少，那你们是不是瞬间想起来我之前跟你们提到过的，**Redis集群**，**主从同步**、**读写分离**，我们还搞点**哨兵**，开启**持久化**直接无敌高可用！

### Nginx：

**Nginx**大家想必都不陌生了吧，这玩意是**高性能的web服务器**，并发也随便顶几万不是梦，但是我们的**Tomcat**只能顶几百的并发呀，那简单呀**负载均衡**嘛，一台服务几百，那就多搞点，在秒杀的时候多租点**流量机**。

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/16/16e72a449e417960~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

**恶意请求拦截**也需要用到它，一般单个用户请求次数太夸张，不像人为的请求在网关那一层就得拦截掉了，不然请求多了他抢不抢得到是一回事，服务器压力上去了，可能占用网络带宽或者把**服务器打崩、缓存击穿**等等。





### 限流：

* 点击秒杀之前需要输入验证码，验证码以算数计算的形式存在
* 限制IP访问次数，5秒内只允许访问5次

限流这里我觉得应该分为**前端限流**和**后端限流**。

**前端限流**：这个很简单，一般秒杀不会让你一直点的，一般都是点击一下或者两下然后几秒之后才可以继续点击，这也是保护服务器的一种手段。

**后端限流**：秒杀的时候肯定是涉及到后续的订单生成和支付等操作，但是都只是成功的幸运儿才会走到那一步，那一旦100个产品卖光了，return了一个false，前端直接秒杀结束，然后你后端也关闭后续无效请求的介入了。

Tip：真正的限流还会有限流组件的加入例如：阿里的Sentinel、Hystrix等。我这里就不展开了，就说一下物理的限流。



## 超卖

### 减库存之前判断库存是否足够

### 解决同一用户多次秒杀同一商品

1. 数据库建立唯一索引
2. 秒杀订单存入redis，查询更快捷

### 新问题 Redis减库存

Redis没有做到原子性，使用分布式锁解决

**分布式锁** 进来一个线程先占位，当别的线程进来操作时，发现已经有人占位了，就会放弃或者稍后再试 线程操作执行完成后，需要调用del指令释放位子

为了防止业务执行过程中抛异常或者挂机导致del指定没法调用形成死锁，可以添加超时时间

## 链接暴露

### 问题描述

秒杀url很容易通过抓包工具获取，竞争对手或黄牛党可以通过脚本或刷单工具发送下单请求，轻则活动还没开始商品便卖光，严重的服务器宕机，活动失败，GG。

### 解决方案

#### 秒杀链接加盐：

我们上面说了链接要是提前暴露出去可能有人直接访问url就提前秒杀了，那又有小伙伴要说了我做个时间的校验就好了呀，那我告诉你，知道链接的地址比起页面人工点击的还是有**很大优势**。

我知道url了，那我通过程序不断获取最新的北京时间，可以达到**毫秒级别**的，我就在00毫秒的时候请求，我敢说绝对比你人工点的成功率大太多了，而且我可以一毫秒发送N次请求，搞不好你卖100个产品我全拿了。


作者：敖丙
链接：https://juejin.cn/post/6844903999083151374
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## 消息队列

秒杀主要流程

![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d48a45b2a5124599acd1f96bf6365da7~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

秒杀并发量大，下单、支付并发量小

所以，我们在设计秒杀系统时，有必要把下单和支付功能从秒杀的主流程中拆分出来，特别是下单功能要做成**mq异步处理的**。而支付功能，比如支付宝支付，是业务场景本身保证的异步。

![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab1ac5478e2c40008c3d64b3ac4c17ee~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

呼应了消息队列的削峰功能。

消息队列三大应用场景（解耦、异步、削峰）

![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab1ac5478e2c40008c3d64b3ac4c17ee~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)如果使用mq，需要关注以下几个问题：

### 8.1 消息丢失问题

秒杀成功了，往mq发送下单消息的时候，有可能会失败。原因有很多，比如：网络问题、broker挂了、mq服务端磁盘问题等。这些情况，都可能会造成消息丢失。

那么，如何防止消息丢失呢？

答：加一张消息发送表。

![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3552c19d69c447fb92d8648a2300ea1c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)在生产者发送mq消息之前，先把该条消息写入消息发送表，初始状态是待处理，然后再发送mq消息。消费者消费消息时，处理完业务逻辑之后，再回调生产者的一个接口，修改消息状态为已处理。

如果生产者把消息写入消息发送表之后，再发送mq消息到mq服务端的过程中失败了，造成了消息丢失。

这时候，要如何处理呢？

答：使用job，增加重试机制。

![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f3a0f1696f84dd391a579cee00745b2~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)用job每隔一段时间去查询消息发送表中状态为待处理的数据，然后重新发送mq消息。

### 8.2 重复消费问题

本来消费者消费消息时，在ack应答的时候，如果网络超时，本身就可能会消费重复的消息。但由于消息发送者增加了重试机制，会导致消费者重复消息的概率增大。

那么，如何解决重复消息问题呢？

答：加一张消息处理表。![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0492180f81246e1acf05e938a25e8ec~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

消费者读到消息之后，先判断一下消息处理表，是否存在该消息，如果存在，表示是重复消费，则直接返回。如果不存在，则进行下单操作，接着将该消息写入消息处理表中，再返回。

有个比较关键的点是：下单和写消息处理表，要放在同一个事务中，保证原子操作。

### 8.3 垃圾消息问题

这套方案表面上看起来没有问题，但如果出现了消息消费失败的情况。比如：由于某些原因，消息消费者下单一直失败，一直不能回调状态变更接口，这样job会不停的重试发消息。最后，会产生大量的垃圾消息。

那么，如何解决这个问题呢？![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1101415a596143c7b9aba974776a2d35~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)每次在job重试时，需要先判断一下消息发送表中该消息的发送次数是否达到最大限制，如果达到了，则直接返回。如果没有达到，则将次数加1，然后发送消息。

这样如果出现异常，只会产生少量的垃圾消息，不会影响到正常的业务。

### 8.4 延迟消费问题

通常情况下，如果用户秒杀成功了，下单之后，在15分钟之内还未完成支付的话，该订单会被自动取消，回退库存。

那么，在15分钟内未完成支付，订单被自动取消的功能，要如何实现呢？

我们首先想到的可能是job，因为它比较简单。

但job有个问题，需要每隔一段时间处理一次，实时性不太好。

还有更好的方案？

答：使用延迟队列。

我们都知道rocketmq，自带了延迟队列的功能。

![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0209694409b484e843f664d8c2ec0ea~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)下单时消息生产者会先生成订单，此时状态为待支付，然后会向延迟队列中发一条消息。达到了延迟时间，消息消费者读取消息之后，会查询该订单的状态是否为待支付。如果是待支付状态，则会更新订单状态为取消状态。如果不是待支付状态，说明该订单已经支付过了，则直接返回。

还有个关键点，用户完成支付之后，会修改订单状态为已支付。

![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35957783759a40648032b548e5f655ad~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)


作者：苏三说技术
链接：https://juejin.cn/post/6990307911117307934
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



# 优化方案

作者：码出宇宙
链接：https://www.nowcoder.com/discuss/966273
来源：牛客网



秒杀系统主要是有三个特点**高性能**、**高并发**、**高可用**。 

 从一次秒杀的流程出发，考虑秒杀系统的三个特点，那么就可以设计一个秒杀系统。 

##  1. 秒杀页面获取 

 优化方案： 

1.  动静分离。将页面的静态资源等部署到Nginx或者CDN，这样可以加快秒杀页面获取。 
2.  静态资源合并获取。通过将多个请求合并为单个请求，一次获取多个静态资源，这样可以加快秒杀页面获取。 
3.  服务降级。秒杀页面做服务降级处理，将商品推荐列表、评论等做降级处理，少显示或者不显示。秒杀页面需要登录才能查看，对未登录用户直接返回登录界面。 
4.  服务监控。对流量进行监控，使用令牌桶[算法]()等限流[算法]()对流量进行控制。有必要时将部分任务进行熔断。 
5.  页面[数据]()缓存。将页面[数据]()缓存到Redis中，减少[数据]()库操作。 
6.  秒杀连接加盐。使URL动态化，可以减少非法用户操作。 

##  2. 商品下单 

 优化方案： 

1.  前端/后端限流。前端/客户端防抖。限制时间间隔内的下单次数。 
2.  防机器人刷单。对下单操作增加填写验证码步骤，如：55+44=？、“你好”的小写拼音、选出所有飞机等问题，将非法请求过滤掉。 
3.  商品下单预扣库存。[数据]()库表设计的时候需要设置锁库存字段。进行秒杀的时候，减少库存将在Redis中使用分布式锁进行操作。其它后续操作可以使用RabbitMQ进行操作。 
4.  商品下单预扣库存（库存预热）可以添加延时队列。将超时商品转发到死信路由，然后进行操作。 
5.  商品下单可以进行异步操作，如双次验价等操作可以使用多线程。 

##  3. 支付 

 优化方案： 

1.  将支付划分为一个单独的系统，只开放对应的支付接口。因为支付系统是金融敏感的，所以应该保证支付系统的高可用。 
2.  回滚机制。建议使用分布式事务，对支付业务进行TCC事务，因为支付系统是金融敏感的。 

------

 于是，秒杀系统一般会引入MQ、Redis、MySQL、Nginx等中间件，需要对每个中间件进行**高性能**、**高并发**、**高可用**的分析。 

##  MQ 

 优化方案： 

1.  集群部署。MQ系统一般都是集群部署的，进行镜像集群部署，可以提升系统的可用性。 
2.  开启持久化。对MQ系统中的信息开启持久化，将其刷到硬盘内，防止宕机。 
3.  关闭消费自动ACK，需要进行手动ACK。防止信息消费异常。 

##  Redis 

 优化方案： 

1.  Redis进行读写分离，Master节点进行写操作，其他节点进行读操作。 
2.  Redis进行哨兵部署，让某一个节点宕机后可以迅速有机器顶替上。 
3.  Redis进行分片集群部署，让请求分布到每一台Redis机器上。 
4.  开启持久化日志。AOF和RDB根据业务状况进行调整。 
5.  一个系统可以有多个Redis集群，例如页面[数据]()和商品下单两个方面的Redis可以用多个集群的Redis。 

##  MySQL 

 优化方案： 

1.  根据业务建立索引。唯一索引、普通索引、联合索引等。 
2.  看业务是否有优化的地方，减少回表操作。 
3.  分库分表。MySQL应该进行集群部署，单台Redis一般只有2000QPS左右。 
   1.  分库。使用MyCat或者ShardingSphere等进行分库，将操作通过[算法]()分配到相对应的机器上面。 
   2.  分表。分表有垂直划分和水平划分两种。垂直划分是将部分字段分割到其它表上面。水平划分是将[数据]()水平划分到同一[数据]()库中的不同表上面，避免一个表上面的[数据]()过大。 
   3.  一般来说，建议分32个库，每个库分32张表，这样完全能够满足大部分企业的需求。 
4.  MySQL的瓶颈是磁盘IO，可以更换固态硬盘。 

##  Nginx 

 优化方案： 

1.  动静分离。将静态资源部署到Nginx中，无需到其它中间件中查询。 
2.  Nginx可以开启限流操作。令牌桶和露铜[算法]()都支持。 
3.  Nginx开启负载均衡，将服务请求打到不同的服务器上，降低单台服务器压力。 

------

 除了上面列出来的，还有很多的优化操作。 

##  热点[数据]()分离 

 热点商品和普通商品使用的系统可以隔离开来，这样即使秒杀系统宕机了，普通的商品下单也不会有任何问题。 

1.  秒杀商品放到热点[数据]()系统内。 
2.  直播商品也可以放到热点[数据]()系统内。 
3.  流量监控。可以将下单比较多的商品放到热点[数据]()系统内。 
4.  商家上报。商家可以将未来可能售卖较多的商品上报，放到热点[数据]()系统内。 
5.  [数据]()分析。分析以往[数据]()，得出一些未来可能售卖较多的商品，放到热点[数据]()系统内。 

------

##  性能优化 

 最后可以进行机器上面的性能优化。 

1.  更换CPU 
2.  更换内存 
3.  更换速度更快的硬盘 
4.  更新Linux系统内核 
5.  更新软件系统稳定版本 
6.  关闭Linux上面一些无用的服务



## 整合Redis

报错DefaultSerializer requires a Serializable payload but received an object of type [model.Admin]

 要缓存的 Java 对象必须实现 Serializable 接口，因为 Spring 会将对象先[序列化](https://so.csdn.net/so/search?q=序列化&spm=1001.2101.3001.7020)再存入 Redis

### 解决方法:

 将缓存实体类继承 Serializable

```java
public class Admin implements Serializable
```

## Redis启动

```
redis-server.exe redis.windows.conf
```

## Redis设置密码

```
# 查看密码
config get requirepass
# 设置密码
config set requirepass 123456
```

## Redis配置

```yaml
spring:
  redis:
    #超时时间
    timeout: 10000ms
    #服务器地址
    host: localhost
    #服务器端口
    port: 6379
    #数据库
    database: 0
    #密码
    password: 123456
    lettuce:
      pool:
        #最大连接数，默认8
        max-active: 1024
        #最大连接阻塞等待时间，默认-1
        max-wait: 10000ms
        #最大空闲连接
        max-idle: 200
        #最小空闲连接
        min-idle: 5
```

## 分布式Session

* [掘金](https://juejin.cn/post/6850418120780824589)

由于系统会布置在多台服务器，用户发送请求时，Nginx会使用负载均衡策略（默认轮询）将请求发送到不同的服务器，这回导致用户刚在服务器A上登录，cookie信息也存储在服务器A上了，但如果下次被nginx分配到了服务器B，这时又要重新登陆

解决办法就是分布式session

解决办法列表：

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/17/1735a37e17e67100~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

1. Session赋值，既然Tomcat1有了，就可以复现2,3,4，（实现只需要修改Tomcat配置，不需要修改代码）
2. 前端存储：将session信息存在浏览器的cookie里、
3. Session粘滞：让nginx改用ip hash策略，这样同一个用户只请求一台服务器，session就不用复制了
4. 后端集中存储：将session存在Redis或者Mysql,

### 极简版：



将用户信息存入Redis

**原因**：Session具有过期失效的特点，不需要持久化，所以Redis这种数据存放在内存中的数据库速度比较快，同时也支持持久化。

使用的数据类型是String

## SpringBoot+Redis存放session

添加三条依赖后重启项目，此时登录即可自动将cookie保存到redis

```xml
    <!-- spring data redis 依赖 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>
        <!-- commons-pool2 对象池依赖 -->
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-pool2</artifactId>
        </dependency>
        <!-- spring-session 依赖 -->
        <dependency>
            <groupId>org.springframework.session</groupId>
            <artifactId>spring-session-data-redis</artifactId>
        </dependency>
```



**但这种方式向Redis中存放的是二进制形式的Cookie信息，可读性较差，一般自己写Redis配置类，手动定义session的序列化**

![image-20220708214634996](E:\gitfile\modiman.github.io\docs\_posts\image-20220708214634996.png)

Redis配置类RedisConfig.java

```java
package com.springboot.demo.config;

/**
 * @author: modige
 * @date: 2022/7/8 21:38
 * @description:
 */
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;

@Configuration
public class RedisConfig {
    @Bean
    public RedisTemplate<String,Object> redisTemplate(RedisConnectionFactory
                                                              connectionFactory){
        RedisTemplate<String,Object> redisTemplate = new RedisTemplate<>();
        //key序列器
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        //value序列器
        redisTemplate.setValueSerializer(new
                GenericJackson2JsonRedisSerializer());
        //Hash类型 key序列器
        redisTemplate.setHashKeySerializer(new StringRedisSerializer());
        //Hash类型 value序列器
        redisTemplate.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());
        redisTemplate.setConnectionFactory(connectionFactory);
        return redisTemplate;
    }
}

```

## 数据库分库分表

### 是什么

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2330da16bbc402e8caa72b52a767a00~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

### 为什么

## 异常处理

我们知道，系统中异常包括：编译时异常和运行时异常 RuntimeException ，前者通过捕获异常从而获 取异常信息，后者主要通过规范代码开发、测试通过手段减少运行时异常的发生。在开发中，不管是 dao层、service层还是controller层，都有可能抛出异常，在Springmvc中，能将所有类型的异常处理 从各处理过程解耦出来，既保证了相关处理过程的功能较单一，也实现了异常信息的统一处理和维护。 SpringBoot全局异常处理方式主要两种：

用 @ControllerAdvice 和 @ExceptionHandler 注解。 

使用 ErrorController类 来实现 区别： 

1. @ControllerAdvice 方式只能处理控制器抛出的异常。此时请求已经进入控制器中。 
2. ErrorController类 方式可以处理所有的异常，包括未进入控制器的错误，比如404,401等错误 
3. 如果应用中两者共同存在，则 @ControllerAdvice 方式处理控制器抛出的异常， ErrorController类 方式处理未进入控制器的异常
4. @ControllerAdvice 方式可以定义多个拦截方法，拦截不同的异常类，并且可以获取抛出的异常 信息，自由度更大。

