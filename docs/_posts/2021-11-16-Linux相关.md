[toc]



## 1. 系统操作

### 1.1 cmd打开服务器

ssh 用户名@主机名

```bash
ssh omnisky@172.21.7.94
```

### 1.2 Screen命令

打开一个新的screen

```
screen -S screen_name
```

恢复screen 

```
screen -r screen_name
screen -d -r screen_name
```

查看当前是否在screen中

```
echo $STY
```

查看所有的screen

```
screen -ls
```

删除screen

```
screen -S session_name -X quit
```









### 1.3 conda离线安装

将anaconda安装包复制到本机

配置环境变量

```bash
export PATH=/home/hm/anaconda3/bin:$PATH
```

### 1.4 新建用户

```bash
adduser hm
```

### 1.5 查看内存使用情况

```bash
free -m
```



## 2. 文件操作

### 2.1 传输文件

Linux scp 命令用于 Linux 之间复制文件和目录。

**本地复制到远程服务器**

```bash
scp local_file remote_username@remote_ip:remote_folder 
# 将本地名为HeMeng 的文件夹复制到地址为172.21.7.94的主机的/home/omnisky/hm目录下，
scp -rp ./HeMeng 172.21.7.94:/home/omnisky/hm
# 两个路径调转则变为从远程主机下载到本地
```



### 2.2 删除文件夹

```bash
rm -rf filedir
```

该命令会直接删除文件夹，不会给出警告信息和提示

* 有提示

```bash
rm -i filename
```

* 无提示

```bash
rm -f filename
或
rm filename
```

### 2.3查看所有文件，包括隐藏的

```bash
ls -a
```

### 2.4批量删除文件

```bash
# 所有以aaa开头的文件
rm -rf aaa*
```

### 2.5 解压

* https://cloud.tencent.com/developer/article/1404921

```bash
# 解压：
unzip FileName.zip
# 压缩：
zip FileName.zip DirName
```

=======

### 2.6读取文本并输出

```bash
cat input.txt
```

### 2.7 修改文件/文件夹名

```bash
mv 原名 改后名
# 例
mv '安装包' packages
```

### 2.8 移动文件

```bash
mv 要移动的文件  目标路径
# 例
mv test.txt  /home/modige/document
```



## 2020 11 06 几个shell命令的使用

1. awk '{print $1}' sam.log|uniq -c|sort -g|tail -10

用空格切割字符串并取第一项，去重并显示每条出现次数，按出现次数排序，取前十 （awk命令用来按行切割文本中的字符串，默认以空格为分隔符 print $1 代表输出切分后的第一项 sam.log是被处理的文件名 uniq 命令指去除重复的行， -c代表 显示每行出现过的次数 没有文件名时默认以标准输出作为输入 sort 指排序 tail -10 取最后10项）

2. grep GET sam.log |awk '{print $1}' sam.log|uniq -c|sort -g|tail -5

筛选出含“GET“ 的行，。。。 (grep GET　sam.log命令指筛选出文件sam.log中含＂ＧＥＴ＂的字符串)

3. awk '{print $4}' sam.log |cut -c 14-18|uniq -c|sort -g|tail -5 取出时间所在的项，切出时，分，去重，排序

4. cut -d '"' sam.log -f 4 |cut -d '/' -f 3| sort | uniq -c 用 “ 切割每一行，取第四项，用 / 切割，取第三项 去重

# 各类软件安装

## Redis

1. 将压缩包放到想放的位置

2. 解压  

   ```bash
   tar xzvf redis-6.2.3.tar.gz
   ```

   

3. 进入redis根目录

   ```bash
    cd redis-6.2.3
   ```

4. 

   ```bash
   make
   ```

   如果这一步出错，改用

   ```bash
   make MALLOC=libc
   ```

5. 此时在根目录下已经可以启动服务

   ```bash
   redis-server  # 启动服务器
   redis-cli   # 启动客户端
   ```

6. 添加环境变量以便从任意路径启动

   ```bash
   echo "export REDIS_HOME=/home/modige/softs/redis-6.2.3" >>/etc/profile
   echo "export PTAH=$PATH:$REDIS_HOME" >>/etc/profile
   ```

   ## 备份与恢复

   https://www.runoob.com/redis/redis-backup.html

# IO

# [六大进程通信](https://zhuanlan.zhihu.com/p/465574868)



![img](https://pic2.zhimg.com/v2-05357079c73568813ec18658a5e803c1_b.jpg)

**一. 什么是进程通信**

顾名思义，进程通信（ InterProcess Communication，IPC）就是指**进程之间的信息交换**。

* 实际上，**进程的同步与互斥本质上也是一种进程通信**，只不过它传输的仅仅是[信号量](https://www.zhihu.com/search?q=信号量&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"465574868"})，通过修改信号量，使得进程之间建立联系，相互协调和协同工作，但是它**缺乏传递数据的能力**。
* 但是大多数情况下，**进程之间需要交换大批数据**，比如传送一批信息或整个文件，这就需要通过一种新的通信机制来完成，也就是所谓的进程通信。
* 再来从操作系统层面直观的看一些进程通信：我们知道，为了保证安全，每个进程的用户地址空间都是独立的，一般而言一个进程不能直接访问另一个进程的地址空间，不过内核空间是每个进程都共享的，所以**进程之间想要进行信息交换就必须通过内核**。![img](https://pic2.zhimg.com/v2-1c0a8bc38f13325491ab6a8b0f781be1_b.jpg)
  

二. 管道

1. **匿名管道**
   * Linux 管道使用竖线 | 连接多个命令，这被称为管道符。它的功能是将前一个命令（command1）的输出，作为后一个命令（command2）的输入，
   * 从这个功能描述中，我们可以看出**管道中的数据只能单向流动**，也就是半双工通信，
   * 如果想实现相互通信（全双工通信），我们需要创建两个管道才行。
   * 另外，通过管道符 | 创建的管道是匿名管道，用完了就会被自动销毁。
   * 并且，匿名管道只能在具有亲缘关系（父子进程）的进程间使用，。也就是说，**匿名管道只能用于父子进程之间的通信**。
   * 我们来理解下管道的本质是什么：对于管道两端的进程而言，管道就是一个文件（这也就是为啥管道也被称为共享文件机制的原因了)，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在于内存中。
   * 简单来说，**管道的本质就是内核在内存中开辟了一个缓冲区，这个缓冲区与管道文件相关联，对管道文件的操作，被内核转换成对这块缓冲区的操作**。
2. **有名管道**
   * 匿名管道由于没有名字，只能用于父子进程间的通信。
   * 为了克服这个缺点，提出了有名管道，也称做 FIFO，因为数据是先进先出的传输方式。
   * 所谓有名管道也就是提供一个路径名与之关联，这样，即使与创建有名管道的进程不存在亲缘关系的进程，只要可以访问该路径，就能够通过这个有名管道进行相互通信。
   * 使用 Linux 命令 mkfifo 来创建有名管道：
   * 管道这种进程通信方式虽然使用简单，但是效率比较低，不适合进程间频繁地交换数据，并且管道只能传输无格式的[字节流](https://www.zhihu.com/search?q=字节流&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"465574868"})**。**
   

三、消息队列

为此，消息传递机制（Linux 中称消息队列）应用而生。比如，A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程在需要的时候自行去消息队列中读取数据就可以了。同样的，B 进程要给 A 进程发送消息也是如此。![img](https://pic1.zhimg.com/v2-a2caf6e76f9407a1752a220080b10134_b.jpg)

* **消息队列的本质就是存放在内存中的消息的链表，而消息本质上是用户自定义的数据结构**。
* 如果进程从消息队列中读取了某个消息，这个消息就会被从消息队列中删除。
* 对比一下管道机制：消息队列允许一个或多个进程向它写入或读取消息。消息队列可以实现消息的**随机查询**，不一定非要以先进先出的次序读取消息，也可以按消息的类型读取。比有名管道的先进先出原则更有优势。

四. 共享内存

为了避免像消息队列那样频繁的拷贝消息、进行系统调用，共享内存机制出现了。

* 顾名思义，共享内存就是允许不相干的进程将同一段物理内存连接到它们各自的地址空间中，使得这些进程可以访问同一个物理内存，这个物理内存就成为共享内存。

* 如果某个进程向共享内存写入数据，所做的改动将**立即**影响到可以访问同一段共享内存的任何其他进程。

  

  

  

五. 信号量和 PV 操作

* 实际上，对具有多 CPU 系统的最新研究表明，在这类系统上，消息传递的性能其实是要优于共享内存的，因为**消息队列无需避免冲突，而共享内存机制可能会发生冲突**。
* 题，保证共享内存在任何时刻只有一个进程在访问（互斥），并且使得进程们能够按照某个特定顺序访问共享内存（同步)，我们就可以使用进程的同步与互斥机制，常见的比如信号量与 PV 操作。**进程的同步与互斥其实是一种对进程通信的保护机制，并不是用来传输进程之间真正通信的内容的，但是由于它们会传输信号量，所以也被纳入进程通信的范畴，称为低级通信**。下面的内容和上篇文章【看完了进程同步与互斥机制，我终于彻底理解了 PV 操作】中所讲的差不多，看过的小伙伴可直接跳到下一标题。信号量其实就是一个变量 ，我们可以用一个信号量来表示系统中某种资源的数量，比如：系统中只有一台打印机，就可以设置一个初值为 1 的信号量。用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而很方便的实现进程互斥或同步。这一对原语就是 PV 操作：1）**P 操作**：将信号量值唤醒进程**？答：所谓唤醒进程是从就绪队列（[阻塞队列](https://www.zhihu.com/search?q=阻塞队列&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"465574868"})）中唤醒进程，而信号量的值大于 0 表示有共享资源可供使用，也就是说这个时候没有进程被阻塞在这个资源上，所以不需要唤醒，正常运行即可。问：**信号量的值 等于 0 的时候表示没有共享资源可供使用，为什么还要唤醒进程**？答：V 操作是先执行信号量值加 1 的，也就是说，把信号量的值加 1 后才变成了 0，在此之前，信号量的值是 -1，即有一个进程正在等待这个共享资源，我们需要唤醒它
* 

七. Socket

**至此，上面介绍的 5 种方法都是用于同一台主机上的进程之间进行通信的，如果想要**跨网络与不同主机上的进程进行通信**，那该怎么做呢？这就是 Socket 通信做的事情了

**总结**

1. 首先，最简单的方式就是**管道**，管道的本质是存放在内存中的特殊的文件。也就是说，内核在内存中开辟了一个缓冲区，这个缓冲区与管道文件相关联，对管道文件的操作，被内核转换成对这块缓冲区的操作。管道分为匿名管道和有名管道，匿名管道只能在父子进程之间进行通信，而有名管道没有限制。
2. 虽然管道使用简单，但是效率比较低，不适合进程间频繁地交换数据，并且管道只能传输无格式的字节流。为此**消息队列**应用而生。消息队列的本质就是存放在内存中的消息的链表，而消息本质上是用户自定义的数据结构。如果进程从消息队列中读取了某个消息，这个消息就会被从消息队列中删除。
3. 消息队列的速度比较慢，因为每次数据的写入和读取都需要经过用户态与内核态之间数据的拷贝过程，**共享内存**可以解决这个问题。所谓共享内存就是：两个不同进程的逻辑地址通过页表映射到物理空间的同一区域，它们所共同指向的这块区域就是共享内存。如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。对于共享内存机制来说，仅在建立共享内存区域时需要系统调用，一旦建立共享内存，所有的访问都可作为常规内存访问，无需借助内核。这样，数据就不需要在进程之间来回拷贝，所以这是最快的一种进程通信方式。
4. 共享内存速度虽然非常快，但是存在冲突问题，为此，我们可以使用信号量和 PV 操作来实现对共享内存的互斥访问，并且还可以实现进程同步。
5. **信号**和信号量是完全不同的两个概念！信号是进程通信机制中唯一的异步通信机制，它可以在任何时候发送信号给某个进程。通过发送指定信号来通知进程某个异步事件的发送，以迫使进程执行信号处理程序。信号处理完毕后，被中断进程将恢复执行。用户、内核和进程都能生成和发送信号。
6. 上面介绍的 5 种方法都是用于同一台主机上的进程之间进行通信的，如果想要跨网络与不同主机上的进程进行通信，就需要使用 **Socket** 通信。另外，Socket 也能完成同主机上的进程通信。

## Linux安装mongoDB

参考官网教程：https://docs.mongodb.com/manual/tutorial/install-mongodb-on-ubuntu/

* 错误1：E: Unable to locate package mongodb-org     http://corpus.hubwiz.com/2/node.js/28945921.html

* 错误2： Create this directory or give existing directory in --dbpath. 

​	缺乏数据库存储路径

​	创建一个新的文件夹

```bash
#回到根目录
mkdir -p /data/db    创建/data/db
# 分配访问权限
sudo chown -R  `whoami` /data

```

* 错误3

mongod 命令执行发现已经有进程在运行mongod数据库--errno:48 Address already in use for socket: 0.0.0.0:27017

找到占用进程并终止

```bash
ps aux | grep mongod

kill -9 进程号
```

### 启动（windows）

* https://www.runoob.com/mongodb/mongodb-window-install.html

​	首先创建数据存储路径（需要在根目录下）

* 在E盘下依次建立data\db文件夹
* 找到mongodb安装目录，进入bin路径下
* 地址栏下输入cmd进入命令行窗口
* 输入命令

```bat
C:\Program Files\MongoDB\Server\5.0\bin> mongod --dbpath E:\data\db
```

<img src="E:\gitfile\notes\就业\imgs\image-20211109164730773.png">

此时启动成功，可以使用mongodb桌面版连接

### 数据备份与恢复

将本地数据库转存到数据库

如果本地没有安装mongodump.exe与mongorestore.exe，需要提前安装

下载地址（https://www.mongodb.com/try/download/database-tools）

默认安装路径C:\Program Files\MongoDB\Tools\100\bin

进入该路径，进入cmd窗口

### 数据备份

```bash
mongodump -h dbhost -d dbname -o dbdirectory
```

### 数据恢复

```bash
mongorestore -h <hostname><:port> -d dbname <path>
```

 

- --host <:port>, -h <:port>：

  MongoDB所在服务器地址，默认为： localhost:27017

- --db , -d ：

  需要恢复的数据库实例，例如：test，当然这个名称也可以和备份时候的不一样，比如test2

- --drop：

  恢复的时候，先删除当前数据，然后恢复备份的数据。就是说，恢复后，备份后添加修改的数据都会被删除，慎用哦！

- <path>：

  mongorestore 最后的一个参数，设置备份数据所在位置，例如：c:\data\dump\test。

  你不能同时指定 <path> 和 --dir 选项，--dir也可以设置备份目录。

- --dir：

  指定备份的目录

  你不能同时指定 <path> 和 --dir 选项

执行完成后发现path下多了一个数据库同名文件夹

**如果报错，加-drop参数**



### 常见错误

* code=exited, status=14

https://askubuntu.com/questions/823288/mongodb-loads-but-breaks-returning-status-14

### 数据操作

* <a href="https://www.runoob.com/python3/python-mongodb-query-document.html">菜鸟教程</a>

