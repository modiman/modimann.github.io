# 数据集

## ogbl-biokg

### 概述

ogbl-biokg数据集是一个知识图(kg)，它是我们使用大量生物医学数据仓库的数据创建的。它包含5种类型的实体:

| 结点类型 | 疾病  | 蛋白质 | 药物  | 副作用 | 蛋白质功能 |
| -------- | ----- | ------ | ----- | ------ | ---------- |
| 结点数量 | 10687 | 17499  | 10533 | 9969   | 45085      |

### 关系


连接两类实体的有向关系共有51种，包括39种药物-药物相互作用、8种蛋白质-蛋白质相互作用，以及药物-蛋白质、药物-副作用、药物-蛋白质、功能-功能关系。所有关系都被建模为有向边，其中连接相同实体类型(例如，蛋白质-蛋白质、药物-药物、功能-功能)的关系总是对称的，即边是双向的。

### 研究意义

该数据集与生物医学和基础ML研究都相关。在生物医学方面，该数据集使我们能够更好地了解人类生物学，并生成可以指导下游生物医学研究的预测。在最基本的最大似然方面，数据集在处理可能有矛盾观测值的噪声、不完整的KG时带来了挑战。这是因为ogbl-biokg数据集涉及从分子规模(例如，细胞内的蛋白质-蛋白质相互作用)到整个群体(例如，特定国家患者经历的不良副作用的报告)的异质性相互作用。此外，KG中的三元组来自具有各种置信水平的来源，包括实验读数、人工辅助注释和自动提取的元数据。

### 预测任务:

任务是预测给定训练三元组的新三元组。评估协议与ogbl-wiki G2完全相同，只是这里我们只考虑针对相同类型的实体进行排名。例如，当腐蚀蛋白质类型的头部实体时，我们只考虑负蛋白质实体。

### 数据集分割

对于这个数据集，我们采用随机分割。虽然根据时间分割三元组是一个有吸引力的选择，但我们注意到，获得关于三元组背后的单个实验和观察是何时进行的准确信息是非常具有挑战性的。我们努力在OGB的未来版本中提供额外的数据集分割



### 数据载入方法

```python
from ogb.linkproppred import PygLinkPropPredDataset

dataset = PygLinkPropPredDataset(name = d_name) 

split_edge = dataset.get_edge_split()
train_edge, valid_edge, test_edge = split_edge["train"], split_edge["valid"], split_edge["test"]
graph = dataset[0] # pyg graph object containing only training edges
```

dataset存储形式

```json
dataset[0]=
{
    'edge_index_dict':
    {
        ('disease', 'disease-protein', 'protein'): array([[ 1718, ...,   1198],  [ 3207...,1962]]), 
		('drug', 'drug-disease', 'disease'): array([[1411 ...,  679], [1402, ...,  2416]]),
			...(共51行，对应51个关系)  

    }，
	'edge_feat_dict': None,
	'node_feat_dict': None,
	'num_nodes_dict': {'disease': 10687, 'drug': 10533, 'function': 45085, 'protein': 17499, 'sideeffect': 9969},
		
	'edge_reltype': {('disease', 'disease-protein', 'protein'): array([[0],  [0],  ...
       [0]]), ('drug', 'drug-disease', 'disease'): array([[1],       [1],...
                                                          
 }

}
dataset只包含一张图biokg，故长度为1;
dataset[0]包含5个key                                                   
```

### 变量名解释

The library-agnostic graph object is a dictionary containing the following keys: `edge_index`, `edge_feat`, `node_feat`, and `num_nodes`, which are detailed below.

- `edge_index`:形状为(2, num_edges)的numpy数组，一列表示一个边，第一行、第二行表示头、尾节点的索引，无向边表示为双向边
- `edge_feat`: 形状为(num_edges, edgefeat_dim)的numpy数组， `edgefeat_dim`是边特征的维度，一行表示一个边的特征，如果没有输入，
- `node_feat`: numpy ndarray of shape `(num_nodes, nodefeat_dim)`, where `nodefeat_dim` is the dimensionality of node features and i-th row represents the feature of i-th node. This can be `None` if no input node features are available.
- `num_nodes`: 图节点数量

**Heterogeneous graph:** We represent a heterogeneous graph using dictionaries: `edge_index_dict`, `edge_feat_dict`, `node_feat_dict`, and `num_nodes_dict`.

- `edge_index_dict`:将三元组映射为与 `edge_index`.相关的字典
- `edge_feat_dict`: A dictionary mapping each triplet `(head type, relation type, tail type)` into corresponding `edge_feat`.
- `node_feat_dict`: A dictionary mapping each `node type` into corresponding `node_feat`.
- `num_nodes_dict`: A dictionary mapping each `node type` into corresponding `num_nodes`.

**Note:** 一些图形数据集可能在节点或边中包含额外的元信息，例如它们的时间戳。尽管它们没有作为默认输入特征给出，但研究人员应该可以随意利用这些附加信息



# 日记

## 1-11

* 运行pairRE提供的代码，提示没有ogb包



## 1-12 

解决昨天的报错
昨天以为装上了，实际装obg失败了，原因是卡在了torch安装这一步
今天单独安装torch ，因为是在windows上配置环境，在安装torch时按选择没有cuda的cpu-only版本
命令

```
conda install pytorch torchvision torchaudio cpuonly -c pytorch

```

网上说一般人学习只用cpu-only的torch版本就可以，希望没问题
pairre模型用的是16G显存的显卡，试试我的amd cpu顶不顶
现在在下数据集，希望能成功，
运行失败，源代码调用了cuda，本机没有

从run.py看代码

代码细节

### defaultdict

```python
from collections import defaultdict

train_count, train_true_head, train_true_tail = defaultdict(lambda: 4), defaultdict(list), defaultdict(list)

```

defaultdict区别于普通的dict
对于普通的dict，调用不存在的键值对时会报错

```python
>>> a = dict()
>>> a['name'] = 'modige'
>>> print(a['name'])
modige
>>> print(a['age'])
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 'age'

```

但对于defaultdict

```python
>>> b = defaultdict(list)
>>> print(b['age'])
[]
>>> c = defaultdict(tuple)
>>> print(c['age'])
()
```

可以看出，但调用不存在的key时会返回一个形参类型的空结果

### tqdm

Tqdm 是一个快速，可扩展的Python进度条，可以在 Python 长循环中添加一个进度提示信息，用户只需要封装任意的迭代器 tqdm(iterator)。



使用方法

```python
    for i in tqdm(range(len(train_triples['head']))):
        head, relation, tail = train_triples['head'][i], train_triples['relation'][i], train_triples['tail'][i]
        head_type, tail_type = train_triples['head_type'][i], train_triples['tail_type'][i]
        train_count[(head, relation, head_type)] += 1
        train_count[(tail, -relation-1, tail_type)] += 1
        train_true_head[(relation, tail)].append(head)
        train_true_tail[(head, relation)].append(tail)
```

样式如下

100%|██████████| 4762678/4762678 [00:14<00:00, 335575.16it/s]

或

```python
from tqdm import tqdm
for i in tqdm(range(1000)):

     #do something
     pass
```









### 环境 服务器149

* python 3.7.11
* torch 1.7.1
*  cuda 11.4
* ogb 1.3.2

# 1.Auto-SF 

##  1.1论文部分

### 概述 

* 数据集 OGB-biokg
* 消耗显存  9G
* 完全复现



## 1.2代码部分(run.py)

### argparse

* **https://docs.python.org/3/library/argparse.html**

命令行选项、参数和子命令的解析器

#### 打印现有参数

```pyhton
python a.py -h
#输出
usage: a.py [-h] echo ecdho

positional arguments:
  echo        dddd
  ecdho       dddd

optional arguments:
  -h, --help  show this help message and exit
```

#### 常用关键字

##### **help**

存放对参数的解释

#####  **action**

```python
import argparse
parser = argparse.ArgumentParser()
parser.add_argument("--verbose", help="increase output verbosity",
                    action="store_true")
args = parser.parse_args()
if args.verbose:
    print("verbosity turned on")
```

给关键字action赋值"store_true"，这意味着，如果指定了选项，则将值 True 分配给 args.verbose。不指定它意味着 False。

##### type

指定参数的数据类型

```python
import argparse
parser = argparse.ArgumentParser()
parser.add_argument("square", help="display a square of a given number",
                    type=int)
args = parser.parse_args()
print(args.square**2)
```

##### 短指令

可以使用```-v```代替```--verbose```

```python
import argparse
parser = argparse.ArgumentParser()
parser.add_argument("-v", "--verbose", help="increase output verbosity",
                    action="store_true")
args = parser.parse_args()
if args.verbose:
    print("verbosity turned on")
```

##### default 

不指定参数时的默认值

```python
parser.add_argument('--valid_steps', default=10000, type=int)
```

执行时没有加```--valid_steps```使用默认值10000



```python
import argparse
def parse_args(args=None):
    parser = argparse.ArgumentParser(
        description='Training and Testing Knowledge Graph Embedding Models',
        usage='train.py [<args>] [-h | --help]'
    )

    parser.add_argument('--cuda', action='store_true', help='use GPU')
    parser.add_argument('--dataset', type=str, default='ogbl-biokg', help='dataset name, default to biokg')
    ...
    return parser.parse_args(args)
```

### 主程序（main函数）逻辑

1. 判断是否指定训练/测试/验证mode(缺一不可)，没有则报错并给出提示
2. 检查是否需要从断点处恢复模型
3. 设置模型保存路径
4. 设置randomseed  
5. 载入数据集到内存
6. 分割数据集
7. 设置评价协议（ ogb自带函数）
8. 



### KGB Rotate

* 数据集 FB15K
* 显存不足无法复现

报错信息

```bash
RuntimeError: CUDA out of memory. Tried to allocate 1.95 GiB (GPU 0; 10.76 GiB total capacity; 8.44 GiB already allocated; 661.44 MiB free; 9.14 GiB reserved in total by PyTorc
```

使用nvidia-smi发现并没有进程在运行，显存也未被占用

**这说明为程序分配8.44GiB显存后无法继续分配报错，进而程序停止，就是说显卡内存不足**

* TransE模型可以试试



