



![image-20220227221134527](https://github.com/modiman/modiman.github.io/blob/gh-pages/docs/_posts/imgs/image-20220227221134527.png?raw=true)

## 1.4 与 HTTP 关系密切的协议 : IP、TCP 和 DNS

### 1.4.1 负责传输的 IP 协议

* 全称：Internet Protocol

* 位置：网络层

* 作用：是把各种数据包传送给对方。

  IP 间的通信依赖 MAC 地址。在网络上，通信的双方在同一局域网 （LAN）内的情况是很少的，通常是经过多台计算机和网络设备中转 才能连接到对方。而在进行中转时，会利用下一站中转设备的 MAC 地址来搜索下一个中转目标。这时，会采用 ARP 协议（Address Resolution Protocol）。ARP 是一种用以解析地址的协议，根据通信方 的 IP 地址就可以反查出对应的 MAC 地址。

  ![image-20220228190709300](https://github.com/modiman/modiman.github.io/blob/gh-pages/docs/_posts/imgs/image-20220228190709300.png?raw=true)

![image-20220228190709300](.\imgs\image-20220228190709300.png)

### 1.4.2 确保可靠性的 TCP 协议

* 全称：Transmission Control Protocol
* 位置：传输层
* 作用：TCP 协议为了更容易传送大数据才把数据分割，而且 TCP 协议能够确认数据最终是否送达到对方。

​       为了准确无误地将数据送达目标处，TCP 协议采用了三次握手 （three-way handshaking）策略。用 TCP 协议把数据包送出去后，TCP 不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。

![三次握手](https://github.com/modiman/modiman.github.io/blob/gh-pages/docs/_posts/imgs/三次握手.png?raw=true)

![三次握手](.\imgs\三次握手.png)

握手过程中使用了 TCP 的标志（flag） —— SYN（synchronize） 和 ACK（acknowledgement）。

发送端首先发送一个带 SYN 标志的数据包给对方。接收端收到后， 回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。最后，发 送端再回传一个带 ACK 标志的数据包，代表“握手”结束。

若在握手过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发 送相同的数据包。

## 1.5 负责域名解析的 DNS 服务

* 全称：**Domain Name System**
* 位置：应用层
* 作用：它提供域名到 IP 地址之间的解析服务。

​          用户通常使用主机名或域名来访问对方的计算机，而不是直接通过 IP 地址访问。因为与 IP 地址的一组纯数字相比，用字母配合数字的表 示形式来指定计算机名更符合人类的记忆习惯。

​           但要让计算机去理解名称，相对而言就变得困难了。因为计算机更擅 长处理一长串数字。 为了解决上述的问题，DNS 服务应运而生。DNS 协议提供通过域名 查找 IP 地址，或逆向从 IP 地址反查域名的服务。

![DNS](https://github.com/modiman/modiman.github.io/blob/gh-pages/docs/_posts/imgs/DNS.png?raw=true)

![DNS](./imgs/DNS.png?raw=true)



## 1.6 各种协议与 HTTP 协议的关系

![网络图](https://github.com/modiman/modiman.github.io/blob/gh-pages/docs/_posts/imgs/网络图.png?raw=true)



![image-20220228190709300](.\imgs\网络图.png)

## 1.7 URI 和 URL

## 2.1 HTTP 协议用于客户端和服务器端之间 的通信

## 2.1 HTTP 协议用于客户端和服务器端之间 的通信

![image-20220228190709300](.\imgs\http.png)

![网络图](https://github.com/modiman/modiman.github.io/blob/gh-pages/docs/_posts/imgs/http.png?raw=true)

1. 起始行开头的GET表示请求访问服务器的类型，称为方法 （method）。
2. 随后的字符串 /index.htm 指明了请求访问的资源对象， 也叫做请求 URI（request-URI）。
3. 最后的 HTTP/1.1，即 HTTP 的版本 号，用来提示客户端使用的 HTTP 协议功能。

 综合来看，这段请求内容的意思是：请求访问某台 HTTP 服务器上的 /index.htm 页面资源。

## 2.3 HTTP 是不保存状态的协议

![image-20220228190709300](.\imgs\httpstatus.png)

![网络图](https://github.com/modiman/modiman.github.io/blob/gh-pages/docs/_posts/imgs/httpstatus.png?raw=true)

​         **使用 HTTP 协议，每当有新的请求发送时，就会有对应的新响应产 生。协议本身并不保留之前一切的请求或响应报文的信息。这是为了 更快地处理大量事务，确保协议的可伸缩性，而特意把 HTTP 协议设 计成如此简单的。**

​            可是，随着 Web 的不断发展，因无状态而导致业务处理变得棘手的 情况增多了。比如，用户登录到一家购物网站，即使他跳转到该站的其他页面后，也需要能继续保持登录状态。针对这个实例，网站为了 能够掌握是谁送出的请求，需要保存用户的状态。

​          HTTP/1.1 虽然是无状态协议，但为了实现期望的保持状态功能，于 是引入了 Cookie 技术。有了 Cookie 再用 HTTP 协议通信，就可以管 理状态了。有关 Cookie 的详细内容稍后讲解。

## 2.4 请求 URI 定位资源

![image-20220303185556779](./imgs/locate.png)

![网络图](https://github.com/modiman/modiman.github.io/blob/gh-pages/docs/_posts/imgs/httpstatus.png?raw=true)

## 2.5 告知服务器意图的 HTTP 方法

### GET ：获取资源

GET 方法用来请求访问已被 URI 识别的资源。指定的资源经服务器 端解析后返回响应内容。也就是说，如果请求的资源是文本，那就保 持原样返回；如果是像 CGI（Common Gateway Interface，通用网关接 口）那样的程序，则返回经过执行后的输出结果。

| 请求 | GET /index.html HTTP/1.1<br>Host: www.hackr.jp <br/>If-Modified-Since: Thu, 12 Jul 2012 07:30:00 GMT |
| ---- | ------------------------------------------------------------ |
| 响应 | 仅返回2012年7 月12日7 点30分以后更新过的index.html页面资源。如果未<br/>有内容更新，则以状态码304 Not Modified作为响应返回 |



### POST：传输实体主体

​       POST 方法用来传输实体的主体。 虽然用 GET 方法也可以传输实体的主体，但一般不用 GET 方法进行 传输，而是用 POST 方法。虽说 POST 的功能与 GET 很相似，但 POST 的主要目的并不是获取响应的主体内容。

| 请求 | OST /submit.cgi HTTP/1.1 <br>Host: www.hackr.jp <br/>Content-Length: 1560（1560字节的数据） |
| ---- | ------------------------------------------------------------ |
| 响应 | 返回 submit.cgi 接收数据的处理结果                           |

### PUT：传输文件

PUT 方法用来传输文件。就像 FTP 协议的文件上传一样，要求在请 求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置。

​         但是，鉴于 HTTP/1.1 的 PUT 方法自身不带验证机制，任何人都可以 上传文件 , 存在安全性问题，因此一般的 Web 网站不使用该方法。若 配合 Web 应用程序的验证机制，或架构设计采用 REST（REpresentational State Transfer，表征状态转移）标准的同类 Web 网站，就可能会开放使用 PUT 方法。

更多操作请求OST /submit.cgi HTTP/1.1 <br>Host: www.hackr.jp <br/>Content-Length: 1560（1560字节的数据）响应返回 submit.cgi 接收数据的处理结果

| 请求 | PUT /example.html HTTP/1.1 Host: www.hackr.jp        <br/>Content-Type: text/html  <br/>Content-Length: 1560（1560 字节的数据） |
| ---- | ------------------------------------------------------------ |
| 响应 | 响应返回状态码 204 No  <br/>Content（比如 ：该 html 已存在于服务器上 |

### HEAD：获得报文首部

![网络图](https://github.com/modiman/modiman.github.io/blob/gh-pages/docs/_posts/imgs/head.png?raw=true)



<img src="./imgs/head.png"/>

| 请求 | HEAD /index.html HTTP/1.1 Host: www.hackr.jp |
| ---- | -------------------------------------------- |
| 响应 | 返回index.html有关的响应首部                 |

### DELETE：删除文件

DELETE 方法用来删除文件，是与 PUT 相反的方法。DELETE 方法按 请求 URI 删除指定的资源。

但是，HTTP/1.1 的 DELETE 方法本身和 PUT 方法一样不带验证机 制，所以一般的 Web 网站也不使用 DELETE 方法。当配合 Web 应用 程序的验证机制，或遵守 REST 标准时还是有可能会开放使用的。

![网络图](https://github.com/modiman/modiman.github.io/blob/gh-pages/docs/_posts/imgs/delete.png?raw=true)

![网络图](./imgs/delete.png?raw=true)

### OPTIONS：询问支持的方法

OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法。

![](https://github.com/modiman/modiman.github.io/blob/gh-pages/docs/_posts/imgs/option.png?raw=true)

![](./imgs/option.png?raw=true)

### TRACE：追踪路径 

TRACE 方法是让 Web 服务器端将之前的请求通信环回给客户端的方 法。

![](https://github.com/modiman/modiman.github.io/blob/gh-pages/docs/_posts/imgs/trace.png?raw=true)

![](./imgs/trace.png?raw=true)

### CONNECT：要求用隧道协议连接代理

​        CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协 议进行 TCP 通信。主要使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容 加 密后经网络隧道传输。

![](https://github.com/modiman/modiman.github.io/blob/gh-pages/docs/_posts/imgs/connect.png?raw=true)

![](./imgs/connect.png?raw=true)

## 2.6 使用方法下达命令

## 2.7 持久连接节省通信量

HTTP 协议的初始版本中，每进行一次 HTTP 通信就要断开一次 TCP 连接。

​        以当年的通信情况来说，因为都是些容量很小的文本传输，所以即使 这样也没有多大问题。可随着 HTTP 的普及，文档中包含大量图片的 情况多了起来。 比如，使用浏览器浏览一个包含多张图片的 HTML页面时，在发送 请求访问 HTML页面资源的同时，也会请求该 HTML页面里包含的 其他资源。因此，每次的请求都会造成无谓的 TCP 连接建立和断 开，增加通信量的开销。

![](https://github.com/modiman/modiman.github.io/blob/gh-pages/docs/_posts/imgs/persis.png?raw=true)

![](./imgs/persis.png?raw=true)

## 2.8 使用 Cookie 的状态管理

保留无状态协议这个特征的同时又要解决类似的矛盾问题，于是引入 了 Cookie 技术。Cookie 技术通过在请求和响应报文中写入 Cookie 信 息来控制客户端的状态。 

Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的 首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器 发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出 去。

 服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一 个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前 的状态信息。

![](https://github.com/modiman/modiman.github.io/blob/gh-pages/docs/_posts/imgs/0cookie.png?raw=true)

![](./imgs/0cookie.png?raw=true)

![](https://github.com/modiman/modiman.github.io/blob/gh-pages/docs/_posts/imgs/1cookie.png?raw=true)

![zz](./imgs/1cookie.png?raw=true)

![](https://github.com/modiman/modiman.github.io/blob/gh-pages/docs/_posts/imgs/cookie.png?raw=true)

![zz](./imgs/cookie.png?raw=true)

# 第 3 章 HTTP 报文内的 HTTP 信息

