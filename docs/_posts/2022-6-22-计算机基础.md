# 操作系统

### 进程调度

1. 先到先服务
2. 最短作业优先
3. 时间片轮转
4. 优先级

### 中断

中断是指计算机运行过程中，出现某些意外情况需主机干预时，机器能自动停止正在运行的程序并转入处理新情况的程序，处理完毕后又返回原被暂停的程序继续运行。

### 死锁必要条件

（1） 互斥条件：一个资源每次只能被一个进程使用。

（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。

（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。

（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

**避免死锁**：银行家算法

# [六大进程通信](https://zhuanlan.zhihu.com/p/465574868)



![img](https://pic2.zhimg.com/v2-05357079c73568813ec18658a5e803c1_b.jpg)

**一. 什么是进程通信**

顾名思义，进程通信（ InterProcess Communication，IPC）就是指**进程之间的信息交换**。

* 实际上，**进程的同步与互斥本质上也是一种进程通信**，只不过它传输的仅仅是[信号量](https://www.zhihu.com/search?q=信号量&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"465574868"})，通过修改信号量，使得进程之间建立联系，相互协调和协同工作，但是它**缺乏传递数据的能力**。
* 但是大多数情况下，**进程之间需要交换大批数据**，比如传送一批信息或整个文件，这就需要通过一种新的通信机制来完成，也就是所谓的进程通信。
* 再来从操作系统层面直观的看一些进程通信：我们知道，为了保证安全，每个进程的用户地址空间都是独立的，一般而言一个进程不能直接访问另一个进程的地址空间，不过内核空间是每个进程都共享的，所以**进程之间想要进行信息交换就必须通过内核**。![img](https://pic2.zhimg.com/v2-1c0a8bc38f13325491ab6a8b0f781be1_b.jpg)

二. 管道

1. **匿名管道**
   * Linux 管道使用竖线 | 连接多个命令，这被称为管道符。它的功能是将前一个命令（command1）的输出，作为后一个命令（command2）的输入，
   * 从这个功能描述中，我们可以看出**管道中的数据只能单向流动**，也就是半双工通信，
   * 如果想实现相互通信（全双工通信），我们需要创建两个管道才行。
   * 另外，通过管道符 | 创建的管道是匿名管道，用完了就会被自动销毁。
   * 并且，匿名管道只能在具有亲缘关系（父子进程）的进程间使用，。也就是说，**匿名管道只能用于父子进程之间的通信**。
   * 我们来理解下管道的本质是什么：对于管道两端的进程而言，管道就是一个文件（这也就是为啥管道也被称为共享文件机制的原因了)，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在于内存中。
   * 简单来说，**管道的本质就是内核在内存中开辟了一个缓冲区，这个缓冲区与管道文件相关联，对管道文件的操作，被内核转换成对这块缓冲区的操作**。
2. **有名管道**
   * 匿名管道由于没有名字，只能用于父子进程间的通信。
   * 为了克服这个缺点，提出了有名管道，也称做 FIFO，因为数据是先进先出的传输方式。
   * 所谓有名管道也就是提供一个路径名与之关联，这样，即使与创建有名管道的进程不存在亲缘关系的进程，只要可以访问该路径，就能够通过这个有名管道进行相互通信。
   * 使用 Linux 命令 mkfifo 来创建有名管道：
   * 管道这种进程通信方式虽然使用简单，但是效率比较低，不适合进程间频繁地交换数据，并且管道只能传输无格式的[字节流](https://www.zhihu.com/search?q=字节流&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"465574868"})**。**

三、消息队列

为此，消息传递机制（Linux 中称消息队列）应用而生。比如，A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程在需要的时候自行去消息队列中读取数据就可以了。同样的，B 进程要给 A 进程发送消息也是如此。![img](https://pic1.zhimg.com/v2-a2caf6e76f9407a1752a220080b10134_b.jpg)

* **消息队列的本质就是存放在内存中的消息的链表，而消息本质上是用户自定义的数据结构**。
* 如果进程从消息队列中读取了某个消息，这个消息就会被从消息队列中删除。
* 对比一下管道机制：消息队列允许一个或多个进程向它写入或读取消息。消息队列可以实现消息的**随机查询**，不一定非要以先进先出的次序读取消息，也可以按消息的类型读取。比有名管道的先进先出原则更有优势。

四. 共享内存

为了避免像消息队列那样频繁的拷贝消息、进行系统调用，共享内存机制出现了。

* 顾名思义，共享内存就是允许不相干的进程将同一段物理内存连接到它们各自的地址空间中，使得这些进程可以访问同一个物理内存，这个物理内存就成为共享内存。

* 如果某个进程向共享内存写入数据，所做的改动将**立即**影响到可以访问同一段共享内存的任何其他进程。

  

  

  

五. 信号量和 PV 操作

* 实际上，对具有多 CPU 系统的最新研究表明，在这类系统上，消息传递的性能其实是要优于共享内存的，因为**消息队列无需避免冲突，而共享内存机制可能会发生冲突**。
* 题，保证共享内存在任何时刻只有一个进程在访问（互斥），并且使得进程们能够按照某个特定顺序访问共享内存（同步)，我们就可以使用进程的同步与互斥机制，常见的比如信号量与 PV 操作。**进程的同步与互斥其实是一种对进程通信的保护机制，并不是用来传输进程之间真正通信的内容的，但是由于它们会传输信号量，所以也被纳入进程通信的范畴，称为低级通信**。下面的内容和上篇文章【看完了进程同步与互斥机制，我终于彻底理解了 PV 操作】中所讲的差不多，看过的小伙伴可直接跳到下一标题。信号量其实就是一个变量 ，我们可以用一个信号量来表示系统中某种资源的数量，比如：系统中只有一台打印机，就可以设置一个初值为 1 的信号量。用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而很方便的实现进程互斥或同步。这一对原语就是 PV 操作：1）**P 操作**：将信号量值唤醒进程**？答：所谓唤醒进程是从就绪队列（[阻塞队列](https://www.zhihu.com/search?q=阻塞队列&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"465574868"})）中唤醒进程，而信号量的值大于 0 表示有共享资源可供使用，也就是说这个时候没有进程被阻塞在这个资源上，所以不需要唤醒，正常运行即可。问：**信号量的值 等于 0 的时候表示没有共享资源可供使用，为什么还要唤醒进程**？答：V 操作是先执行信号量值加 1 的，也就是说，把信号量的值加 1 后才变成了 0，在此之前，信号量的值是 -1，即有一个进程正在等待这个共享资源，我们需要唤醒它
* 

七. Socket

**至此，上面介绍的 5 种方法都是用于同一台主机上的进程之间进行通信的，如果想要**跨网络与不同主机上的进程进行通信**，那该怎么做呢？这就是 Socket 通信做的事情了

**总结**

1. 首先，最简单的方式就是**管道**，管道的本质是存放在内存中的特殊的文件。也就是说，内核在内存中开辟了一个缓冲区，这个缓冲区与管道文件相关联，对管道文件的操作，被内核转换成对这块缓冲区的操作。管道分为匿名管道和有名管道，匿名管道只能在父子进程之间进行通信，而有名管道没有限制。
2. 虽然管道使用简单，但是效率比较低，不适合进程间频繁地交换数据，并且管道只能传输无格式的字节流。为此**消息队列**应用而生。消息队列的本质就是存放在内存中的消息的链表，而消息本质上是用户自定义的数据结构。如果进程从消息队列中读取了某个消息，这个消息就会被从消息队列中删除。
3. 消息队列的速度比较慢，因为每次数据的写入和读取都需要经过用户态与内核态之间数据的拷贝过程，**共享内存**可以解决这个问题。所谓共享内存就是：两个不同进程的逻辑地址通过页表映射到物理空间的同一区域，它们所共同指向的这块区域就是共享内存。如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。对于共享内存机制来说，仅在建立共享内存区域时需要系统调用，一旦建立共享内存，所有的访问都可作为常规内存访问，无需借助内核。这样，数据就不需要在进程之间来回拷贝，所以这是最快的一种进程通信方式。
4. 共享内存速度虽然非常快，但是存在冲突问题，为此，我们可以使用信号量和 PV 操作来实现对共享内存的互斥访问，并且还可以实现进程同步。
5. **信号**和信号量是完全不同的两个概念！信号是进程通信机制中唯一的异步通信机制，它可以在任何时候发送信号给某个进程。通过发送指定信号来通知进程某个异步事件的发送，以迫使进程执行信号处理程序。信号处理完毕后，被中断进程将恢复执行。用户、内核和进程都能生成和发送信号。
6. 上面介绍的 5 种方法都是用于同一台主机上的进程之间进行通信的，如果想要跨网络与不同主机上的进程进行通信，就需要使用 **Socket** 通信。另外，Socket 也能完成同主机上的进程通信。
