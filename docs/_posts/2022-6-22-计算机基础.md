# 操作系统

### 进程调度

1. 先到先服务
2. 最短作业优先
3. 时间片轮转
4. 优先级

### 中断

中断是指计算机运行过程中，出现某些意外情况需主机干预时，机器能自动停止正在运行的程序并转入处理新情况的程序，处理完毕后又返回原被暂停的程序继续运行。

### 死锁必要条件

（1） 互斥条件：一个资源每次只能被一个进程使用。

（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。

（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。

（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

**避免死锁**：银行家算法

# [六大进程通信](https://zhuanlan.zhihu.com/p/465574868)



![img](https://pic2.zhimg.com/v2-05357079c73568813ec18658a5e803c1_b.jpg)

**一. 什么是进程通信**

顾名思义，进程通信（ InterProcess Communication，IPC）就是指**进程之间的信息交换**。

* 实际上，**进程的同步与互斥本质上也是一种进程通信**，只不过它传输的仅仅是[信号量](https://www.zhihu.com/search?q=信号量&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"465574868"})，通过修改信号量，使得进程之间建立联系，相互协调和协同工作，但是它**缺乏传递数据的能力**。
* 但是大多数情况下，**进程之间需要交换大批数据**，比如传送一批信息或整个文件，这就需要通过一种新的通信机制来完成，也就是所谓的进程通信。
* 再来从操作系统层面直观的看一些进程通信：我们知道，为了保证安全，每个进程的用户地址空间都是独立的，一般而言一个进程不能直接访问另一个进程的地址空间，不过内核空间是每个进程都共享的，所以**进程之间想要进行信息交换就必须通过内核**。![img](https://pic2.zhimg.com/v2-1c0a8bc38f13325491ab6a8b0f781be1_b.jpg)

二. 管道

1. **匿名管道**
   * Linux 管道使用竖线 | 连接多个命令，这被称为管道符。它的功能是将前一个命令（command1）的输出，作为后一个命令（command2）的输入，
   * 从这个功能描述中，我们可以看出**管道中的数据只能单向流动**，也就是半双工通信，
   * 如果想实现相互通信（全双工通信），我们需要创建两个管道才行。
   * 另外，通过管道符 | 创建的管道是匿名管道，用完了就会被自动销毁。
   * 并且，匿名管道只能在具有亲缘关系（父子进程）的进程间使用，。也就是说，**匿名管道只能用于父子进程之间的通信**。
   * 我们来理解下管道的本质是什么：对于管道两端的进程而言，管道就是一个文件（这也就是为啥管道也被称为共享文件机制的原因了)，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在于内存中。
   * 简单来说，**管道的本质就是内核在内存中开辟了一个缓冲区，这个缓冲区与管道文件相关联，对管道文件的操作，被内核转换成对这块缓冲区的操作**。
2. **有名管道**
   * 匿名管道由于没有名字，只能用于父子进程间的通信。
   * 为了克服这个缺点，提出了有名管道，也称做 FIFO，因为数据是先进先出的传输方式。
   * 所谓有名管道也就是提供一个路径名与之关联，这样，即使与创建有名管道的进程不存在亲缘关系的进程，只要可以访问该路径，就能够通过这个有名管道进行相互通信。
   * 使用 Linux 命令 mkfifo 来创建有名管道：
   * 管道这种进程通信方式虽然使用简单，但是效率比较低，不适合进程间频繁地交换数据，并且管道只能传输无格式的[字节流](https://www.zhihu.com/search?q=字节流&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"465574868"})**。**

三、消息队列

为此，消息传递机制（Linux 中称消息队列）应用而生。比如，A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程在需要的时候自行去消息队列中读取数据就可以了。同样的，B 进程要给 A 进程发送消息也是如此。![img](https://pic1.zhimg.com/v2-a2caf6e76f9407a1752a220080b10134_b.jpg)

* **消息队列的本质就是存放在内存中的消息的链表，而消息本质上是用户自定义的数据结构**。
* 如果进程从消息队列中读取了某个消息，这个消息就会被从消息队列中删除。
* 对比一下管道机制：消息队列允许一个或多个进程向它写入或读取消息。消息队列可以实现消息的**随机查询**，不一定非要以先进先出的次序读取消息，也可以按消息的类型读取。比有名管道的先进先出原则更有优势。

四. 共享内存

为了避免像消息队列那样频繁的拷贝消息、进行系统调用，共享内存机制出现了。

* 顾名思义，共享内存就是允许不相干的进程将同一段物理内存连接到它们各自的地址空间中，使得这些进程可以访问同一个物理内存，这个物理内存就成为共享内存。

* 如果某个进程向共享内存写入数据，所做的改动将**立即**影响到可以访问同一段共享内存的任何其他进程。

  

  

  

五. 信号量和 PV 操作

* 实际上，对具有多 CPU 系统的最新研究表明，在这类系统上，消息传递的性能其实是要优于共享内存的，因为**消息队列无需避免冲突，而共享内存机制可能会发生冲突**。
* 题，保证共享内存在任何时刻只有一个进程在访问（互斥），并且使得进程们能够按照某个特定顺序访问共享内存（同步)，我们就可以使用进程的同步与互斥机制，常见的比如信号量与 PV 操作。**进程的同步与互斥其实是一种对进程通信的保护机制，并不是用来传输进程之间真正通信的内容的，但是由于它们会传输信号量，所以也被纳入进程通信的范畴，称为低级通信**。下面的内容和上篇文章【看完了进程同步与互斥机制，我终于彻底理解了 PV 操作】中所讲的差不多，看过的小伙伴可直接跳到下一标题。信号量其实就是一个变量 ，我们可以用一个信号量来表示系统中某种资源的数量，比如：系统中只有一台打印机，就可以设置一个初值为 1 的信号量。用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而很方便的实现进程互斥或同步。这一对原语就是 PV 操作：1）**P 操作**：将信号量值唤醒进程**？答：所谓唤醒进程是从就绪队列（[阻塞队列](https://www.zhihu.com/search?q=阻塞队列&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"465574868"})）中唤醒进程，而信号量的值大于 0 表示有共享资源可供使用，也就是说这个时候没有进程被阻塞在这个资源上，所以不需要唤醒，正常运行即可。问：**信号量的值 等于 0 的时候表示没有共享资源可供使用，为什么还要唤醒进程**？答：V 操作是先执行信号量值加 1 的，也就是说，把信号量的值加 1 后才变成了 0，在此之前，信号量的值是 -1，即有一个进程正在等待这个共享资源，我们需要唤醒它
* 

七. Socket

**至此，上面介绍的 5 种方法都是用于同一台主机上的进程之间进行通信的，如果想要**跨网络与不同主机上的进程进行通信**，那该怎么做呢？这就是 Socket 通信做的事情了

**总结**

1. 首先，最简单的方式就是**管道**，管道的本质是存放在内存中的特殊的文件。也就是说，内核在内存中开辟了一个缓冲区，这个缓冲区与管道文件相关联，对管道文件的操作，被内核转换成对这块缓冲区的操作。管道分为匿名管道和有名管道，匿名管道只能在父子进程之间进行通信，而有名管道没有限制。
2. 虽然管道使用简单，但是效率比较低，不适合进程间频繁地交换数据，并且管道只能传输无格式的字节流。为此**消息队列**应用而生。消息队列的本质就是存放在内存中的消息的链表，而消息本质上是用户自定义的数据结构。如果进程从消息队列中读取了某个消息，这个消息就会被从消息队列中删除。
3. 消息队列的速度比较慢，因为每次数据的写入和读取都需要经过用户态与内核态之间数据的拷贝过程，**共享内存**可以解决这个问题。所谓共享内存就是：两个不同进程的逻辑地址通过页表映射到物理空间的同一区域，它们所共同指向的这块区域就是共享内存。如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。对于共享内存机制来说，仅在建立共享内存区域时需要系统调用，一旦建立共享内存，所有的访问都可作为常规内存访问，无需借助内核。这样，数据就不需要在进程之间来回拷贝，所以这是最快的一种进程通信方式。
4. 共享内存速度虽然非常快，但是存在冲突问题，为此，我们可以使用信号量和 PV 操作来实现对共享内存的互斥访问，并且还可以实现进程同步。
5. **信号**和信号量是完全不同的两个概念！信号是进程通信机制中唯一的异步通信机制，它可以在任何时候发送信号给某个进程。通过发送指定信号来通知进程某个异步事件的发送，以迫使进程执行信号处理程序。信号处理完毕后，被中断进程将恢复执行。用户、内核和进程都能生成和发送信号。
6. 上面介绍的 5 种方法都是用于同一台主机上的进程之间进行通信的，如果想要跨网络与不同主机上的进程进行通信，就需要使用 **Socket** 通信。另外，Socket 也能完成同主机上的进程通信。

<<<<<<< Updated upstream

# IO模型

## 术语

* `文件描述符`:(fd)是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。
  * 文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为**每一个进程所维护的该进程打开文件的记录表**。
  * 当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。
  * 在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。
  * 但是文件描述符这一概念往往只适用于 `UNIX、Linux` 这样的操作系统。

* 缓存IO
* ![image-20220923153340611](H:\gitfile\modiman.github.io\docs\_posts\imgs\image-20220923153340611.png)
  * **缓存I/O的优点**：首先，在一定程度上分离了内核空间和用户空间，保护系统本身的运行安全；其次，可以减少读盘的次数，从而提高性能。
  * **缓存I/O的缺点**：在缓存 I/O 机制中，DMA 方式可以将数据直接从磁盘读到页缓存中，或者将数据从页缓存直接写回到磁盘上，而不能直接在应用程序地址空间和磁盘之间进行数据传输，这样，数据在传输过程中需要在应用程序地址空间（用户空间）和缓存（内核空间）之间进行多次数据拷贝操作，这些数据拷贝操作所带来的CPU以及内存开销是非常大的。



## BIO

服务端为了顺利处理客户端的IO请求，为每个客户端开启一个线程

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/9/26/382f3861aaf1769e560e5ae558f77f10~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

**缺陷**：线程占用了大量内存，同时线程上下文切换还花费了大量时间

同时，在这种线程模型下，io没有执行完会阻塞线程的执行

## NIO 

java1.4以后，如果没读到数据，非阻塞IO不会阻塞线程，而是直接返回0，这时候线程判断到数据没有准备好，可以处理其他事，不会被阻塞

**问题**：处理什么

可以明白，虽然非阻塞 IO 不会阻塞线程，但是由于没有数据可读，线程也没有办法继续执行下面的逻辑，只能不断的调用判断，等待数据到来。这种情况下称为**同步 IO**。所以综上，NIO 本质上是一个**非阻塞同步 IO**。

## IO复用

根据上文，在BIO中，服务端要为每个客户端分配一个线程，而且每个线程要等io结束才能进行下一步操作

在NIO中，尽管不用阻塞，但大部分时候还是要等io结束才能下一步操作

但不用为每一个client都分配一个线程去监听io事件，可以设置一个线程统一监听，这就叫IO复用

1. 进程A读取文件x
2. 内核缓冲区没有文件x，返回读取失败，添加一个文件描述符（A,x）
3. 内核到磁盘读取x（耗时比较久）
4. select函数轮询fd，当有文件读取完毕，通知对应的进程

**改进**：把fd信息通知到用户空间需要不小的开销，eoll引入`mmap`，通过开辟一块内核和用户空间共享内存加快通信速度

# IO流

输入源包括键盘、文件、网络连接等

* 输入流：Inputstream(字节)/reader(字符)
* 输出流：Outstream（字节）/writer(字符)

### 字节流字符流一般应用场景

如果输入输出文本内容，考虑使用字符流，如果是二进制文件，考虑使用字节流。这样能避免字节字符之间相互转换带来的复杂度

## BIO

* BIO全称是Blocking IO，是JDK1.4之前的传统IO模型，本身是同步阻塞模式。
* 线程发起IO请求后，一直阻塞IO，直到缓冲区数据就绪后，再进入下一步操作。
* 针对网络通信都是一请求一应答的方式，虽然简化了上层的应用开发，但在性能和可靠性方面存在着巨大瓶颈，试想一下如果每个请求都需要新建一个线程来专门处理，那么在高并发的场景下，机器资源很快就会被耗尽。

**从时间上讲，创建和销毁线程需要巨大的开销**

**从空间上讲，大量线程的存在占用内存和cpu资源**

## NIO

* NIO也叫Non-Blocking IO 是同步非阻塞的IO模型。
* 线程发起io请求后，立即返回（非阻塞io）。
* 同步指的是必须等待IO缓冲区内的数据就绪，
* 而非阻塞指的是，用户线程不原地等待IO缓冲区，可以先做一些其他操作，但是要定时轮询检查IO缓冲区数据是否就绪。

但尽管如此，大部分线程是需要等待io结束才能做其他事的，所以这仍然是一种同步io，优化程度有限

## IO多路复用

* Java中的NIO 是new IO的意思。其实是NIO加上IO多路复用技术。
* 普通的NIO是线程轮询查看一个IO缓冲区是否就绪，而Java中的new IO指的是线程轮询地去查看一堆IO缓冲区中哪些就绪，
* 这是一种IO多路复用的思想。
* IO多路复用模型中，将检查IO数据是否就绪的任务，交给系统级别的select或epoll模型，由系统进行监控，减轻用户线程负担。
* NIO主要有buffer、channel、selector三种技术的整合，通过零拷贝的buffer取得数据，
* 每一个客户端通过channel在selector（多路复用器）上进行注册。
* 服务端不断轮询channel来获取客户端的信息。
* channel上有connect,accept（阻塞）、read（可读）、write(可写)四种状态标识。
* 根据标识来进行后续操作。所以一个服务端可接收无限多的channel。不需要新开一个线程。大大提升了性能。

## AIO

AIO是真正意义上的异步非阻塞IO模型。 上述NIO实现中，需要用户线程定时轮询，去检查IO缓冲区数据是否就绪，占用应用程序线程资源，其实轮询相当于还是阻塞的，并非真正解放当前线程，因为它还是需要去查询哪些IO就绪。而真正的理想的异步非阻塞IO应该让内核系统完成，用户线程只需要告诉内核，当缓冲区就绪后，通知我或者执行我交给你的回调函数。

AIO可以做到真正的异步的操作，但实现起来比较复杂，支持纯异步IO的操作系统非常少，目前也就windows是IOCP技术实现了，而在Linux上，底层还是是使用的epoll实现的。

## 多路复用

* [彻底理解 IO 多路复用实现机制](https://juejin.cn/post/6882984260672847879)

### 什么是IO多路复用？

- IO 多路复用是一种同步IO模型，实现一个线程可以监视多个文件句柄；
- 一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；
- 没有文件句柄就绪就会阻塞应用程序，交出CPU。

> 多路是指网络连接，复用指的是同一个线程

|                      | **select**                                         | **poll**                                         | **epoll**                                                    |
| -------------------- | -------------------------------------------------- | ------------------------------------------------ | ------------------------------------------------------------ |
| 操作方式             | 遍历                                               | 遍历                                             | 回调                                                         |
| 数据结构             | bitmap                                             | 数组                                             | 红黑树                                                       |
| 最大连接数           | 1024（x86）或 2048（x64）                          | 无上限                                           | 无上限                                                       |
| 最大支持文件描述符数 | 一般有最大值限制                                   | 65535                                            | 65535                                                        |
| fd拷贝               | 每次调用select，都需要把fd集合从用户态拷贝到内核态 | 每次调用poll，都需要把fd集合从用户态拷贝到内核态 | fd首次调用epoll_ctl拷贝，每次调用epoll_wait不拷贝            |
| 工作模式             | LT                                                 | LT                                               | 支持ET高效模式                                               |
| 工作效率             | 每次调用都进行线性遍历，时间复杂度为O(n)           | 每次调用都进行线性遍历，时间复杂度为O(n)         | 事件通知方式，每当fd就绪，系统注册的回调函数就会被调用，将就绪fd放到readyList里面，时间复杂度O(1) |
>>>>>>> Stashed changes
