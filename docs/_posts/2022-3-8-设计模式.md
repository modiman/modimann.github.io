#  设计原则

设计模式原则

## 设计模式的目的

1. 代码可充裕红星

## 单一职责原则

**一个类只负责一个职责**



* 降低类的复杂度，一个类只负责一个与职责
* 提高类的可读性，可维护性
* 降低变更带来的风险
* 通常情况下遵守单一职责原则，只有逻辑足够简单，才可以在代码中级别违反单依职责原则，只有方法足够简单，才可以在类级别违反单一职责原则

##  接口隔离原则

1.  客户端不应该依赖他不需要的接口，寄一个接口对另一个类的应该建立在最小的接口上 
2. 

# 策略模式

定义了算法族，并分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的客户

# 2. 观察者模式

观察者模式定义了一系列对象之间的一对多关系，当一个对象改变状态，其他依赖者都会收到通知。

## 认识观察者模式

以报纸和杂志订阅为例

1. 报社的业务就是出版报纸
2. 向某家报社订阅报纸，只要有新报纸出版，就会送给订阅者。
3. 当不想看的时候，取消订阅，报社就不会再继续送
4. 只要报社还在，就一直有人订阅或取消订阅

**出版者+订阅者=观察者模式**





**![image-20220308102656510](./imgs\image-20220308102656510.png)**![image-20220308102908947](.\imgs\image-20220308102908947.png)

* 问：这和一对多的关系有何关联

利用观察者模式，主题是具有状态的对象，并且可以控制这些状态，也就是说，有一个具有状态的主题。另一方面，观察者使用这些状态，虽然这些状态并不属于它们。有许多的观察者，依赖主题来告诉他们状态何时改变了。这就产生一个关系：一个主题对多个观察者的关系

* 问：其间的依赖是如何产生的

因为主题是真正拥有数据的人，观察者是主题的依赖者，在数据变化时更新，这样比起许多对象控制同一份数据来，可以得到更干净的OO设计。

## 松耦合的威力

**当两个对象之间松耦合，它们依然可以交互，但是彼此不太清楚彼此的细节。**

观察者模式提供了一种对象设计，让主题和观察者之间松耦合。

## 气象站实例

### 项目需求

| 组成 | 气象站                 | WeatherData对象            | 布告板       |
| ---- | ---------------------- | -------------------------- | ------------ |
| 作用 | 获取气象数据的物理装置 | 追踪气象站数据并更新布告板 | 展示天气情况 |

这里WeatherData对象就是被观察者，布告板则是观察者。

### 方法表

| WeatherData对象                | 布告板              |
| ------------------------------ | ------------------- |
| 数据域、观察者列表             | 更新数据方法update  |
| 注册、移除、通知观察者的方法   | 展示数据方法display |
| 改变方法 measurementsChanged() |                     |
| 设置改变方法setMeasurements    |                     |

### 三个接口

```java
package service;
import service.Observer;
public interface Subject {
    public void registerObserver(Observer o);
    public void removeObserver(Observer o);
    public void notifyObserver();
    }
package service;

public interface Observer {
    public void update(float temp,float humidity,float pressure);
}
package service;

public interface DisplayElement {
    public void display();
}

```

### 两个类

```java
package model;

import service.Subject;

import java.util.ArrayList;
import service.Observer;

public class WeatherData implements Subject {
    private ArrayList observers;
    private float temprature;
    private float humidity;
    private float pressure;


    public WeatherData(){
        observers = new ArrayList();
    }


    public void registerObserver(Observer o) {
        observers.add(o);
    }

    public void removeObserver(Observer o) {
        int i= observers.indexOf(o);
        if(i>=0){
            observers.remove(i);
        }
    }



    public void notifyObserver() {
        for(int i=0;i<observers.size();i++){
            Observer observer = (Observer)observers.get(i);
            observer.update(temprature,humidity,pressure);
        }

    }

    public void measurementsChanged(){
        notifyObserver();
    }

    public void setMeasurements(float temprature,float humidity,float pressure) {
        this.temprature = temprature;
        this.humidity = humidity;
        this.pressure = pressure;
        measurementsChanged();
    }
}

```

```java
package model;

import controller.CurrentConditionsDisplay;
import model.WeatherData;

public class WeatherStation {
    public static void main(String[] args) {
        WeatherData weatherData = new WeatherData();
        CurrentConditionsDisplay currentConditionsDisplay = new CurrentConditionsDisplay(weatherData);
        weatherData.setMeasurements(80,65,30.4f);
        weatherData.setMeasurements(82,66,30.4f);
        weatherData.setMeasurements(83,75,29.4f);

    }
}
```

### 测试函数

```****
package controller;

import service.DisplayElement;
import service.Observer;
import service.Subject;

public class CurrentConditionsDisplay implements Observer, DisplayElement {
    private float temprature;
    private float humidity;
    private Subject weatherData;

    public CurrentConditionsDisplay(Subject weatherData) {
        this.weatherData = weatherData;
        weatherData.registerObserver(this);
    }


    public void update(float temp, float humidity, float pressure) {
        this.temprature = temp;
        this.humidity = humidity;
        display();

    }


    public void display() {
        System.out.println("Current condition"+temprature);
        System.out.println("Current F degree"+humidity);
    }

}
```

### 使用java内置Observer改写

首先把WeatherData改成使用java.util.Observable

改写了measurementsChanged方法，同时删去了对三个observer接口的实现

```java
package model;

import java.util.ArrayList;
import java.util.Observable;

import service.Observer;

public class WeatherData extends Observable {
    private ArrayList observers;
    private float temprature;
    private float humidity;
    private float pressure;


    public WeatherData(){
        observers = new ArrayList();
    }

    public void measurementsChanged(){
        setChanged();
        notifyObservers();
    }

    public void setMeasurements(float temprature,float humidity,float pressure) {
        this.temprature = temprature;
        this.humidity = humidity;
        this.pressure = pressure;
        measurementsChanged();
    }

    public float getTemprature() {
        return temprature;
    }

    public float getHumidity() {
        return humidity;
    }

    public float getPressure() {
        return pressure;
    }
}

```

* 在java自带的观察者类中，Observable表示可观察者，用来替代subject，即发送消息的一方
* observer则表示观察者，接收条件的一方

```java
package model;

import model.WeatherData;
//import service.DisplayElement;
import java.util.Observable;
import java.util.Observer;

public class CurrentConditionsDisplay implements Observer {
    Observable observable;
    private float temprature;
    private float humidity;


    public CurrentConditionsDisplay(Observable observable) {
        this.observable = observable;
        observable.addObserver(this);
       // weatherData.registerObserver(this);
    }
    public void update(Observable obs,Object arg) {
        if (obs instanceof WeatherData){
            WeatherData weatherData = (WeatherData)obs;
            this.temprature = weatherData.getTemprature();
            this.humidity = weatherData.getHumidity();
            display();
        }
    }
    public void display() {
        System.out.println("Current condition"+temprature+"   and Current F degree"+humidity);
        System.out.println();
    }

}
```



### 第二章要点

* 观察者模式定义了对象之间一对多的关系、
* 主题（也就是可观察者）用一个共同的接口来更新观察者
* 观察者和可观察者之间使用松耦合方式结合，可观察者不知道观察者的细节，只知道观察者实现了观察者接口
* 使用此模式时，可从被观察者处推（push）或拉（poll）数据，然而推的方式被认为更正确
* 有多个观察者时，不可以依赖特定的通知次序
* java有多种观察者模式的实现，包括了通用的java.util.Observable
* 要注意java.util.Observable
* 要注意java.util.Observable实现上所带来的一些问题
* 如果有必要的话，可以实现自己的Observable，这并不难
* Swing使用大量的观察者模式，许多GUI框架也是如此
* 此模式也被应用在许多地方，例如JavaBeans\RMI 



# 3. 装饰者模式

**本章可以称为给爱用继承的人一个全新的设计眼界**

我们即将再次探讨典型的继承滥用问题，你将在本章学到如何使用对象组合的方式，做到在运行时装饰类。

## 开放-关闭原则

* 类应该对扩展开放，对修改关闭

**我们的目标是允许类容易扩展，在不修改现有代码的情况下就可以搭配新的行为。这样的设计具有弹性可以应对改变，可以接受新的功能来应对改变的需求**

* 问：对扩展开放，对修改关闭听起来很矛盾，如何兼顾两者

有一些聪明的OO技巧，允许系统在不修改代码的情况下，进行功能的扩展，想想观察者模式。通过加入新的观察者，我们可以在任何时候扩展Subject，而且不需要向主题中添加代码。

* 问：如何将某件东西设计的可以扩展有禁止修改

许多模式是长期经验的实证，可通过提供扩展的方法保护代码免于被修改

* 如何让设计的每个部分都遵循开放-关闭原则

## 认识装饰者模式

以咖啡馆为例

以饮料为主题，然后在运行时以调料来“装饰”饮料，比方说，如果顾客想要摩卡和奶泡深焙咖啡，那么，要做的是

1. 拿一个深焙咖啡（DarkRoast）对象
2. 以摩卡（Mocha）对象装饰它
3. 以奶泡（Whip）对象装饰它
4. 调用cost（）方法，并依赖委托（delegate）将调理的价钱加上去

已知条件

* 装饰者和被装饰对象具有相同的超类型
* 可以用一个或多个装饰者包装一个对象
* 既然装饰者和被装饰者对象有相同的超类型，所以在任何需要原始对象（被包装的）的场合，可以用装饰过的对象替代它
* 装饰者可以在所委托被装饰者的行为之前与之后加上自己的行为，已达到特定的目的
* 对象可以在任何时候被装饰，所以可以在运行时动态地、不限量地用喜欢的装饰者来装饰对象

## 定义装饰者模式

装饰者模式动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案

![image-20220308192609673](.\imgs\image-20220308192609673.png)

## 装饰饮料



### 首先定义基类Beverage

```java
package s3decorator;

public abstract class Beverage {
    //饮料类
    String description = "Unknown Beverage";

    public String getDescription() {
        return description;
    }
    public abstract double cost();
}
```

### 实现调料抽象类，也就是装饰者类

```java
package s3decorator;

/**
 * @author: modige
 * @date: 2022/3/8 18:47
 * @description:调料抽象类，也就是装饰者类
 */
public abstract class CondimentDecorator extends Beverage{
//首先必须让Condiment Decorator 能够取代Beverage，所以将Condiment Decorator 扩展自Beverage类
    public abstract String getDescription();
    //所有的调料装饰者必须重新实现getDescription方法

}
```

### 实现一些饮料

包括

* 浓缩咖啡Espresso、

* 综合咖啡house blend  coffee、

* 深焙咖啡dark roast

  (分别在三个不同文件，此处放在一起)

```java
package s3decorator;

/**
 * @author: modige
 * @date: 2022/3/8 18:52
 * @description:
 */
public class Espresso extends Beverage {

    public Espresso(){
        description = "Espresso";//description继承自neverage
    }
    @Override
    public double cost(){
        return 1.99;
        //最后需要计算Espresso的价钱，现在不需要管调料的价钱，直接把Espresso的价格1.99返回即可
    }
}
public class HouseBlend extends Beverage {
    public HouseBlend (){
        description = "House Blend Coffee";

    }

    @Override
    public double cost() {
        return .89;
    }
}
public class DarkRoast extends Beverage{
    public DarkRoast(){
        description = "Dark Roast Coffee";
    }

    @Override
    public double cost() {
        return 1.05;
    }
}
```

### 写调料代码

CondimentDecorator的具体组件，也就是具体装饰者，包括

* Mocca
* Whip

```java
package s3decorator;

/**
 * @author: modige
 * @date: 2022/3/8 18:58
 * @description:具体装饰者
 */
public class Mocha extends CondimentDecorator {
    Beverage beverage ;
    /*
    * 要让Mocha能够引用一个Beverage，做法如下
    * 1. 用一个实例变量记录饮料，也就是被装饰者
    * 2. 想办法让被修饰者被记录到实例变量中这里的做法是
    *     把饮料当做是构造器的参数，再由构造器将此饮料
    *    记录在实例变量中
    *   * */
    public Mocha(Beverage beverage) {
        this.beverage = beverage;
    }

    public String getDescription() {
        return beverage.getDescription() + ",Mocha";
        /*
        * 希望不只是描述饮料如DarkRoast  而是完整地连
        * 调料都描述出来，所以首先利用委托的做法，得到
        * 一个叙述，然后再其上加上附加的叙述
        *
        * */

    }

    public double cost() {
        return.20 + beverage.cost();
    }
}
public class Whip extends CondimentDecorator{
    Beverage beverage ;
    public Whip(Beverage beverage){
        this.beverage = beverage;
    }
    public String getDescription(){
        return beverage.getDescription() + ",Whip";
    }
    public double cost(){
        return beverage.cost()+.20;
    }
}

```

## 真实世界的装饰者 Java I/O

## OO原则

* 封装变化
* 多用组合，少用继承
* 针对接口编程，不针对实现编程
* 为交互对象之间的松耦合设计而努力
* 对扩展开放，对修改关闭

## 第三章要点

* 继承术语扩展形式之一，但不见得是达到弹性设计的最佳方式
* 在设计中，应允许行为可以被扩展，而无需修改现有的代码
* 组合和委托可用于在运行时动态地加上新的行为
* 除了继承，装饰者模式也可以扩展行为
* 装饰者模式意味着一群装饰者类，这些类用来包装具体组件
* 装饰者类反映出被装饰的组件类型，
* 装饰者可以在被装饰者的行为前面加上自己的行为
* 可以用无数个装饰者包装一个组件
* 装饰者一般对组件的客户是透明的，除非客户程序依赖于组建的具体类型
* 装饰者会导致设计中出现许多小对象，如果过度使用，会让程序变得很复杂

# 4.工厂模式

**除了使用new操作符之外，还有更多制造对象的方法。你将了解到实例化这个活动不应该总是公开的进行，也会认识到初始化经常造成耦合问题。工厂模式可以从复杂的依赖中帮你脱困**

## new

**当看到new时就会想到具体**。当使用new时，的确是在实例化一个具体类，所以的确是实现，而不是接口。

## 定义简单工厂

简单工厂其实不是一个设计模式，反而像是一种编程习惯。有些开发人员的确是把这个编程习惯误认为是工厂模式。

有时要实例化一些具体类，究竟实例那个类要在运行时根据一些条件决定

```java
public Pizza createPizza(String type){
    Pizza pizza = null;
    if(type.equals("cheese")){
        pizza = new CheesePizza();
    }
    else if  (type.equals("pepperoni")){
        pizza = new PepperoniPizza();
    }
    else pizza = new VeggiePizza();
    return pizza;
}
```

一旦有变化或扩展，就必须重新打开这段代码进行检查和修改。通常这样修改过 的到吗将造成部分代码更难维护和更新，而且也更容易犯错。

## 简单工厂实例：披萨店

假设有一家披萨店

```java
 public Pizza orderPizza(){
        Pizza pizza = new Pizza();
         pizza = factory.createPizza(type);
        pizza.prepare();
        pizza.bake();
        pizza.cut();
        pizza.box();
        return pizza;
    }

```

**当需要更多披萨类型**就需要增加一些代码，来决定披萨类型

```java
 public Pizza orderPizza(){
        Pizza pizza ;
        if(type.equals("cheese")){
            pizza = new CheesePizza();
        }
        else if  (type.equals("pepperoni")){
            pizza = new PepperoniPizza();
        }
        else pizza = new VeggiePizza();
        pizza.prepare();
        pizza.bake();
        pizza.cut();
        pizza.box();
        return pizza;
    }
```

**但是压力来自增加更多的披萨**，if-else语句将不得不持续增大，**但可以发现，只有选择披萨类型的部分需要修改，制作部分则不需要**

于是可以继续封装代码



### 封装创建对象的代码

现在最好将创建对象封装到orderPizza之外，移到另一个对象中，由这个对象进行专职创建披萨

**我们称这个新对象为工厂**

工厂处理创建对象的细节， 一点有了SimplePizzaFactory，orderPizza()就变成此对象的客户，但需要披萨时，就叫披萨工厂做一个

### 建立一个简单的披萨工厂

披萨工厂为所有披萨封装创建对象的代码

```java
package s4factory;

import s4factory.pizza.CheesePizza;
import s4factory.pizza.PepperoniPizza;
import s4factory.pizza.Pizza;
import s4factory.pizza.VeggiePizza;

/**
 * @author: modige
 * @date: 2022/3/9 13:09
 * @description:建立一个简单披萨工厂，为所有披萨创建对象的代码
 */
public class SimplePizzaFactory {
    public Pizza createPizza(String type){
        Pizza pizza = null;
        if(type.equals("cheese")){
            pizza = new CheesePizza();
        }
        else if  (type.equals("pepperoni")){
            pizza = new PepperoniPizza();
        }
        else pizza = new VeggiePizza();
        return pizza;
    }


}
```

###  问答

* 这么做有什么好处似乎只是把问题搬到另一个对象罢了

​       



* 

### 重做PizzaStore类

```java
package s4factory;

import s4factory.pizza.Pizza;

/**
 * @author: modige
 * @date: 2022/3/9 13:30
 * @description:倚仗工厂创建披萨
 */
public class PizzaStore {
    //为PizzaStore加上一个对SimplePizzaFactory的引用
    SimplePizzaFactory factory;

    //PizzaStore的构造器需要一个工厂作为参数
    public PizzaStore(SimplePizzaFactory factory){
        this.factory = factory;
    }
    //而orderPizza()方法通过简单传入订单类型来使用
    // 工厂创建披萨
    public Pizza orderPizza(String type){
        Pizza pizza ;
        //把new操作符替换成工厂对象的创建方法，不再使用具体实例化
        pizza = factory.createPizza(type);
        pizza.prepare();
        pizza.bake();
        pizza.cut();
        pizza.box();
        return pizza;
    }
}
```

## 加盟披萨店

![image-20220309141632383](.\imgs\image-20220309141632383.png)

此时不光披萨的口味、调料有差异，连做法都出现了分歧。

### 给披萨店使用的框架

有个做法可以让披萨制作活动局限于PizzaStore类，而同时又能让这些加盟店依然可以自由地制作该区域的风味

所要做的事情就是把createPizza（）方法放回PizzaStore中，不过要把它设置为抽象方法，然后为，每个区域创建一个PizzaStore的子类

```java
public abstract class PizzaStore{
    public Pizza orderPizza(String type) {
        Pizza pizza;
        pizza = createPizza(type);
        pizza.prepare();
        pizza.bake();
        pizza.cut();
        pizza.box();
        return pizza;
    }
    abstract Pizza createPizza(String type);

}
```

现在已经有一个PizzaStore作为超类，让每个域类型都继承自这个PizzaStore，每个子类各自决定如何制造披萨

### 允许子类做决定

### 开一家披萨店

```java
package s4factory.store;

import s4factory.pizza.NYStyleCheesePizza;
import s4factory.pizza.NYStylePepperoniPizza;
import s4factory.pizza.NYStyleVeggiePizza;
import s4factory.pizza.Pizza;

/**
 * @author: modige
 * @date: 2022/3/9 14:30
 * @description:
 */
public class NYPizzaStore extends PizzaStore {
    //必须实现createPizza方法，因为在PizzaStore里他是抽象的
    Pizza createPizza(String item) {
        if (item.equals("cheese"))
            return new NYStyleCheesePizza();
        else if (item.equals("pepproni"))
            return new NYStylePepperoniPizza();
        else if (item.equals("veggie"))
            return new NYStyleVeggiePizza();
        else return null;


    }
}
```

##  声明一个工厂方法

```
public abstract class PizzaStore{
    public Pizza orderPizza(String type) {
        Pizza pizza;
        pizza = createPizza(type);
        pizza.prepare();
        pizza.bake();
        pizza.cut();
        pizza.box();
        return pizza;
    }
    protected abstract Pizza createPizza(String type);
    //现在实例化披萨的责任被移到一个方法中，此方法就如同一个工厂
    //工厂方法是抽象的，所以依赖子类来处理对象的创建
    //工厂方法必须返回一个产品
    //工厂方法将客户和实际创建具体代码的代码分隔开
    //工厂方法可能需要参数来指定所要的产品
    

}
```

### 如何利用工厂方法订购披萨

1. 获得披萨店的实例，分别实例化一个NYPizzaStore和一个ChicagoPizzaStore
2. 有了各自的PizzaStore，分别调用各自的orderPizza方法，并传入他们喜爱的类型
3. orderPizza调用createPizza创建披萨，createPizza会将创建好的披萨当做返回值
4. orderPizza并不知道真正创建的是哪一种披萨，只知道这是一个披萨

### 根据订单生产披萨

1. 首先需要一个纽约披萨店

   ```java
   PizzaStore nyPizzaStore = new NYPizzaStore(); 
   ```

2. 下订单

   ```java
   nyPizzaStore.orderPizza("cheese");
   ```

3. orderPizza方法调用createPizza方法

   ```java
   Pizza pizza = createPizza("cheese");
   ```

4. 最后，披萨必须经过处理才算完成orderPizza（）

   ```java
   pizza.prepare();
   pizza.bake();
   pizza.cut();
   pizza.box(); 
   ```

### 实现Pizza本身

```java
package s4factory.pizza;

import java.util.ArrayList;

/**
 * @author: modige
 * @date: 2022/3/9 13:11
 * @description:皮萨类
 */
//从一个抽象皮萨类开始，所有的具体披萨都必须派生自这个类
public abstract class Pizza {
    String name;
    String dough;
    String sauce;
    ArrayList toppings = new ArrayList();


    public void prepare() {
        System.out.println("preparing "+name);
        for (int i=0;i<toppings.size();i++){
            System.out.println(" "+toppings.get(i));
        }
    }

    public void bake() {
        System.out.println("bake for 25m ");

    }

    public void cut() {
        System.out.println("cutting into slices");

    }

    public void box() {
        System.out.println("placing in box");

    }

    public String getName() {
        return name;
    }
    //    public Pizza(String type) {
//        this.type = type;
//    }
}

```

### 定义一些Pizza子类

```java
package s4factory.pizza;

/**
 * @author: modige
 * @date: 2022/3/9 14:35
 * @description:
 */
public class NYStyleCheesePizza extends Pizza {

    public NYStyleCheesePizza() {
        name = "NY cheese ";
        dough = "Thin Crust Dough";
        sauce = "Marinara Sauce";
        toppings.add("grated reggiana cheese");
    }
}
```

### 测试方法

```java
package s4factory;

import s4factory.pizza.ChicagoStyleCheesePizza;
import s4factory.pizza.Pizza;
import s4factory.store.CCGPizzaStore;
import s4factory.store.NYPizzaStore;
import s4factory.store.PizzaStore;

/**
 * @author: modige
 * @date: 2022/3/9 15:11
 * @description:
 */
public class PizzaTestDrive {
    public static void main(String[] args) {
        PizzaStore nyStore = new NYPizzaStore();
        PizzaStore ccgStore = new CCGPizzaStore();

        Pizza pizza = nyStore.orderPizza("cheese");
        System.out.println("tom order a "+pizza.getName());

        pizza = ccgStore.orderPizza("cheese");
        System.out.println("androw order a "+ pizza.getName());

    }
}
```

## 认识工厂模式

所有工厂模式都用来封装对象的创建。工厂方法模式通过让子类决定该创建的对象是什么，来达到将对象创建的过程封装的目的

![image-20220309152533238](./imgs\image-20220309152533238.png)![image-20220309152547904](.\imgs\image-20220309152547904.png)

## 定义工厂方法模式

**工厂方法模式**定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个，工厂方法让类把实例化延迟到子类。

