# 策略模式

定义了算法族，并分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的客户

# 2. 观察者模式

观察者模式定义了一系列对象之间的一对多关系，当一个对象改变状态，其他依赖者都会收到通知。

## 认识观察者模式

以报纸和杂志订阅为例

1. 报社的业务就是出版报纸
2. 向某家报社订阅报纸，只要有新报纸出版，就会送给订阅者。
3. 当不想看的时候，取消订阅，报社就不会再继续送
4. 只要报社还在，就一直有人订阅或取消订阅

**出版者+订阅者=观察者模式**





**![image-20220308102656510](E:\gitfile\mypages\modiman.github.io\docs\_posts\image-20220308102656510.png)**![image-20220308102908947](E:\gitfile\mypages\modiman.github.io\docs\_posts\image-20220308102908947.png)

* 问：这和一对多的关系有何关联

利用观察者模式，主题是具有状态的对象，并且可以控制这些状态，也就是说，有一个具有状态的主题。另一方面，观察者使用这些状态，虽然这些状态并不属于它们。有许多的观察者，依赖主题来告诉他们状态何时改变了。这就产生一个关系：一个主题对多个观察者的关系

* 问：其间的依赖是如何产生的

因为主题是真正拥有数据的人，观察者是主题的依赖者，在数据变化时更新，这样比起许多对象控制同一份数据来，可以得到更干净的OO设计。

## 松耦合的威力

**当两个对象之间松耦合，它们依然可以交互，但是彼此不太清楚彼此的细节。**

观察者模式提供了一种对象设计，让主题和观察者之间松耦合。

## 气象站实例

### 项目需求

| 组成 | 气象站                 | WeatherData对象            | 布告板       |
| ---- | ---------------------- | -------------------------- | ------------ |
| 作用 | 获取气象数据的物理装置 | 追踪气象站数据并更新布告板 | 展示天气情况 |

这里WeatherData对象就是被观察者，布告板则是观察者。

### 方法表

| WeatherData对象                | 布告板              |
| ------------------------------ | ------------------- |
| 数据域、观察者列表             | 更新数据方法update  |
| 注册、移除、通知观察者的方法   | 展示数据方法display |
| 改变方法 measurementsChanged() |                     |
| 设置改变方法setMeasurements    |                     |

### 三个接口

```java
package service;
import service.Observer;
public interface Subject {
    public void registerObserver(Observer o);
    public void removeObserver(Observer o);
    public void notifyObserver();
    }
package service;

public interface Observer {
    public void update(float temp,float humidity,float pressure);
}
package service;

public interface DisplayElement {
    public void display();
}

```

### 两个类

```java
package model;

import service.Subject;

import java.util.ArrayList;
import service.Observer;

public class WeatherData implements Subject {
    private ArrayList observers;
    private float temprature;
    private float humidity;
    private float pressure;


    public WeatherData(){
        observers = new ArrayList();
    }


    public void registerObserver(Observer o) {
        observers.add(o);
    }

    public void removeObserver(Observer o) {
        int i= observers.indexOf(o);
        if(i>=0){
            observers.remove(i);
        }
    }



    public void notifyObserver() {
        for(int i=0;i<observers.size();i++){
            Observer observer = (Observer)observers.get(i);
            observer.update(temprature,humidity,pressure);
        }

    }

    public void measurementsChanged(){
        notifyObserver();
    }

    public void setMeasurements(float temprature,float humidity,float pressure) {
        this.temprature = temprature;
        this.humidity = humidity;
        this.pressure = pressure;
        measurementsChanged();
    }
}

```

```java
package model;

import controller.CurrentConditionsDisplay;
import model.WeatherData;

public class WeatherStation {
    public static void main(String[] args) {
        WeatherData weatherData = new WeatherData();
        CurrentConditionsDisplay currentConditionsDisplay = new CurrentConditionsDisplay(weatherData);
        weatherData.setMeasurements(80,65,30.4f);
        weatherData.setMeasurements(82,66,30.4f);
        weatherData.setMeasurements(83,75,29.4f);

    }
}
```

### 测试函数

```****
package controller;

import service.DisplayElement;
import service.Observer;
import service.Subject;

public class CurrentConditionsDisplay implements Observer, DisplayElement {
    private float temprature;
    private float humidity;
    private Subject weatherData;

    public CurrentConditionsDisplay(Subject weatherData) {
        this.weatherData = weatherData;
        weatherData.registerObserver(this);
    }


    public void update(float temp, float humidity, float pressure) {
        this.temprature = temp;
        this.humidity = humidity;
        display();

    }


    public void display() {
        System.out.println("Current condition"+temprature);
        System.out.println("Current F degree"+humidity);
    }

}
```

### 使用java内置Observer改写

首先把WeatherData改成使用java.util.Observable

改写了measurementsChanged方法，同时删去了对三个observer接口的实现

```java
package model;

import java.util.ArrayList;
import java.util.Observable;

import service.Observer;

public class WeatherData extends Observable {
    private ArrayList observers;
    private float temprature;
    private float humidity;
    private float pressure;


    public WeatherData(){
        observers = new ArrayList();
    }

    public void measurementsChanged(){
        setChanged();
        notifyObservers();
    }

    public void setMeasurements(float temprature,float humidity,float pressure) {
        this.temprature = temprature;
        this.humidity = humidity;
        this.pressure = pressure;
        measurementsChanged();
    }

    public float getTemprature() {
        return temprature;
    }

    public float getHumidity() {
        return humidity;
    }

    public float getPressure() {
        return pressure;
    }
}

```

* 在java自带的观察者类中，Observable表示可观察者，用来替代subject，即发送消息的一方
* observer则表示观察者，接收条件的一方

```java
package model;

import model.WeatherData;
//import service.DisplayElement;
import java.util.Observable;
import java.util.Observer;

public class CurrentConditionsDisplay implements Observer {
    Observable observable;
    private float temprature;
    private float humidity;


    public CurrentConditionsDisplay(Observable observable) {
        this.observable = observable;
        observable.addObserver(this);
       // weatherData.registerObserver(this);
    }
    public void update(Observable obs,Object arg) {
        if (obs instanceof WeatherData){
            WeatherData weatherData = (WeatherData)obs;
            this.temprature = weatherData.getTemprature();
            this.humidity = weatherData.getHumidity();
            display();
        }
    }
    public void display() {
        System.out.println("Current condition"+temprature+"   and Current F degree"+humidity);
        System.out.println();
    }

}
```



### 第二章要点

* 观察者模式定义了对象之间一对多的关系、
* 主题（也就是可观察者）用一个共同的接口来更新观察者
* 观察者和可观察者之间使用松耦合方式结合，可观察者不知道观察者的细节，只知道观察者实现了观察者接口
* 使用此模式时，可从被观察者处推（push）或拉（poll）数据，然而推的方式被认为更正确
* 有多个观察者时，不可以依赖特定的通知次序
* java有多种观察者模式的实现，包括了通用的java.util.Observable
* 要注意java.util.Observable
* 要注意java.util.Observable实现上所带来的一些问题
* 如果有必要的话，可以实现自己的Observable，这并不难
* Swing使用大量的观察者模式，许多GUI框架也是如此
* 此模式也被应用在许多地方，例如JavaBeans\RMI 



# 3. 装饰者模式

**本章可以称为给爱用继承的人一个全新的设计眼界**

我们即将再次探讨典型的继承滥用问题，你将在本章学到如何使用对象组合的方式，做到在运行时装饰类。

## 开放-关闭原则

* 类应该对扩展开放，对修改关闭

**我们的目标是允许类容易扩展，在不修改现有代码的情况下就可以搭配新的行为。这样的设计具有弹性可以应对改变，可以接受新的功能来应对改变的需求**

* 问：对扩展开放，对修改关闭听起来很矛盾，如何兼顾两者

有一些聪明的OO技巧，允许系统在不修改代码的情况下，进行功能的扩展，想想观察者模式。通过加入新的观察者，我们可以在任何时候扩展Subject，而且不需要向主题中添加代码。

* 问：如何将某件东西设计的可以扩展有禁止修改

许多模式是长期经验的实证，可通过提供扩展的方法保护代码免于被修改

* 如何让设计的每个部分都遵循开放-关闭原则

## 认识装饰者模式

以咖啡馆为例

以饮料为主题，然后在运行时以调料来“装饰”饮料，比方说，如果顾客想要摩卡和奶泡深焙咖啡，那么，要做的是

1. 拿一个深焙咖啡（DarkRoast）对象
2. 以摩卡（Mocha）对象装饰它
3. 以奶泡（Whip）对象装饰它
4. 调用cost（）方法，并依赖委托（delegate）将调理的价钱加上去

已知条件

* 装饰者和被装饰对象具有相同的超类型
* 可以用一个或多个装饰者包装一个对象
* 既然装饰者和被装饰者对象有相同的超类型，所以在任何需要原始对象（被包装的）的场合，可以用装饰过的对象替代它
* 装饰者可以在所委托被装饰者的行为之前与之后加上自己的行为，已达到特定的目的
* 对象可以在任何时候被装饰，所以可以在运行时动态地、不限量地用喜欢的装饰者来装饰对象

## 定义装饰者模式

装饰者模式动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案

![image-20220308192609673](E:\gitfile\mypages\modiman.github.io\docs\_posts\image-20220308192609673.png)

## 装饰饮料



### 首先定义基类Beverage

```java
package s3decorator;

public abstract class Beverage {
    //饮料类
    String description = "Unknown Beverage";

    public String getDescription() {
        return description;
    }
    public abstract double cost();
}
```

### 实现调料抽象类，也就是装饰者类

```java
package s3decorator;

/**
 * @author: modige
 * @date: 2022/3/8 18:47
 * @description:调料抽象类，也就是装饰者类
 */
public abstract class CondimentDecorator extends Beverage{
//首先必须让Condiment Decorator 能够取代Beverage，所以将Condiment Decorator 扩展自Beverage类
    public abstract String getDescription();
    //所有的调料装饰者必须重新实现getDescription方法

}
```

### 实现一些饮料

包括

* 浓缩咖啡Espresso、

* 综合咖啡house blend  coffee、

* 深焙咖啡dark roast

  (分别在三个不同文件，此处放在一起)

```java
package s3decorator;

/**
 * @author: modige
 * @date: 2022/3/8 18:52
 * @description:
 */
public class Espresso extends Beverage {

    public Espresso(){
        description = "Espresso";//description继承自neverage
    }
    @Override
    public double cost(){
        return 1.99;
        //最后需要计算Espresso的价钱，现在不需要管调料的价钱，直接把Espresso的价格1.99返回即可
    }
}
public class HouseBlend extends Beverage {
    public HouseBlend (){
        description = "House Blend Coffee";

    }

    @Override
    public double cost() {
        return .89;
    }
}
public class DarkRoast extends Beverage{
    public DarkRoast(){
        description = "Dark Roast Coffee";
    }

    @Override
    public double cost() {
        return 1.05;
    }
}
```

### 写调料代码

CondimentDecorator的具体组件，也就是具体装饰者，包括

* Mocca
* Whip

```java
package s3decorator;

/**
 * @author: modige
 * @date: 2022/3/8 18:58
 * @description:具体装饰者
 */
public class Mocha extends CondimentDecorator {
    Beverage beverage ;
    /*
    * 要让Mocha能够引用一个Beverage，做法如下
    * 1. 用一个实例变量记录饮料，也就是被装饰者
    * 2. 想办法让被修饰者被记录到实例变量中这里的做法是
    *     把饮料当做是构造器的参数，再由构造器将此饮料
    *    记录在实例变量中
    *   * */
    public Mocha(Beverage beverage) {
        this.beverage = beverage;
    }

    public String getDescription() {
        return beverage.getDescription() + ",Mocha";
        /*
        * 希望不只是描述饮料如DarkRoast  而是完整地连
        * 调料都描述出来，所以首先利用委托的做法，得到
        * 一个叙述，然后再其上加上附加的叙述
        *
        * */

    }

    public double cost() {
        return.20 + beverage.cost();
    }
}
public class Whip extends CondimentDecorator{
    Beverage beverage ;
    public Whip(Beverage beverage){
        this.beverage = beverage;
    }
    public String getDescription(){
        return beverage.getDescription() + ",Whip";
    }
    public double cost(){
        return beverage.cost()+.20;
    }
}

```

## 真实世界的装饰者 Java I/O

## OO原则

* 封装变化
* 多用组合，少用继承
* 针对接口编程，不针对实现编程
* 为交互对象之间的松耦合设计而努力
* 对扩展开放，对修改关闭

## 第三章要点

* 继承术语扩展形式之一，但不见得是达到弹性设计的最佳方式
* 在设计中，应允许行为可以被扩展，而无需修改现有的代码
* 组合和委托可用于在运行时动态地加上新的行为
* 除了继承，装饰者模式也可以扩展行为
* 装饰者模式意味着一群装饰者类，这些类用来包装具体组件
* 装饰者类反映出被装饰的组件类型，
* 装饰者可以在被装饰者的行为前面加上自己的行为
* 可以用无数个装饰者包装一个组件
* 装饰者一般对组件的客户是透明的，除非客户程序依赖于组建的具体类型
* 装饰者会导致设计中出现许多小对象，如果过度使用，会让程序变得很复杂

