## 字典排序

```python
word_dict = sorted(word_dict.items(),key=lambda item:item[1],reverse=True)
'''

这里的d.items()实际上是将d转换为可迭代对象，迭代对象的元素为（‘lilee’,25）、（‘wangyan’,21）、（‘liqun’,32）、（‘lidaming’,19），items()方法将字典的元素转化为了元组，而这里key参数对应的lambda表达式的意思则是选取元组中的第二个元素作为比较参数（如果写作key=lambda item:item[0]的话则是选取第一个元素作为比较对象，也就是key值作为比较对象。
'''

```

## 装饰器

常用场景

* 计算函数运行时间
* 给函数打日志
* 类型检查

https://www.zhihu.com/search?type=content&q=python%E8%A3%85%E9%A5%B0%E5%99%A8

## 文件打开方式

## 3. 打开方式

在刚才的实例中，open 方法的第二个参数设置成了 a，这样在每次写入文本时不会清空源文件，而是在文件末尾写入新的内容，这是一种文件打开方式。关于文件的打开方式，其实还有其他几种，这里简要介绍一下。

- r：以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。
- rb：以二进制只读方式打开一个文件。文件指针将会放在文件的开头。
- r+：以读写方式打开一个文件。文件指针将会放在文件的开头。
- rb+：以二进制读写方式打开一个文件。文件指针将会放在文件的开头。
- w：以写入方式打开一个文件。如果该文件已存在，则将其覆盖。如果该文件不存在，则创建新文件。
- wb：以二进制写入方式打开一个文件。如果该文件已存在，则将其覆盖。如果该文件不存在，则创建新文件。
- w+：以读写方式打开一个文件。如果该文件已存在，则将其覆盖。如果该文件不存在，则创建新文件。
- wb+：以二进制读写格式打开一个文件。如果该文件已存在，则将其覆盖。如果该文件不存在，则创建新文件。
- a：以追加方式打开一个文件。如果该文件已存在，文件指针将会放在文件结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，则创建新文件来写入。
- ab：以二进制追加方式打开一个文件。如果该文件已存在，则文件指针将会放在文件结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，则创建新文件来写入。
- a+：以读写方式打开一个文件。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，则创建新文件来读写。
- ab+：以二进制追加方式打开一个文件。如果该文件已存在，则文件指针将会放在文件结尾。如果该文件不存在，则创建新文件用于读写。

# 基本数据类型

## set

* <a href="https://github.com/python/cpython/blob/main/Objects/setobject.c">源码</a>
* <a href="https://stackoverflow.com/questions/8608587/finding-the-source-code-for-built-in-python-functions">讨论</a>
* 



### 遍历

```bash
for s in set:
	print(s)
```

## 判断是否存在元素

```python
x in set
```

## 差集

```python
a-b
# 源码
def difference(self, *args, **kwargs): # real signature unknown
        """
        Return the difference of two or more sets as a new set.
        
        (i.e. all elements that are in this set but not the others.)
        """
        pass
```

### 补充

当我想看set求差集函数源码时，发现函数体中只有一个占位符pass,

百度说像这种源码函数体中只有一个pass的，说函数是由C 实现的

去stack overflow查询，结果

```
PyCharm is lying to you. The source code you're looking at is a fake that PyCharm has created. PyCharm knows what functions should be there, and it can guess at their signatures using the function docstrings, but it has no idea what the function bodies should look like.

If you want to see the real source code, you can look at it in the official Github repository in Modules/mathmodule.c. A lot of the functions in there are macro-generated thin wrappers around C functions from math.h, but there's also a bunch of manually-written code to handle things like inconsistent or insufficient standard library implementations, functions with no math.h equivalent, and customization hooks like __ceil__.
```

pycharm在撒谎，想看真正的python源码到github上看

### 分辨真假源码

通过文件路径辨别真假源码

* 真：\Python\Python<version>\Lib\
* 假：\PyCharm<version>\system\python_stubs\ 

# 面向对象编程

和java一样，想要改写python第三方库函数时，只用继承模块中的类并重写其中的函数即可

```python
import torch.nn as nn
import torch.nn.functional as F

class Model(nn.Module):
    def __init__(self):
        super(Model, self).__init__()
        self.conv1 = nn.Conv2d(1, 20, 5)
        self.conv2 = nn.Conv2d(20, 20, 5)
    def forward(self, x):
        x = F.relu(self.conv1(x))
        return F.relu(self.conv2(x))
```

Model继承nn.module，并重写了init和forward函数