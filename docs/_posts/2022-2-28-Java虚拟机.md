# 内存管理

## 运行时数据区

### 程序计数器

* 当前线程执行的字节码的行号指示器
* 字节码解释器通过修改计数器的值来决定下一条需要执行的字节码指令
* 每个线程对应一个程序计数器--》线程私有
* 没有Out Of Memory Error

### 虚拟机栈

* 线程私有
* 生命周期与线程相同
* 描述的是方法对应的内存模型
* 方法被执行时虚拟机创建一个栈帧，存储局部变量表、操作数栈、动态链接方法出口等信息
* 如果栈帧请求的深度超出范围，抛出stack overflow
* 如果虚拟接允许栈扩容但无法申请到足够的内存抛出oom error

### 本地方法栈

与虚拟机栈类似

### 堆

* 被所有线程共享
* 唯一目的就是存放对象
* 由垃圾收集器管理
* 常常会分代

### 方法区

* 线程共享
* 存储被虚拟机加载的类型信息、常量、静态变量、代码缓存等数据
* 别称为永久代
* 不需要连续的内存
* 无法满足新的内存分配时会抛出OOME

### 运行时常量池

### 直接内存

# 垃圾回收

* [回收](https://juejin.cn/post/6911668514096955406)

回收之前判断对象是否存活

## 引用计数法

给对象添加一个引用计数器，引用+1，失效-1，为0表示不被使用。

**缺点**：无法解决循环依赖

## 可达性分析算法

以GC Roots作为起点向下搜索，如果不能搜索到某个对象，证明它可回收	

![image-20220815204217068](E:\gitfile\modiman.github.io\docs\_posts\imgs\image-20220815204217068.png)

 **可作为GC Roots的对象**

* 虚拟机栈中引用的对象
* 方法区中类静态属性引用的对象
* 方法区中常量引用的对象
* 本地方法栈中JNI引用的对象

## 分代结构

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45a74a5765b74ad4857511271c922ecf~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

* 对象优先分配在 Eden 区
* 大对象直接进入老年代
* 长期存活的对象将进入老年代
* 动态对象年龄判断
* 空间分配担保

## 引用

* 强引用
* 软引用
* 弱引用
* 虚引用

## 手动GC

```java
System.gc();
// 或者下面，两者等价
Runtime.getRuntime().gc();
```

System.gc();
另Java的GC是由JVM自行调动的，在需要的时候才执行，上面的指令只是告诉JVM尽快GC一次，但不会立即执行GC。

## 垃圾收集算法

### 标记-清除 mark-sweep

标记出所有需要回收的对象，统一回收

**缺点**：效率不高，产生不连续碎片浪费空间

### 复制算法

将可用内存分为两块，每次只用一块，满了之后将活着的移到另一块，然后将已经使用过的一次清理 

**缺点**：只有一半内存可用

### 标记-整理  mark-compact

标记，将存活的对象向一段移动，清理掉端边界以外的内存

### 分代收集

根据对象存活周期将堆分为新生代、老年代

* 新生代：只有少量存活，选择复制算法
* 老年代：对象存活率高，采用标记-清理/整理

## 垃圾收集器

### CMS收集器 

Concurrent mark sweep

致力于减小系统停顿时间，常用于B/S结构的服务器端、

流程

1. 初始标记
2. 并发标记
3. 重新标记
4. 并发清除

**缺点**：

* 对CPU资源敏感
* 无法处理浮动垃圾
* 产生大量不连续碎片

### G1收集器

面向服务端的垃圾收集器

特点

* 并发与并行：利用多CPU优势缩短停顿时间
* 分代收集：用不同的方式处理新创建的、存活一段时间的对象
* 空间整合：不会产生大量碎片
* 可预测的停顿：

流程

1. 初始标记
2. 并发标记
3. 最终标记
4. **筛选回收**

# JVM调优

## 参数

Jvm调优典型参数设置;

1. -Xms堆内存的最小值：

   - 默认情况下，当堆中可用内存小于40%时，堆内存会开始增加，一直增加到-Xmx的大小。

2. -Xmx堆内存的最大值：

   默认值是总内存/64（且小于1G）

   - 默认情况下，当堆中可用内存大于70%时，堆内存会开始减少，一直减小到-Xms的大小；

3. -Xmn新生代内存的最大值：

   - 1.包括Eden区和两个Survivor区的总和
   - 2.配置写法如：-Xmn1024k，-Xmn1024m，-Xmn1g

4. -Xss每个线程的栈内存：

   - 默认1M，一般来说是不需要改。线程栈越小意味着可以创建的线程数越多

## 流程

* 第一步：监控分析GC日志

* 第二步：判断JVM问题：

  - 如果各项参数设置合理，系统没有超时日志出现，GC频率不高，GC耗时不高，那么没有必要进行GC优化

  - 如果GC时间超过1-3秒，或者频繁GC，则必须优化。

    

    第三步：确定调优目标

  第四步：调整参数

  - 调优一般是从满足程序的内存使用需求开始，之后是时间延迟要求，最后才是吞吐量要求，要基于这个步骤来不断优化，每一个步骤都是进行下一步的基础，不可逆行之。

  第五步：对比调优前后差距

  第六步：重复： 1 、 2 、 3 、 4 、 5 步骤

  - 找到最佳JVM参数设置

  第七步：应用JVM到应用服务器：

  - 找到最合适的参数，将这些参数应用到所有服务器，并进行后续跟踪。
  - 
  - 
  - 作者：llsydn
    链接：https://juejin.cn/post/7128377003224334373
    来源：稀土掘金
    著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## 内存分配

* 对象优先在eden分配
* 大对象直接进入老年代
* 长期存活的对象进入老年代
* 

# 类加载

## calssloader

​		**虚拟机把描述类的数据从class字节码文件加载到内存，并对数据进行检验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。**

### 加载过程

家宴准备了西式菜

1. **加载** 把class字节码从各个来源通过加载器装进内存
2. **验证** 保证加载进来的字节流合乎虚拟机规范，不会造成安全错误
3. **准备** 为类变量分配内存，并且赋予初值
4. **解析**  将常量池中的符号引用替换成直接饮用
5. **初始化** 对类变量进行初始化，是执行构造器的基础

### 双亲委派

多个类加载器之间存在父子关系的时候，某个class类具体由哪个加载器进行加载的问题。

* 当一个类加载的时候，它不会首先去加载，而是委托给自己的父类去加载，
* 父类又委托给自己的父类。
* 所有的类加载都会委托给顶层的父类 Bootstrap Classloader
* 父类无法完成时子类加载器才会自己完成

**作用**：

1. 避免类的重复加载
2. 避免核心类被不不同的类加载到内存中造成冲突和混乱，从而保护了java核心库的安全

| 加载器                    | 范围                                                       |      |
| ------------------------- | ---------------------------------------------------------- | ---- |
| 启动类加载器Boostrap      | <Java_Home>/lib,r如java.io\|java.util\|java.lang           |      |
| 扩展类加载器Extention     | 以javax开头，<Java_Home>/lib/ext目录下                     |      |
| 应用程序加载器Application | 用户路径classpath上指定的类库，自己编写的类以及第三方jar包 |      |
| 自定义加载器Custom        | 为了某些特殊目的实现的自定义加载器                         |      |

### 应用场景

**依赖冲突**：

![image-20220822095304982](H:\gitfile\modiman.github.io\docs\_posts\imgs\image-20220822095304982.png)



├─业务
│  ├─fastjson1
│  ├─中间件
│  │  └─fastjson2
│  └─微服务
│      └─fastjson2

在这种业务逻辑中，业务层有自己的依赖fastjson1.0，中间件和微服务又有各自版本的fastjson2,3

根据maven依赖处理机制，只会加载fastjson1

**解决方案**：通过自定义类加载器，为每个中间件自定义一个加载器，这些加载器之间的关系是平行的，彼此没有依赖关系。

这样每个中间件的classloader就可以加载各自版本 的fastjson。因为一个类的全限定名以及加载该类的加载器两者共同形成了这个类在JVM中的惟一标识，这也 是阿里pandora实现依赖隔离的基础。

## 加载顺序

​         关于关键字static，大家 都知道它是静态的，相当于一个全局变量，也就是这个属性或者方法是可以通过类来访问，当class文件被加载进内存，开始初始化的时候，被static修饰的变量或者方法即被分配了内存，而其他变量是在对象被创建后，才被分配了内存的。

所以在类中，加载顺序为：

1.首先加载父类的静态字段或者静态语句块

2.子类的静态字段或静态语句块

3.父类普通变量以及语句块

4.父类构造方法被加载

5.子类变量或者语句块被加载

6.子类构造方法被加载
