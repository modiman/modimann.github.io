# 内存管理

## 运行时数据区

### 程序计数器

* 当前线程执行的字节码的行号指示器
* 字节码解释器通过修改计数器的值来决定下一条需要执行的字节码指令
* 每个线程对应一个程序计数器--》线程私有
* 没有Out Of Memory Error

### 虚拟机栈

* 线程私有
* 生命周期与线程相同
* 描述的是方法对应的内存模型
* 方法被执行时虚拟机创建一个栈帧，存储局部变量表、操作数栈、动态链接方法出口等信息
* 如果栈帧请求的深度超出范围，抛出stack overflow
* 如果虚拟接允许栈扩容但无法申请到足够的内存抛出oom error
* 局部变量表存储
  * 基本数据类型
  * 对象引用
  * returnAddress类型

### 本地方法栈

与虚拟机栈类似

### 堆

* 被所有线程共享
* 唯一目的就是存放对象
* 由垃圾收集器管理
* 常常会分代

### 方法区

* 线程共享
* 存储被虚拟机加载的类型信息、常量、静态变量、代码缓存等数据
* 别称为永久代
* 不需要连续的内存
* 无法满足新的内存分配时会抛出OOME

### 运行时常量池

### 直接内存

## 内存溢出

* [Java中的内存泄漏与内存溢出介绍](https://juejin.cn/post/6972730787464642574)

### 内存溢出

### 内存泄露

申请的内存用完了不释放

**八种情况**

1. 静态集合类，如果容器是静态的，那么他们的生命周期和JVM一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。

   ```java
   //list是长生命周期的对象
   //即使 Object()是生命周期，在list被回收之前也不能被回收
   static List list = new ArrayList();
   list.add(new Object());
   ```

2. 单例模式 因为单例的静态特性，如果单例对象如果持有外部对象的引用，那么这个外部对象也不会被回收

3. 内部类持有外部类 

4. 各种连接  在对数据库等的连接中，如果不显式关闭，会造成大量对象无法被回收

5. 

# 垃圾回收

* [回收](https://juejin.cn/post/6911668514096955406)

回收之前判断对象是否存活

## 引用计数法

给对象添加一个引用计数器，引用+1，失效-1，为0表示不被使用。

**缺点**：无法解决循环依赖

## 可达性分析算法

以GC Roots作为起点向下搜索，如果不能搜索到某个对象，证明它可回收	

![image-20220815204217068](E:\gitfile\modiman.github.io\docs\_posts\imgs\image-20220815204217068.png)

 **可作为GC Roots的对象**

* 虚拟机栈中引用的对象
* 方法区中类静态属性引用的对象
* 方法区中常量引用的对象
* 本地方法栈中JNI引用的对象



## 分代结构

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45a74a5765b74ad4857511271c922ecf~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

* 对象优先分配在 Eden 区
* 大对象直接进入老年代
* 长期存活的对象将进入老年代
* 动态对象年龄判断
* 空间分配担保

## 引用

* 强引用  使用new创建的对象，只要强引用还在就不会被回收
* 软引用  有用但并非必须的对象，在系统将要发生内存溢出之前会把这些对象回收，如果内存仍然不够再抛出异常
* 弱引用 非必须对象 只能生存到下一次垃圾回收发生之前，到时无论内存是否够用都会被回收
* 虚引用 唯一作用是在对象被回收时收到一个系统通知

## 手动GC

```java
System.gc();
// 或者下面，两者等价
Runtime.getRuntime().gc();
```

System.gc();
另Java的GC是由JVM自行调动的，在需要的时候才执行，上面的指令只是告诉JVM尽快GC一次，但不会立即执行GC。

## 垃圾收集算法

### 标记-清除 mark-sweep

标记出所有需要回收的对象，统一回收

**缺点**：效率不高，产生不连续碎片浪费空间

**原因**：对对象进行可达性分析，不可达的标记为待回收的内存区域，由于内存是连续的但待回收的内存区域未必是连续的，因此这些垃圾被清除之后会将内存切分成一个个不连续的片段，也就是产生不连续碎片

### 复制算法

将可用内存分为两块，每次只用一块，满了之后将活着的移到另一块，然后将已经使用过的一次清理 

**缺点**：只有一半内存可用

### 标记-整理  mark-compact

标记，将存活的对象向一段移动，清理掉端边界以外的内存，解决了标记-清除具有的产生内存碎片的问题

### 分代收集

根据对象存活周期将堆分为新生代、老年代

* 新生代：只有少量存活，选择复制算法
* 老年代：对象存活率高，采用标记-清理/整理

## 垃圾收集器

**储备知识**

* 根据不同分代的特点，收集器可能不同。有些收集器可以同时用于新生代和老年代，而有些时候，则需要分别为新生代或老年代选用合适的收集器。一般来说，新生代收集器的收集频率较高，应选用性能高效的收集器；而老年代收集器收集次数相对较少，对空间较为敏感，应当避免选择基于复制算法的收集器。
* **在垃圾收集执行的时刻，应用程序需要暂停运行**。（Stop the world）
* 可以串行收集，也可以并行收集。
* 如果能做到并发收集（应用程序不必暂停），那绝对是很妙的事情。
* 如果收集行为可控，那也是很妙的事情。

### CMS收集器 

Concurrent mark sweep

致力于减小系统停顿时间，常用于B/S结构的服务器端、

流程

其中，`初始标记`、`重新标记`这两个步骤仍然需要Stop-the-world。**初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始阶段稍长一些，但远比并发标记的时间短。**

>  CMS以流水线方式拆分了收集周期，将耗时长的操作单元保持与应用线程并发执行。只将那些必需STW才能执行的操作单元单独拎出来，控制这些单元在恰当的时机运行，并能保证仅需短暂的时间就可以完成。这样，在整个收集周期内，只有**两次短暂的暂停（初始标记和重新标记）**，**达到了近似并发的目的**。

### G1收集器



面向服务端的垃圾收集器

特点

* 并发与并行：利用多CPU优势缩短停顿时间
* 分代收集：用不同的方式处理新创建的、存活一段时间的对象
* 空间整合：不会产生大量碎片
* 可预测的停顿：

流程

1. 初始标记
2. 并发标记
3. 最终标记
4. **筛选回收**

### CMS与G1区别

**G1与CMS的特征对比如下：**

| 特征                     | G1                                                 | CMS                                                         |
| :----------------------- | :------------------------------------------------- | :---------------------------------------------------------- |
| 并发和分代               | 是，传统分代                                       | 是，将堆分成region                                          |
| 算法                     | 标记-清除                                          | 标记-整理+复制                                              |
| 最大化释放堆内存         | 是                                                 | 否                                                          |
| 吞吐量                   | 高                                                 | 低                                                          |
| 可预测性                 | 强                                                 | 弱                                                          |
| 新生代和老年代的物理隔离 | 否                                                 | 是                                                          |
| 流程                     | 初始标记<br>并发标记 <br>最终标记 <br>**筛选回收** | 初始标记 <br/>并发标记 <br/>重新标记 <br/>并发清除          |
| 缺点                     |                                                    | 对CPU资源敏感<br/> 无法处理浮动垃圾<br/> 产生大量不连续碎片 |
| 算法                     | 标记-整理                                          | 标记-清除                                                   |
| 流程                     | 最终标记                                           | 重新标记stw,                                                |
| 流程                     | 筛选回收最有价值region                             | 并发清除                                                    |

**解析**

1. CMS基于标记清除产生内存碎片（因此CMS只作用于老年代），G1不会，因为使用标记-整理算法会将垃圾挤到边界
2. G1将堆内存切割成大小相同的region，新生代和老年代都是一部分region的集合
3. **可预测的停顿时间**：避免在整个java堆中垃圾回收，而是化整为零，有限回收价值最大的region
4. 



当垃圾收集器认为一个对象不被引用时会调用这个方法


=======
得分点 整堆、Region、标记整理、四个步骤 

**标准回答** Garbage First（G1）收集器开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。

* 在G1收集器出现之前的所有其他收集器,垃圾收集的目标范围要么是整个新生代,要么就是整个老年代,再要么就是整个Java堆。
* 而G1跳出了这个限制,它可以面向堆内存任何部分来组成回收集进行回收,衡量标准不再是它属于哪个分代,而是哪块内存中存放的垃圾数量最多,回收收益最大,这就是G1收集器的Mixed GC模式。
* G1也仍是遵循分代收集理论设计的,但其堆内存的布局与其他收集器有非常明显的差异：
  * G1不再坚持固定大小以及固定数量的分代区域划分,而是把连续的Java堆划分为多个大小相等的独立区域（Region）,每一个Region都可以根据需要,扮演新生代的Eden空间、Survivor空间,或者老年代空间。
  * 此外,还有一类专门用来存储大对象的特殊区域（Humongous Region）。
  * G1认为只要超过了Region一半的对象即可判定为大对象。
  * 而对于那些超过了整个Region容量的超级大对象,将会被存放在N个连续的Humongous Region之中,G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待。 
  * 更具体的处理思路是,让G1收集器去跟踪各个Region里面的垃圾堆积的“价值”大小,价值即回收所获得的空间大小以及回收所需时间的经验值,然后在后台维护一个优先级列表,每次根据用户设定允许的收集停顿时间,优先处理回收价值收益最大的那些Region,这也就是“Garbage First”名字的由来。 
  * 
* G1收集器的运作过程大致可划分为以下四个步骤：初始标记、并发标记、最终标记、筛选回收。
* 其中,初始标记和最终标记阶段仍然需要停顿所有的线程,但是耗时很短。
* 加分回答 G1与CMS的对比： 
* G1从整体来看是基于标记整理算法实现的收集器,但从局部上看又是基于标记复制算法实现。
* 无论如何,这两种算法都意味着G1运作期间不会产生内存空间碎片,垃圾收集完成之后能提供规整的可用内存。
* 比起CMS,G1的弱项也可以列举出不少。例如在用户程序运行过程中,G1无论是为了垃圾收集产生的内存占用还是程序运行时的额外执行负载都要比CMS要高。
* G1与CMS的选择： 目前在小内存应用上CMS的表现大概率仍然要会优于G1,而在大内存应用上G1则大多能发挥其优势,这个优劣势的Java堆容量平衡点通常在6GB至8GB之间。
* 以上这些也仅是经验之谈,随着HotSpot的开发者对G1的不断优化,也会让对比结果继续向G1倾斜

## Finalizer 机制

当一个对象的生命周期即将终结时，也就是即将被垃圾收集器回收之前，虚拟机就会调用对象的 finalize() 方法，从而提供了一个释放资源的时机。

### finalize() 方法

Object类下的一个没有方法体的无返回值方法

```java
protected void finalize() throws Throwable { }
```

* 
>>>>>>> 0ded46f7c0b2dbc8163e69b7a1a4deaa316fc35f

# 执行子系统

* 一次编译，到处执行基于所有平台都统一支持的程序存储格式--字节码

* jvm可以运行多种语言，提供了多种语言的编译器来生成class文件
* jvm不与语言绑定而是和class文件绑定
* ![image-20221002104645290](E:\gitfile\modiman.github.io\docs\_posts\imgs\image-20221002104645290.png)



## class类文件

由于class文件没有分隔符，所以结构严格定义，哪个字节代表什么，长度是多少、先后顺序都不允许改变

### 1.魔数

* **位置**：头四个字节
* **作用**：类身份识别
* 

# JVM调优

## 参数

Jvm调优典型参数设置;

1. -Xms堆内存的最小值：

   - 默认情况下，当堆中可用内存小于40%时，堆内存会开始增加，一直增加到-Xmx的大小。

2. -Xmx堆内存的最大值：

   默认值是总内存/64（且小于1G）

   - 默认情况下，当堆中可用内存大于70%时，堆内存会开始减少，一直减小到-Xms的大小；

3. -Xmn新生代内存的最大值：

   - 1.包括Eden区和两个Survivor区的总和
   - 2.配置写法如：-Xmn1024k，-Xmn1024m，-Xmn1g

4. -Xss每个线程的栈内存：

   - 默认1M，一般来说是不需要改。线程栈越小意味着可以创建的线程数越多

## 流程

* 第一步：监控分析GC日志

* 第二步：判断JVM问题：

  - 如果各项参数设置合理，系统没有超时日志出现，GC频率不高，GC耗时不高，那么没有必要进行GC优化

  - 如果GC时间超过1-3秒，或者频繁GC，则必须优化。

    

    第三步：确定调优目标

  第四步：调整参数

  - 调优一般是从满足程序的内存使用需求开始，之后是时间延迟要求，最后才是吞吐量要求，要基于这个步骤来不断优化，每一个步骤都是进行下一步的基础，不可逆行之。

  第五步：对比调优前后差距

  第六步：重复： 1 、 2 、 3 、 4 、 5 步骤

  - 找到最佳JVM参数设置

  第七步：应用JVM到应用服务器：

  - 找到最合适的参数，将这些参数应用到所有服务器，并进行后续跟踪。
  - 
  - 
  - 作者：llsydn
    链接：https://juejin.cn/post/7128377003224334373
    来源：稀土掘金
    著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## 内存分配

* 对象优先在eden分配
* 大对象直接进入老年代
* 长期存活的对象进入老年代

# 类加载

**虚拟机把描述类的数据从class字节码文件加载到内存，并对数据进行检验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。**



## 类加载的时机

什么时候开始**加载**并没有严格规定，但当以下六种情况发生时必须开始**初始化**

而由于加载、验证、准备必须发生在初始化之前，所以这意味着当下面六种情况发生时，（加载、验证、准备、解析）等步骤也必须发生

下文中的**类型**包括类和接口

1. 遇到指定字节码，比如以下情况
   * 使用new实例化对象
   * 读取或设置静态变量（被final修饰除外，因为已经在编译期把结果放进常量池）
   * 调用一个类型的静态方法
2. 对类型进行反射调用
3. 初始化类时，发现其父类没有初始化，需要初始化其父类
4. 虚拟机启动时，用户需要指定一个要执行的主类（包含main方法的那个类），虚拟机先初始化这个主类
5. 与JDK7有关，略
6. 当一个接口定义了jdk8新加入的默认方法时（被default修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化

这六种场景可以被称为对一个类型进行**主动引用**，与之对应的是**被动引用**，下面举例说明

```java
class YeYe{
    public  static String strYeYe="HelloJVM_YeYe";

    static {
        System.out.println("YeYe静态代码块");
    }
}

class Father extends YeYe{
    public final static String strFather="HelloJVM_Father";

    static{
        System.out.println("Father静态代码块");
    }
}

class Son extends Father{
    public static String strSon="HelloJVM_Son";

    static{
        System.out.println("Son静态代码块");
    }
}
```

上面定义了子、父、祖父三个具有继承关系的类，其中`Father`拥有一个以`static final`修饰的变量，`Son`拥有一个以`strFather`修饰的变量

下面考虑以下调用会出现的情况

1. ```java
   System.out.println(Son.strFather);
   ```

   只输出`HelloJVM_Father`,这是因为由于使用`static final`修饰`strFather`,该变量已经被加载进主函数所在的类的常量池中，此时它已经和Father类没有什么关系了

2. ```java
   System.out.println(Son.strFather);
   //输出
   //YeYe静态代码块
   //HelloJVM_YeYe
   ```

   上述两个调用都没有加载Son本身的静态代码段，这是因为对于静态字段，只有直接定义这个字段的类会被初始化，因此通过子类调用父类的静态字段并不会触发子类的初始化

3. 

## 加载过程

家宴准备了西式菜

1. **加载** 把class字节码从各个来源通过加载器装进内存
2. **验证** 保证加载进来的字节流合乎虚拟机规范，不会造成安全错误
3. **准备** 为类变量分配内存，并且赋予初值
4. **解析**  将常量池中的符号引用替换成直接饮用
5. **初始化** 对类变量进行初始化，是执行构造器的基础
6. 使用
7. 卸载

### 加载

1. 通过类名获取类的二进制字节流
2. 将字节流代表的静态数据结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问接口

值得注意的是，二进制字节流未必从本地获取，还有以下渠道

* ZIP压缩包（war,jar等）
* 网络中获取
* 运行时计算产生，如动态代理技术，
* JSP产生
* 数据库读取

加载阶段结束后，虚拟机外部的二进制字节流就按照虚拟机设定的格式存放在方法区

### 验证

1. 文件格式验证 验证字节流是否符合当前版本虚拟机规范

   * 是否以魔数开头
   * 主次版本号是否在虚拟机接受范围之内
   * 常量池中常量是否有不被支持的常量类型

2. 元数据验证

   * 类是否有父类(Object除外)
   * 是否继承了不允许继承的类
   * 如果这个类不是抽象类，是否实现了父类要求被实现的所有方法
   * 类中的字段方法是否与父类产生矛盾

3. 字节码验证 判断程序语义是否是合法、符合逻辑的

4. 符号引用验证 

   * 符号引用中的类名是否能找到对应的类
   * 指定类中是否存在复合方法的字段描述符和简单名称所描述的方法和字段

   

   

   

### 准备

正式为类中定义的变量（静态变量）设置初始值并设置初始值（这里所谓的初始值是该类型的默认值而不是代码指定的值，正式赋值需要等到初始化之后）

### 解析

将常量池中的符号引用替换为直接引用

**符号引用**：以一组符号描述所引用的目标

**直接引用**：可以使直接指向目标的指针、偏移量、或者句柄等

解析包括

#### **类或接口的解析**

​	1. 

#### 字段解析

#### 方法解析

#### 接口方法解析

### 初始化

真正开始执行类中编写的程序代码



## 类加载器

实现**通过一个类的全限定名来获取类的二进制字节**这个动作的代码被称为类加载器 			



### 双亲委派

多个类加载器之间存在父子关系的时候，某个class类具体由哪个加载器进行加载的问题。

* 当一个类加载的时候，它不会首先去加载，而是委托给自己的父类去加载，
* 父类又委托给自己的父类。
* 所有的类加载都会委托给顶层的父类 Bootstrap Classloader
* 父类无法完成时子类加载器才会自己完成

**作用**：

1. 避免类的重复加载
2. 避免核心类被不不同的类加载到内存中造成冲突和混乱，从而保护了java核心库的安全

| 加载器                    | 范围                                                       |      |
| ------------------------- | ---------------------------------------------------------- | ---- |
| 启动类加载器Boostrap      | <Java_Home>/lib,r如java.io\|java.util\|java.lang           |      |
| 扩展类加载器Extention     | 以javax开头，<Java_Home>/lib/ext目录下                     |      |
| 应用程序加载器Application | 用户路径classpath上指定的类库，自己编写的类以及第三方jar包 |      |
| 自定义加载器Custom        | 为了某些特殊目的实现的自定义加载器                         |      |

### 应用场景

**依赖冲突**：

![image-20220822095304982](H:\gitfile\modiman.github.io\docs\_posts\imgs\image-20220822095304982.png)



├─业务
│  ├─fastjson1
│  ├─中间件
│  │  └─fastjson2
│  └─微服务
│      └─fastjson2

在这种业务逻辑中，业务层有自己的依赖fastjson1.0，中间件和微服务又有各自版本的fastjson2,3

根据maven依赖处理机制，只会加载fastjson1

**解决方案**：通过自定义类加载器，为每个中间件自定义一个加载器，这些加载器之间的关系是平行的，彼此没有依赖关系。

这样每个中间件的classloader就可以加载各自版本 的fastjson。因为一个类的全限定名以及加载该类的加载器两者共同形成了这个类在JVM中的惟一标识，这也 是阿里pandora实现依赖隔离的基础。

## 加载顺序

​         关于关键字static，大家 都知道它是静态的，相当于一个全局变量，也就是这个属性或者方法是可以通过类来访问，当class文件被加载进内存，开始初始化的时候，被static修饰的变量或者方法即被分配了内存，而其他变量是在对象被创建后，才被分配了内存的。

所以在类中，加载顺序为：

1.首先加载父类的静态字段或者静态语句块

2.子类的静态字段或静态语句块

3.父类普通变量以及语句块

4.父类构造方法被加载

5.子类变量或者语句块被加载

6.子类构造方法被加载
