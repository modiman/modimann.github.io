# 内存管理

## 运行时数据区

### 程序计数器

* 当前线程执行的字节码的行号指示器
* 字节码解释器通过修改计数器的值来决定下一条需要执行的字节码指令
* 每个线程对应一个程序计数器--》线程私有
* 没有Out Of Memory Error

### 虚拟机栈

* 线程私有
* 生命周期与线程相同
* 描述的是方法对应的内存模型
* 方法被执行时虚拟机创建一个栈帧，存储局部变量表、操作数栈、动态链接方法出口等信息
* 如果栈帧请求的深度超出范围，抛出stack overflow
* 如果虚拟接允许栈扩容但无法申请到足够的内存抛出oom error

### 本地方法栈

与虚拟机栈类似

### 堆

* 被所有线程共享
* 唯一目的就是存放对象
* 由垃圾收集器管理
* 常常会分代

### 方法区

* 线程共享
* 存储被虚拟机加载的类型信息、常量、静态变量、代码缓存等数据
* 别称为永久代
* 不需要连续的内存
* 无法满足新的内存分配时会抛出OOME

### 运行时常量池

### 直接内存

# 垃圾回收

* [回收](https://juejin.cn/post/6911668514096955406)

回收之前判断对象是否存活

## 引用计数法

给对象添加一个引用计数器，引用+1，失效-1，为0表示不被使用。

**缺点**：无法解决循环依赖

## 可达性分析算法

以GC Roots作为起点向下搜索，如果不能搜索到某个对象，证明它可回收	

![image-20220815204217068](E:\gitfile\modiman.github.io\docs\_posts\imgs\image-20220815204217068.png)

 **可作为GC Roots的对象**

* 虚拟机栈中引用的对象
* 方法区中类静态属性引用的对象
* 方法区中常量引用的对象
* 本地方法栈中JNI引用的对象

## 分代结构

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45a74a5765b74ad4857511271c922ecf~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

* 对象优先分配在 Eden 区
* 大对象直接进入老年代
* 长期存活的对象将进入老年代
* 动态对象年龄判断
* 空间分配担保

## 引用

* 强引用
* 软引用
* 弱引用
* 虚引用

## 手动GC

```java
System.gc();
// 或者下面，两者等价
Runtime.getRuntime().gc();
```

System.gc();
另Java的GC是由JVM自行调动的，在需要的时候才执行，上面的指令只是告诉JVM尽快GC一次，但不会立即执行GC。

## 垃圾收集算法

### 标记-清除 mark-sweep

标记出所有需要回收的对象，统一回收

**缺点**：效率不高，产生不连续碎片浪费空间

### 复制算法

将可用内存分为两块，每次只用一块，满了之后将活着的移到另一块，然后将已经使用过的一次清理 

**缺点**：只有一半内存可用

### 标记-整理  mark-compact

标记，将存活的对象向一段移动，清理掉端边界以外的内存

### 分代收集

根据对象存活周期将堆分为新生代、老年代

* 新生代：只有少量存活，选择复制算法
* 老年代：对象存活率高，采用标记-清理/整理

## 垃圾收集器

### CMS收集器 

Concurrent mark sweep

致力于减小系统停顿时间，常用于B/S结构的服务器端、

流程

1. 初始标记
2. 并发标记
3. 重新标记
4. 并发清除

**缺点**：

* 对CPU资源敏感
* 无法处理浮动垃圾
* 产生大量不连续碎片

### G1收集器

面向服务端的垃圾收集器

特点

* 并发与并行：利用多CPU优势缩短停顿时间
* 分代收集：用不同的方式处理新创建的、存活一段时间的对象
* 空间整合：不会产生大量碎片
* 可预测的停顿：

流程

1. 初始标记
2. 并发标记
3. 最终标记
4. **筛选回收**

# JVM调优

## 参数

Jvm调优典型参数设置;

1. -Xms堆内存的最小值：

   - 默认情况下，当堆中可用内存小于40%时，堆内存会开始增加，一直增加到-Xmx的大小。

2. -Xmx堆内存的最大值：

   默认值是总内存/64（且小于1G）

   - 默认情况下，当堆中可用内存大于70%时，堆内存会开始减少，一直减小到-Xms的大小；

3. -Xmn新生代内存的最大值：

   - 1.包括Eden区和两个Survivor区的总和
   - 2.配置写法如：-Xmn1024k，-Xmn1024m，-Xmn1g

4. -Xss每个线程的栈内存：

   - 默认1M，一般来说是不需要改。线程栈越小意味着可以创建的线程数越多

## 流程

* 第一步：监控分析GC日志

* 第二步：判断JVM问题：

  - 如果各项参数设置合理，系统没有超时日志出现，GC频率不高，GC耗时不高，那么没有必要进行GC优化

  - 如果GC时间超过1-3秒，或者频繁GC，则必须优化。

    

    第三步：确定调优目标

  第四步：调整参数

  - 调优一般是从满足程序的内存使用需求开始，之后是时间延迟要求，最后才是吞吐量要求，要基于这个步骤来不断优化，每一个步骤都是进行下一步的基础，不可逆行之。

  第五步：对比调优前后差距

  第六步：重复： 1 、 2 、 3 、 4 、 5 步骤

  - 找到最佳JVM参数设置

  第七步：应用JVM到应用服务器：

  - 找到最合适的参数，将这些参数应用到所有服务器，并进行后续跟踪。
  - 
  - 
  - 作者：llsydn
    链接：https://juejin.cn/post/7128377003224334373
    来源：稀土掘金
    著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## 内存分配

* 对象优先在eden分配
* 大对象直接进入老年代
* 长期存活的对象进入老年代
* 

# 类加载

**虚拟机把描述类的数据从class字节码文件加载到内存，并对数据进行检验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。**



## 类加载的时机

什么时候开始**加载**并没有严格规定，但当以下六种情况发生时必须开始**初始化**

而由于加载、验证、准备必须发生在初始化之前，所以这意味着当下面六种情况发生时，（加载、验证、准备、解析）等步骤也必须发生

下文中的**类型**包括类和接口

1. 遇到指定字节码，比如以下情况
   * 使用new实例化对象
   * 读取或设置静态变量（被final修饰除外，因为已经在编译期把结果放进常量池）
   * 调用一个类型的静态方法
2. 对类型进行反射调用
3. 初始化类时，发现其父类没有初始化，需要初始化其父类
4. 虚拟机启动时，用户需要指定一个要执行的主类（包含main方法的那个类），虚拟机先初始化这个主类
5. 与JDK7有关，略
6. 当一个接口定义了jdk8新加入的默认方法时（被default修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化

这六种场景可以被称为对一个类型进行**主动引用**，与之对应的是**被动引用**，下面举例说明

```java
class YeYe{
    public  static String strYeYe="HelloJVM_YeYe";

    static {
        System.out.println("YeYe静态代码块");
    }
}

class Father extends YeYe{
    public final static String strFather="HelloJVM_Father";

    static{
        System.out.println("Father静态代码块");
    }
}

class Son extends Father{
    public static String strSon="HelloJVM_Son";

    static{
        System.out.println("Son静态代码块");
    }
}
```

上面定义了子、父、祖父三个具有继承关系的类，其中`Father`拥有一个以`static final`修饰的变量，`Son`拥有一个以`strFather`修饰的变量

下面考虑以下调用会出现的情况

1. ```java
   System.out.println(Son.strFather);
   ```

   只输出`HelloJVM_Father`,这是因为由于使用`static final`修饰`strFather`,该变量已经被加载进主函数所在的类的常量池中，此时它已经和Father类没有什么关系了

2. ```java
   System.out.println(Son.strFather);
   //输出
   //YeYe静态代码块
   //HelloJVM_YeYe
   ```

   上述两个调用都没有加载Son本身的静态代码段，这是因为对于静态字段，只有直接定义这个字段的类会被初始化，因此通过子类调用父类的静态字段并不会触发子类的初始化

3. 

## 加载过程

家宴准备了西式菜

1. **加载** 把class字节码从各个来源通过加载器装进内存
2. **验证** 保证加载进来的字节流合乎虚拟机规范，不会造成安全错误
3. **准备** 为类变量分配内存，并且赋予初值
4. **解析**  将常量池中的符号引用替换成直接饮用
5. **初始化** 对类变量进行初始化，是执行构造器的基础
6. 使用
7. 卸载

### 加载

1. 通过类名获取类的二进制字节流
2. 将字节流代表的静态数据结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问接口

值得注意的是，二进制字节流未必从本地获取，还有以下渠道

* ZIP压缩包（war,jar等）
* 网络中获取
* 运行时计算产生，如动态代理技术，
* JSP产生
* 数据库读取

加载阶段结束后，虚拟机外部的二进制字节流就按照虚拟机设定的格式存放在方法区

### 验证

1. 文件格式验证 验证字节流是否符合当前版本虚拟机规范

   * 是否以魔数开头
   * 主次版本号是否在虚拟机接受范围之内
   * 常量池中常量是否有不被支持的常量类型

2. 元数据验证

   * 类是否有父类(Object除外)
   * 是否继承了不允许继承的类
   * 如果这个类不是抽象类，是否实现了父类要求被实现的所有方法
   * 类中的字段方法是否与父类产生矛盾

3. 字节码验证 判断程序语义是否是合法、符合逻辑的

4. 符号引用验证 

   * 符号引用中的类名是否能找到对应的类
   * 指定类中是否存在复合方法的字段描述符和简单名称所描述的方法和字段

   

   

   

### 准备

正式为类中定义的变量（静态变量）设置初始值并设置初始值（这里所谓的初始值是该类型的默认值而不是代码指定的值，正式赋值需要等到初始化之后）

### 解析

将常量池中的符号引用替换为直接引用

**符号引用**：以一组符号描述所引用的目标

**直接引用**：可以使直接指向目标的指针、偏移量、或者句柄等

解析包括

#### **类或接口的解析**

​	1. 

#### 字段解析

#### 方法解析

#### 接口方法解析

### 初始化

真正开始执行类中编写的程序代码



## 类加载器

实现**通过一个类的全限定名来获取类的二进制字节**这个动作的代码被称为类加载器 			



### 双亲委派

多个类加载器之间存在父子关系的时候，某个class类具体由哪个加载器进行加载的问题。

* 当一个类加载的时候，它不会首先去加载，而是委托给自己的父类去加载，
* 父类又委托给自己的父类。
* 所有的类加载都会委托给顶层的父类 Bootstrap Classloader
* 父类无法完成时子类加载器才会自己完成

**作用**：

1. 避免类的重复加载
2. 避免核心类被不不同的类加载到内存中造成冲突和混乱，从而保护了java核心库的安全

| 加载器                    | 范围                                                       |      |
| ------------------------- | ---------------------------------------------------------- | ---- |
| 启动类加载器Boostrap      | <Java_Home>/lib,r如java.io\|java.util\|java.lang           |      |
| 扩展类加载器Extention     | 以javax开头，<Java_Home>/lib/ext目录下                     |      |
| 应用程序加载器Application | 用户路径classpath上指定的类库，自己编写的类以及第三方jar包 |      |
| 自定义加载器Custom        | 为了某些特殊目的实现的自定义加载器                         |      |

### 应用场景

**依赖冲突**：

![image-20220822095304982](H:\gitfile\modiman.github.io\docs\_posts\imgs\image-20220822095304982.png)



├─业务
│  ├─fastjson1
│  ├─中间件
│  │  └─fastjson2
│  └─微服务
│      └─fastjson2

在这种业务逻辑中，业务层有自己的依赖fastjson1.0，中间件和微服务又有各自版本的fastjson2,3

根据maven依赖处理机制，只会加载fastjson1

**解决方案**：通过自定义类加载器，为每个中间件自定义一个加载器，这些加载器之间的关系是平行的，彼此没有依赖关系。

这样每个中间件的classloader就可以加载各自版本 的fastjson。因为一个类的全限定名以及加载该类的加载器两者共同形成了这个类在JVM中的惟一标识，这也 是阿里pandora实现依赖隔离的基础。

## 加载顺序

​         关于关键字static，大家 都知道它是静态的，相当于一个全局变量，也就是这个属性或者方法是可以通过类来访问，当class文件被加载进内存，开始初始化的时候，被static修饰的变量或者方法即被分配了内存，而其他变量是在对象被创建后，才被分配了内存的。

所以在类中，加载顺序为：

1.首先加载父类的静态字段或者静态语句块

2.子类的静态字段或静态语句块

3.父类普通变量以及语句块

4.父类构造方法被加载

5.子类变量或者语句块被加载

6.子类构造方法被加载
