# 设计模式

## 常用设计模式

单例、工厂、策略、观察者

## 手写单例模式

### 懒汉 线程不安全

```java
public class Singleton{
	private static Singleton instance;
    private Singleton(){}//构造函数可以是私有化的，单例模式就是一个很好的证明
    public Static Singleton getInstance(){
		if(Instance==null) {
			instance = new Singleton();
        }
        return Instance;
    }
}
```

### 懒汉 线程安全

唯一区别就是添加synchronize关键字

```java
public class Singleton{
	private static Singleton instance;
    private Singleton(){}
    public static synchronized Singleton getInstance(){
        if(instance == null) 
            instance = new Singleton();
        return instance;
    }
}
```

### 恶汉

```java
public class Singleton{
    private static Singleton instance = new Singleton();
    private Singleton(){}
    public static getInstace(){
		return instance;
    }
}
```

# 手撕代码

## 快排

```java
//快排的思路是交换，首先选择一个中间数（一般是数组的第一个元素）每趟遍历结束之后，比中间数小的移到左边，大的移到右边
//递归调用，以中间数为界，将数组分为两段，对两段数组继续使用快排算法
//两个模块，核心是交换模块，交换完成后返回中间数的索引，另一个则是递归模块，调用交换模块完成排序

public class QuickSort{

	public void quickSort(int []arr,int startIndex,int endIndex){
        if(startIndex>=endIndex) return;
        int index = swapNum(arr,startIndex,index);
        quickSort(arr,startIndex, endIndex);
        quickSort(arr,index,endIndex);
	
    }
    public int swapNum(int [] arr,int startIndex,int endIndex){
		int cur = startIndex;
        int left = startIndex,right=endIndex;
        while(left<right){
            while(right>left && arr[right]>arr[cur]) right--;
			while(left<right&&arr[left]<=arr[cur]) left++;
            if(left<right){
                int temp = arr[left];
            	arr[left] = arr[right];
            	arr[right] = temp;
            }
            
        }
        arr[startIndex] = arr[right];
        arr[right] = arr[cur];
        return right;
    }

}

```



# Redis

## 基本数据结构底层、使用场景

### String

![](./imgs/sds.png)

简单动态字符串

* 常数复杂度获取字符串长度
* 杜绝缓存区溢出 修改之前判断长度
* 减少修改字符串长度时带来的内存重分配次数
* 二进制安全
* 兼容部分C语言字符串函数

### ZSet

##### 一、使用ziplist。

1. 前提：保存元素数量小于128，并且每个元素长度小于64字节
    （这两个参数可以通过zset-max-ziplist-entries 选项和 zset-max-ziplist-value 进行修改）
2. ziplist原理：
    压缩列表（ziplist）是Redis为了节省内存而开发的，是由一系列特殊编码的**连续内存块组成的顺序型数据结构**，一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值。



作者：AnyL8023
链接：https://www.jianshu.com/p/360627bd04e5
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## 红黑树与跳表

##  [redis](https://www.nowcoder.com/jump/super-jump/word?word=redis)为什么可以承载那么高的并发量

Redis 对于 I/O 多路复用模块的设计非常简洁，通过宏保证了 I/O 多路复用模块在不同平台上都有着优异的性能，将不同的 I/O 多路复用函数封装成相同的 API 提供给上层使用。

整个模块使 Redis 能以单进程运行的同时服务成千上万个文件描述符，避免了由于多进程应用的引入导致代码实现复杂度的提升，减少了出错的可能性。



作者：IT架构师luke
链接：https://zhuanlan.zhihu.com/p/343253559
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## 多路复用比阻塞的区别在哪里

* [彻底理解 IO 多路复用实现机制](https://juejin.cn/post/6882984260672847879)

### 什么是IO多路复用？

- IO 多路复用是一种同步IO模型，实现一个线程可以监视多个文件句柄；
- 一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；
- 没有文件句柄就绪就会阻塞应用程序，交出CPU。

> 多路是指网络连接，复用指的是同一个线程

|                      | **select**                                         | **poll**                                         | **epoll**                                                    |
| -------------------- | -------------------------------------------------- | ------------------------------------------------ | ------------------------------------------------------------ |
| 操作方式             | 遍历                                               | 遍历                                             | 回调                                                         |
| 数据结构             | bitmap                                             | 数组                                             | 红黑树                                                       |
| 最大连接数           | 1024（x86）或 2048（x64）                          | 无上限                                           | 无上限                                                       |
| 最大支持文件描述符数 | 一般有最大值限制                                   | 65535                                            | 65535                                                        |
| fd拷贝               | 每次调用select，都需要把fd集合从用户态拷贝到内核态 | 每次调用poll，都需要把fd集合从用户态拷贝到内核态 | fd首次调用epoll_ctl拷贝，每次调用epoll_wait不拷贝            |
| 工作模式             | LT                                                 | LT                                               | 支持ET高效模式                                               |
| 工作效率             | 每次调用都进行线性遍历，时间复杂度为O(n)           | 每次调用都进行线性遍历，时间复杂度为O(n)         | 事件通知方式，每当fd就绪，系统注册的回调函数就会被调用，将就绪fd放到readyList里面，时间复杂度O(1) |

# SpringBoot

## 1.约定大于配置

优先使用默认设置（即约定），当有特殊需要时再使用自定义配置

Spring Boot Starter、Spring Boot Jpa 都是“约定优于配置“的一种体现。都是通过“约定优于配置“的设计思路来设计的，Spring Boot Starter 在启动的过程中会根据约定的信息对资源进行初始化；Spring Boot Jpa 通过约定的方式来自动生成 Sql ，避免大量无效代码编写。

## 2引用数据类型



![image-20220622170357493](E:\gitee\modige\_posts\image-20220622170357493.png)两大集合类接口

### collection

子接口

*  [Deque](https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/Deque.html) <E>
*  [List](https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/List.html) <E>
*  [Queue](https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/Queue.html) <E>，
*  [Set](https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/Set.html) <E>，
*  [SortedSet](https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/SortedSet.html) <E>，
*  [TransferQueue](https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/concurrent/TransferQueue.html) <E>

实现类

* [ArrayList](https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/ArrayList.html) 
* [LinkedList](https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/LinkedList.html)
* [Vector](https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/Vector.html)
* [TreeSet](https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/TreeSet.html) 
* [Stack](https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/Stack.html)
* [HashSet](https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/HashSet.html)

### map

## 3布隆过滤器

作者：飞天小牛肉
链接：https://www.nowcoder.com/discuss/965563?source_id=profile_create_nctrack&channel=-1
来源：牛客网

现在想要实现一个网页过滤系统，利用该系统可以根据网页的 URL 判断该网页是否在黑名单上，黑名单现在已经包含 100 亿个不安全网页的 URL，每个网页的 URL 最多占用 64B（字节） 大小。

请设计该系统， 要求：

1. 该系统允许有万分之一以下的判断失误率 
2. 使用的额外空间不要超过 30GB

### 参考链接

* 详解布隆过滤器的原理，使用场景和注意事项 - 陈蔚澜的文章 - 知乎 https://zhuanlan.zhihu.com/p/43263751
* https://baike.baidu.com/item/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/5384697?fr=aladdin

### 思路

反向排除法，一定能判断不存在，不一定能判断存在

1. 定义一个长度为m的bitmap
2. 定义k个哈希函数
3. 计算上述url在k个哈希函数下的哈希值，将哈希值对应索引下的bitmap设置为1
4. 对于新来的url，要判断它是否已经存在，只需要计算这个url在k个哈希函数下的哈希值，然后查看bitmap中对应位置是否为1，如果都为1,说明该url可能存在，如果有一个为0，说明一定不存在

## 4SpringBoot自动装配原理

注解 @EnableAutoConfiguration, @Configuration, @ConditionalOnClass 就是自动配置的核心，

@EnableAutoConfiguration 给容器导入META-INF/spring.factories 里定义的自动配置类。

筛选有效的自动配置类。

每一个自动配置类结合对应的 xxxProperties.java 读取配置文件进行自动配置功能

* https://blog.csdn.net/u014745069/article/details/83820511
* https://blog.csdn.net/weixin_44460333/article/details/124008480?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-124008480-blog-109813494.pc_relevant_antiscanv3&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-124008480-blog-109813494.pc_relevant_antiscanv3&utm_relevant_index=1



## 5送分题，ArrayList 的扩容机制了解吗？

### 1. ArrayList 了解过吗？它是啥？有啥用?

众所周知，Java 集合框架拥有两大接口 `Collection` 和 `Map`，其中，`Collection` 麾下三生子 `List`、`Set` 和 `Queue`。`ArrayList` 就实现了 `List` 接口，其实就是一个数组列表，不过作为 Java 的集合框架，它只能存储对象引用类型，也就是说当我们需要装载的数据是诸如 `int`、`float` 等基本数据类型的时候，必须把它们转换成对应的包装类。

`ArrayList` 的底层实现是一个 `Object` 数组：

![img](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/20210318002618.png)

既然它是基于数组实现的，数组在内存空间中是连续分配的，那必然查询速率非常快，不过当然也肯定逃不过增删效率低的缺陷。

另外，和 `ArrayList` 一样同样实现了 `List` 接口的、我们比较常用的还有 `LinkedList`。`LinkedList` 比较特殊，它不仅实现了 `List` 接口，还实现了 `Queue` 接口，所以你可以看见 `LinkedList` 经常被当作队列使用：

```
Queue<Integer> queue = ``new` `LinkedList<>();
```

`LinkedList` 人如其名，它的底层自然是基于[链表](https://www.nowcoder.com/jump/super-jump/word?word=链表)的，而且还是个双向[链表](https://www.nowcoder.com/jump/super-jump/word?word=链表)。[链表](https://www.nowcoder.com/jump/super-jump/word?word=链表)的特性和数组正好是反的，由于没有索引，所以查询效率低，但是增删速度快。

![img](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/20210318003923.png)

### 2. ArrayList 如何指定底层数组大小的？

OK，首先，既然咱真正存储数据的地方是数组，那我们初始化 `ArrayList` 的时候自然要给数组分配一个大小，开辟一个内存空间。我们先来看看 `ArrayList` 的无参构造函数：

![img](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/20210318005234.png)

可以看到，它为底层的 `Object` 数组也就是 elementData 赋值了一个默认的空数组 `DEFAULTCAPACITY_EMPTY_ELEMENTDATA`。也就是说，使用无参构造函数初始化 `ArrayList` 后，它当时的数组容量为 0 。

这给咱初始化一个容量为 0 的数组有啥用？啥也存不了啊？别急，如果使用了无参构造函数来初始化 `ArrayList`， 只有当我们真正对数据进行添加操作 `add` 时，才会给数组分配一个默认的初始容量 `DEFAULT_CAPACITY = 10`。看下图：

![img](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/20210318010150.png)

说完了无参构造，`ArrayList` 的有参构造函数就是中规中矩了，按照用户传入的大小开辟数组空间：

![img](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/20210318010554.png)

### 3. 数组的大小一旦被规定就无法改变，那 ArrayList 是怎么对底层数组进行扩容的？

`ArrayList` 的底层实现是 `Object` 数组，我们知道，数组的大小一旦被规定就无法改变。那如果我们不断的往里面添加数据的话，`ArrayList` 是如何进行扩容的呢？或者说 ArrayList 是如何实现存放任意数量对象的呢？

OK，扩容发生在啥时候？那肯定是我们往数组中新加入一个元素但是发现数组满了的时候。没错，我们去 `add` 方法中看看 `ArrayList` 是怎么做扩容的：

![img](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/20210318012036.png)

`ensureExplicitCapacity` 判断是否需要进行扩容，很显然，`grow` 方法是扩容的关键：

![img](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/20210318012249.png)

说实话，别的都不用看了，看上面图中的黄色框框就知道 `ArrayList` 是怎么扩容的了：扩容后的数组长度 = 当前数组长度 + 当前数组长度 / 2。最后使用 `Arrays.copyOf` 方法直接把原数组中的数组 copy 过来，需要注意的是，`Arrays.copyOf` 方***创建一个**新数组**然后再进行拷贝。

举个例子画个图来演示一下：

![img](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/20210318200357.png)

### 4. 既然扩容发生在添加数据的时候，讲讲 ArrayList 具体是怎么添加数据的

OK，`add` 方法我们刚刚讲了一半，添加数据前会先判断一下是否需要扩容，真正的添加数据的操作在下半部分：

![img](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/20210318201926.png)

先讲下 `add(int index, E element)` 这个方法的含义，就是在指定索引 index 处插入元素 element。比如说 `ArrayList.add(0, 3)`，意思就是在头部插入元素 3。

再来看看 `add` 方法的核心 `System.arraycopy`，这个方法有 5 个参数：

- elementData：源数组
- index：从源数组中的哪个位置开始复制
- elementData：目标数组
- index + 1：复制到目标数组中的哪个位置
- size - index：要复制的源数组中数组元素的数量

解释一下上面代码中 `arraycopy` 的意思，举个例子，我们想要在 index = 5 的位置插入元素，首先，我们会复制一遍源数组 elementData（这里我们称复制的数组为新数组吧），然后把源数组中从 index = 5 的位置开始到数组末尾的元素，放到新数组的 index + 1 = 6 的位置上：

![img](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/20210318203028.png)

于是，这就给我们要新增的元素腾出了位置，然后在新数组 index = 5 的位置放入元素 element 就完成了添加的操作：

![img](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/20210318203638.png)

显然，不用多说，ArrayList 的将数据插入到指定位置的操作性能非常低下，因为要开辟新数组复制元素啊，要是涉及到扩容那就更慢了。

另外，`ArrayList` 还内置了一个直接在末尾添加元素的 `add` 方法，不用复制数组，直接 size ++ 就好，这个方法应该是我们最常使用的：

![img](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/20210318211214.png)

### 5. ArrayList 又是如何删除数据的呢？

Ctrl + F 找到 `remove` 方法，就这？和添加一个道理，也是复制数组

![img](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/20210318203837.png)

举个例子，假设我们要删除数组的 index = 5 的元素，首先，我们会复制一遍源数组，然后把源数组中从 index + 1 = 6 的位置开始到数组末尾的元素，放到新数组的 index = 5 的位置上：

![img](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/20210318204239.png)

也就是说 index = 5 的元素直接被覆盖掉了，给了你被删除的感觉。同样的，它的效率自然也是十分低下的

### 6. ArrayList 是线程安全的吗？不安全的表现

`ArrayList` 和 `LinkedList` 都不是线程安全的，我们以在末尾添加元素的 `add` 方法为例，来看看 `ArrayList` 线程不安全的表现是啥：

![img](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/20210318211130.png)

黄色框里的并不是一个原子操作，它由两步操作构成：

```
elementData[size] = e;``size = size + ``1``;
```

在单线程执行这两条代码时，那当然没有任何问题，但是当多线程环境下执行时，可能就会发生**一个线程添加的值覆盖另一个线程添加的值**。举个例子：

- 假设 size = 0，我们要往这个数组的末尾添加元素
- 线程 A 开始添加一个元素，值为 A。此时它执行第一条操作，将 A 放在了数组 elementData 下标为 0 的位置上
- 接着线程 B 刚好也要开始添加一个值为 B 的元素，且走到了第一步操作。此时线程 B 获取到的 size 值依然为 0，于是它将 B 也放在了 elementData 下标为 0 的位置上
- 线程 A 开始增加 size 的值，size = 1
- 线程 B 开始增加 size 的值，size = 2

这样，线程 A、B 都执行完毕后，理想的情况应该是 size = 2，elementData[0] = A，elementData[1] = B。而实际情况变成了 size = 2，elementData[0] = B（线程 B 覆盖了线程 A 的操作），下标 1 的位置上什么都没有。并且后续除非我们使用 set 方法修改下标为 1 的值，否则这个位置上将一直为 null，因为在末尾添加元素时将会从 size = 2 的位置上开始。

上段代码验证下：

![img](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/20210318212403.png)

结果和我们分析的一样：

![img](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/20210318212523.png)

`ArrayList` 的线程安全版本是 `Vector`，它的实现很简单，就是把所有的方法统统加上 `synchronized`：

![img](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/20210318212652.png)

既然它需要额外的开销来维持同步锁，所以理论上来说它要比 `ArrayList` 要慢。

### 7. 为什么线程不安全还要用它呢？

因为在大多数场景中，查询的情况居多，不会涉及太频繁的增删。那如果真的涉及频繁的增删，可以使用`LinkedList`，底层[链表](https://www.nowcoder.com/jump/super-jump/word?word=链表)实现，为增删而生。而如果你非得保证线程安全那就使用 `Vector`。当然实际开发中使用最多的还是 `ArrayList`，虽然线程不安全、增删效率低，但是查询效率高啊。

> 小伙伴们大家好呀，我是小牛肉，公众号【**飞天小牛肉**】定期推送大厂面试题，提供背诵版 + 详细版，知其然而知其所以然，让八股文变得有价值！）

## 6线程五大状态

![img](https://upload-images.jianshu.io/upload_images/3994259-edf9a4d8be059244.jpg?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

### 1.新建状态(New)：

 当用new操作符创建一个线程时， 例如new Thread(r)，线程还没有开始运行，此时线程处在新建状态。 当一个线程处于新生状态时，程序还没有开始运行线程中的代码

### 2.就绪状态(Runnable)

 一个新创建的线程并不自动开始运行，要执行线程，**必须调用线程的start()方法**。当线程对象调用start()方法即启动了线程，start()方法创建线程运行的系统资源，并调度线程运行run()方法。当start()方法返回后，线程就处于就绪状态。
 处于就绪状态的线程并不一定立即运行run()方法，线程还必须同其他线程竞争CPU时间，只有获得CPU时间才可以运行线程。因为在单CPU的计算机系统中，不可能同时运行多个线程，一个时刻仅有一个线程处于运行状态。因此此时可能有多个线程处于就绪状态。对多个处于就绪状态的线程是由[Java](https://link.jianshu.com?t=http://lib.csdn.net/base/javase)运行时系统的线程调度程序(*thread scheduler*)来调度的。

### 3.运行状态(Running)

 当线程获得CPU时间后，它才进入运行状态，真正开始执行run()方法.

### 4.阻塞状态(Blocked)

 线程运行过程中，可能由于各种原因进入阻塞状态:
1>线程通过调用sleep方法进入睡眠状态；        

2>线程调用一个在I/O上被阻塞的操作，即该操作在输入输出操作完成之前不会返回到它的调用者；        

3>线程试图得到一个锁，而该锁正被其他线程持有；        

4>线程在等待某个触发条件；        ......               

​    所谓阻塞状态是正在运行的线程没有运行结束，暂时让出CPU，这时其他处于就绪状态的线程就可以获得CPU时间，进入运行状态。

### 5.死亡状态(Dead)

 有两个原因会导致线程死亡：
 \1) run方法正常退出而自然死亡，
 \2) 一个未捕获的异常终止了run方法而使线程猝死。
 为了确定线程在当前是否存活着（就是要么是可运行的，要么是被阻塞了），需要使用isAlive方法。如果是可运行或被阻塞，这个方法返回true； 如果线程仍旧是new状态且不是可运行的， 或者线程死亡了，则返回false.



## 9.滑动窗口

