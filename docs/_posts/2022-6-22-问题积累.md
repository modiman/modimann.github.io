# 源码

## HashMap

| JDK版本 | 实现方式             | 节点数>=8     | 节点数<=6     |
| ------- | -------------------- | ------------- | ------------- |
| 1.8以前 | 数组+单向链表        | 数组+单向链表 | 数组+单向链表 |
| 1.8以后 | 数组+单向链表+红黑树 | 数组+红黑树   | 数组+单向链表 |

### 重要变量

| 变量名              | 变量解释         | 值    |
| ------------------- | ---------------- | ----- |
| TREEIFY_THRESHOLD   | 变为红黑树临界值 | 8     |
| UNTREEIFY_THRESHOLD | 变为链表临界值   | 6     |
| MIN_TREEIFY_CAPACI  | 红黑树最小长度   | 64    |
| MAXIMUM_CAPACITY    | HashMap最大容量  | 1<<30 |
| DEFAULT_LOAD_FACTOR | 默认负载因子，   | 0.75f |
|                     |                  |       |

### 构造函数四个

* 无参构造，使用默认参数

* ```
  HashMap(int initialCapacity, float loadFactor)
  ```

* ```
   HashMap(int initialCapacity)
  ```

* ```
  HashMap(Map<? extends K, ? extends V> m)
  ```

* 实际上链表转为红黑树的阈值取决于 TREEIFY_THRESHOLD  * DEFAULT_LOAD_FACTOR

### 方法

1. hash()得到hash值

   ```java
   //null默人是0 
   static final int hash(Object key) {
           int h;
           return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
       //返回键的hashcode高16位与低16位的异或值
       //主要从性能、哈希碰撞角度考虑，减少系统开销，不会造成因为高位没有参与下标计算从而引起的碰撞。
       }
   ```

2. 插入方法 put

   ```java
   public V put(K key, V value) {
       return putVal(hash(key), key, value, false, true);
   }
   //
   final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                  boolean evict) {
       Node<K,V>[] tab; Node<K,V> p; int n, i;
       //
       if ((tab = table) == null || (n = tab.length) == 0)
           n = (tab = resize()).length;
       if ((p = tab[i = (n - 1) & hash]) == null)
           tab[i] = newNode(hash, key, value, null);
       else {
           Node<K,V> e; K k;
           if (p.hash == hash &&
               ((k = p.key) == key || (key != null && key.equals(k))))
               e = p;
           else if (p instanceof TreeNode)
               e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
           else {
               for (int binCount = 0; ; ++binCount) {
                   if ((e = p.next) == null) {
                       p.next = newNode(hash, key, value, null);
                       if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                           treeifyBin(tab, hash);
                       break;
                   }
                   if (e.hash == hash &&
                       ((k = e.key) == key || (key != null && key.equals(k))))
                       break;
                   p = e;
               }
           }
           if (e != null) { // existing mapping for key
               V oldValue = e.value;
               if (!onlyIfAbsent || oldValue == null)
                   e.value = value;
               afterNodeAccess(e);
               return oldValue;
           }
       }
       ++modCount;
       if (++size > threshold)
           resize();
       afterNodeInsertion(evict);
       return null;
   }
   
   ```

   * 当桶数组 table 为空时，通过扩容的方式初始化 table
   * 计算key在tab数组的索引`i = (n - 1) & hash]`,n为数组长度。（n-1）&hash等价于hash%n
   * 数组中对应位置结点不存在则生成新节点，并放入数组
   * 否则，生成新节点
   * 查找要插入的键值对是否已经存在，存在的话根据条件判断是否用新值替换旧值
   * 如果不存在，则将键值对链入链表中，并根据链表长度决定是否将链表转为红黑树
   * 判断键值对数量是否大于阈值，大于的话则进行扩容操作

3. **查找方法** get

   * 得到key的hash值
   * 定位key对应的数组索引
   * 判断数组对应索引的第一个结点是否满足条件，是则返回结点
   * 如果first是树节点，使用红黑树查找方法，返回结点
   * 否则在链表中查找对应结点 
   * 从结点中取出value返回

### 扩容

当频繁发生碰撞时，说明数组长度（桶数量太少），先考虑调用resize()方法进行扩容



### 红黑树

* [维基百科](https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91)

需要满足性质

1. 节点是红色或黑色。
2. 根是黑色。
3. 所有叶子都是黑色（叶子是NIL节点）。
4. 每个红色节点必须有两个黑色的子节点。（或者说从每个叶子到根的所有路径上不能有两个连续的红色节点。）（或者说不存在两个相邻的红色节点，相邻指两个节点是父子关系。）（或者说红色节点的父节点和子节点均是黑色的。）
5. 从任一节点到其每个叶子的所有[简单路径](https://zh.wikipedia.org/wiki/道路_(图论))都包含相同数目的黑色节点。

用意：

**最短的可能路径都是黑色节点，最长的可能路径有交替的红色和黑色节点。因为根据性质5所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。**



仍然发生很多碰撞，导致链表超过长度阈值，需要将链表转为红黑树

链表节点

```java
final int hash;
final K key;
V value;
Node<K,V> next;
```

红黑树节点,继承自LinkedHashMap.Entry，而LinkedHashMap.Entry继承自 HashMap.Node

```java
static final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {}
static class Entry<K,V> extends HashMap.Node<K,V> {}
```



```java
TreeNode<K,V> parent;  // red-black tree links
TreeNode<K,V> left;
TreeNode<K,V> right;
TreeNode<K,V> prev;    // needed to unlink next upon deletion
boolean red;
```

转换流程

1. 将链表节点转换为树节点，此时变成了一条树节点构成的链表
2. 将链表转换成红黑树

**红黑树查找**：与二叉查找树相同

**红黑树插入**：

1. 按二叉查找书的方式插入一个红节点（如果插入黑结点，很可能违反性质5）

2. 上一步有可能违背性质4，所以需要换颜色和旋转操作替换

   - 性质1和性质3总是保持着。
   - 性质4只在增加红色节点、重绘黑色节点为红色，或做旋转时受到威胁。
   - 性质5只在增加黑色节点、重绘红色节点为黑色，或做旋转时受到威胁。

3. 下面考虑5中插入情形

   * **情形1**：新节点N位于树的根上，没有父节点。在这种情形下，我们把它重绘为黑色以满足性质2。因为它在每个路径上对黑节点数目增加一，性质5符合。
   * **情形2**：新节点的父节点P是黑色，所以性质4没有失效（新节点是红色的）。在这种情形下，树仍是有效的。性质5也未受到威胁，尽管新节点N有两个黑色叶子子节点；但由于新节点N是红色，通过它的每个子节点的路径就都有同通过它所取代的黑色的叶子的路径同样数目的黑色节点，所以依然满足这个性质。
   * **情形3**:如果父节点P和叔父节点U二者都是红色，（此时新插入节点N做为P的左子节点或右子节点都属于情形3，这里右图仅显示N做为P左子的情形）则我们可以将它们两个重绘为黑色并重绘祖父节点G为红色（用来保持性质5）。现在我们的新节点N有了一个黑色的父节点P。因为通过父节点P或叔父节点U的任何路径都必定通过祖父节点G，在这些路径上的黑节点数目没有改变。但是，红色的祖父节点G可能是根节点，这就违反了性质2，也有可能祖父节点G的父节点是红色的，这就违反了性质4。为了解决这个问题，我们在祖父节点G上递归地进行**情形1**的整个过程。（把G当成是新加入的节点进行各种情形的检查）
   * ![情形3示意图](https://upload.wikimedia.org/wikipedia/commons/c/c8/Red-black_tree_insert_case_3.png)
   * **情形4**:父节点P是红色而叔父节点U是黑色或缺少，并且新节点N是其父节点P的右子节点而父节点P又是其父节点的左子节点。在这种情形下，我们进行一次[左旋转](https://zh.wikipedia.org/wiki/树旋转)调换新节点和其父节点的角色;接着，我们按**情形5**处理以前的父节点P以解决仍然失效的性质4。注意这个改变会导致某些路径通过它们以前不通过的新节点N（比如图中1号叶子节点）或不通过节点P（比如图中3号叶子节点），但由于这两个节点都是红色的，所以性质5仍有效。![情形4示意图](https://upload.wikimedia.org/wikipedia/commons/5/56/Red-black_tree_insert_case_4.png)
   * **情形5**：父节点P是红色而叔父节点U是黑色或缺少，新节点N是其父节点的左子节点，而父节点P又是其父节点G的左子节点。在这种情形下，我们进行针对祖父节点G的一次[右旋转](https://zh.wikipedia.org/wiki/树旋转)；在旋转产生的树中，以前的父节点P现在是新节点N和以前的祖父节点G的父节点。我们知道以前的祖父节点G是黑色，否则父节点P就不可能是红色（如果P和G都是红色就违反了性质4，所以G必须是黑色）。我们切换以前的父节点P和祖父节点G的颜色，结果的树满足性质4。性质5也仍然保持满足，因为通过这三个节点中任何一个的所有路径以前都通过祖父节点G，现在它们都通过以前的父节点P。在各自的情形下，这都是三个节点中唯一的黑色节点。
   * ![情形5示意图](https://upload.wikimedia.org/wikipedia/commons/6/66/Red-black_tree_insert_case_5.png)

   

   

   

   

   **红黑树删除**：

   

### 特色

* 位移运算加快计算速度
* 默认负载因子0.75兼顾时间和空间
* 

# 设计模式

## 常用设计模式

单例、工厂、策略、观察者



# Redis

## 基本数据结构底层、使用场景

### String

![](./imgs/sds.png)

简单动态字符串

* 常数复杂度获取字符串长度
* 杜绝缓存区溢出 修改之前判断长度
* 减少修改字符串长度时带来的内存重分配次数
* 二进制安全
* 兼容部分C语言字符串函数

### ZSet

##### 一、使用ziplist。

1. 前提：保存元素数量小于128，并且每个元素长度小于64字节
    （这两个参数可以通过zset-max-ziplist-entries 选项和 zset-max-ziplist-value 进行修改）
2. ziplist原理：
    压缩列表（ziplist）是Redis为了节省内存而开发的，是由一系列特殊编码的**连续内存块组成的顺序型数据结构**，一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值。



作者：AnyL8023
链接：https://www.jianshu.com/p/360627bd04e5
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## 红黑树与跳表

##  [redis](https://www.nowcoder.com/jump/super-jump/word?word=redis)为什么可以承载那么高的并发量

Redis 对于 I/O 多路复用模块的设计非常简洁，通过宏保证了 I/O 多路复用模块在不同平台上都有着优异的性能，将不同的 I/O 多路复用函数封装成相同的 API 提供给上层使用。

整个模块使 Redis 能以单进程运行的同时服务成千上万个文件描述符，避免了由于多进程应用的引入导致代码实现复杂度的提升，减少了出错的可能性。



作者：IT架构师luke
链接：https://zhuanlan.zhihu.com/p/343253559
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## 多路复用比阻塞的区别在哪里

* [彻底理解 IO 多路复用实现机制](https://juejin.cn/post/6882984260672847879)

### 什么是IO多路复用？

- IO 多路复用是一种同步IO模型，实现一个线程可以监视多个文件句柄；
- 一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；
- 没有文件句柄就绪就会阻塞应用程序，交出CPU。

> 多路是指网络连接，复用指的是同一个线程

|                      | **select**                                         | **poll**                                         | **epoll**                                                    |
| -------------------- | -------------------------------------------------- | ------------------------------------------------ | ------------------------------------------------------------ |
| 操作方式             | 遍历                                               | 遍历                                             | 回调                                                         |
| 数据结构             | bitmap                                             | 数组                                             | 红黑树                                                       |
| 最大连接数           | 1024（x86）或 2048（x64）                          | 无上限                                           | 无上限                                                       |
| 最大支持文件描述符数 | 一般有最大值限制                                   | 65535                                            | 65535                                                        |
| fd拷贝               | 每次调用select，都需要把fd集合从用户态拷贝到内核态 | 每次调用poll，都需要把fd集合从用户态拷贝到内核态 | fd首次调用epoll_ctl拷贝，每次调用epoll_wait不拷贝            |
| 工作模式             | LT                                                 | LT                                               | 支持ET高效模式                                               |
| 工作效率             | 每次调用都进行线性遍历，时间复杂度为O(n)           | 每次调用都进行线性遍历，时间复杂度为O(n)         | 事件通知方式，每当fd就绪，系统注册的回调函数就会被调用，将就绪fd放到readyList里面，时间复杂度O(1) |
