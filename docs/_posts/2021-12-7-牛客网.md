* 抽象方法不能有方法体，只能申明

* getInetAddress获取主机名和IP地址

* getLocalAddress()顾名思义，获取本地IP地址

* getReuseAddress()返回布尔类型，表示复用地址

* getLocalPort()API 的说明：“Returns the Internet Protocol (IP) port number of the interface on which the request was received. 

* hashCode()方法和equals()方法的作用其实是一样的，在Java里都是用来对比两个对象是否相等一致。

  ***那么equals()既然已\******经\******能\******实现\******对\******比的功能了，为什么还要hashCode()呢？\***因为重写的equals()里一般比较的比较全面比较复杂，这样效率就比较低，而利用hashCode()进行对比，则只要生成一个hash值进行比较就可以了，效率很高。*
  *

  ***那么hashCode()既然效率这么高为什么还要equals()呢******？*** 因为hashCode()并不是完全可靠，有时候不同的对象他们生成的hashcode也会一样（生成hash值得公式可能存在的问题），所以hashCode()只能说是大部分时候可靠，并不是绝对可靠，

  **所以我们可以得出：**

  **1.equals()相等的两个对象他们的hashCode()肯定相等，也就是用equals()对比是绝对可靠的。**

  **2.hashCode()相等的两个对象他们的equal()不一定相等，也就是hashCode()不是绝对可靠的。**

  所有对于需要大量并且快速的对比的话如果都用equals()去做显然效率太低，所以解决方式是，每当需要对比的时候，首先用hashCode()去对比，如果hashCode()不一样，则表示这两个对象肯定不相等（也就是不必再用equal()去再对比了）,如果hashCode()相同，此时再对比他们的equals()，如果equals()也相同，则表示这两个对象是真的相同了，这样既能大大提高了效率也保证了对比的绝对正确性！

* **java程序的种类**

  1.Application：Java应用程序，是可以由Java解释器直接运行的程序。

  2.Applet：即Java小应用程序，是可随网页下载到客户端由浏览器解释执行的Java程序。
  3.Servlet：Java服务器端小程序，由Web服务器(容器)中配置运行的Java程序。

* 父类new直接执行构造方法

* 子类new，先执行父类的构造方法，再执行自己的构造方法

```Java
package niuke;

public class ttt { public static void main(String[] args) {
    Father a = new Father();
    Father b = new Child();
}
}
class Father {
    public Father() {
        System.out.println("我是父类");
    }
}
class Child extends Father { public Child() {
    System.out.println("我是子类");
}
}
//程序执行结果
我是父类
我是父类
我是子类

Father a = new Father(); //执行结果为   我是父类
Father b = new Child(); //执行结果为   我是父类   我是子类


    
```

* 在JVM调用mian方法之前先用进行静态内容的初始化。                                                                                                                                   顺序为：父类的静态变量， 父类的静态代码块 ，子类的静态变量，子类的静态代码块。

```java
public class Test{
    static int cnt = 6;
    static{
        cnt += 9;
    }
	public static void main(String[] args）{
    System.out.println（“cnt =” + cnt);
	}
static{
    cnt /=3;
    };
}
//输出cnt=5
```

* **Java一个源程序只能有一个public类存在，且类名与文件名相同。**Java程序是从main方法开始执行的，public为类加载器提供入口，然后找到public类中的main方法开始执行。如果存在多个public类，程序将不知道该从哪里执行。
  **注意**，内部类可以是public的，因为内部类是作为外部类的成员存在的。

```Java
package niuke;
/*
 * Java一个源程序只能有一个public类存在，且类名与文件名相同。
 * Java程序是从main方法开始执行的，public为类加载器提供入口，然后找到public类中的main方法开始执行。
 * 如果存在多个public类，程序将不知道该从哪里执行。
 * 注意，内部类可以是public的，因为内部类是作为外部类的成员存在的。
 * */
public class MultiClass {

    public MultiClass(){
        System.out.println("这是主类的构造函数");
    }

    //因为是内部类，所以使用public修饰也未报错
    public static class World {

        public World() {
            System.out.println("这是内部public类构造函数");
        }
        public static void main(String[] args) {
            MultiClass mc = new MultiClass();
            World w = new World();
            Hello h = new Hello();
        }
    }
}

//因为此类未用public 修饰，因此不会报错
    class Hello {
        public Hello() {
            System.out.println("这是外部类构造函数");
        }
    }

```

```java
	int a = 10;
    double b=3.14;
    //转换为double
    System.out.println('A'+a+b);
    //单引号是字符，转换为整数
    System.out.println('A'+10);
    //双引号是字符串，表示字符串拼接
    System.out.println("A"+10);
```

- 编译器将Java源代码编译成字节码class文件
- 类加载到JVM里面后，执行引擎把字节码转为可执行代码
- 执行的过程，再把可执行代码转为机器码，由底层的操作系统完成执行。

<table border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse;">
  <tbody>
    <tr>
      <td style="" valign="top" width="166"><p>
          <span>&nbsp;</span>
        </p>
      </td><td style="" valign="top" width="166"><p>
          <span>private</span>
        </p>
      </td><td style="" valign="top" width="166"><p>
          <span>default</span>
        </p>
      </td><td style="" valign="top" width="166"><p>
          <span>protected</span>
        </p>
      </td><td style="" valign="top" width="166"><p>
          <span>public</span>
        </p>
      </td></tr>
    <tr>
      <td style="" valign="top" width="166"><p>
          <span>同一个类中</span>
        </p>
      </td><td valign="top" width="166"><p>
          <span>√</span>
        </p>
      </td><td valign="top" width="166"><p>
          <span>√</span>
        </p>
      </td><td valign="top" width="166"><p>
          <span>√</span>
        </p>
      </td><td valign="top" width="166"><p>
          <span>√</span>
        </p>
      </td></tr>
    <tr>
      <td style="" valign="top" width="166"><p>
          <span>同一个包中</span>
        </p>
      </td><td valign="top" width="166"><p>
          <span>&nbsp;</span>
        </p>
      </td><td valign="top" width="166"><p>
          <span>√</span>
        </p>
      </td><td valign="top" width="166"><p>
          <span>√</span>
        </p>
      </td><td valign="top" width="166"><p>
          <span>√</span>
        </p>
      </td></tr>
    <tr>
      <td style="" valign="top" width="166"><p>
          <span>子类中</span>
        </p>
      </td><td valign="top" width="166"><p>
          <span>&nbsp;</span>
        </p>
      </td><td valign="top" width="166"><p>
          <span>&nbsp;</span>
        </p>
      </td><td valign="top" width="166"><p>
          <span>√</span>
        </p>
      </td><td valign="top" width="166"><p>
          <span>√</span>
        </p>
      </td></tr>
    <tr>
      <td style="" valign="top" width="166"><p>
          <span>全局范围内</span>
        </p>
      </td><td valign="top" width="166"><p>
          <span>&nbsp;</span>
        </p>
      </td><td valign="top" width="166"><p>
          <span>&nbsp;</span>
        </p>
      </td><td valign="top" width="166"><p>
          <span>&nbsp;</span>
        </p>
      </td><td valign="top" width="166"><p>
          <span>√</span>
        </p>
      </td></tr>
  </tbody>
</table>


* javac将源程序编译成.class文件，字节码；java将字节码转为机器码，.exe程序

* **方法的重写（override）两同两小一大原则**：

方法名相同，参数类型相同

子类返回类型小于等于父类方法返回类型，

子类抛出异常小于等于父类方法抛出异常，

子类访问权限大于等于父类方法访问权限。

**instance是java的二元运算符，用来判断他左边的对象是否为右面类（接口，抽象类，父类）的实例**

**Math.floor**(x) 返回小于等于x的最接近整数，类型为double

* ​	final的作用：

    \1. 修饰变量，变量的引用地址不可变，但是地址中的内容可以变。

    \2. 修饰方法，方法不可被重写，但是还是可以重载

    \3. 修饰类，类不可继承。

  不可变类，说的是一个类一旦被实例化，就不可改变自身的状态。常见的比如String和基本数据类型的包装类，对于这种不可变类，一旦在进行引用传递的时候，形参一开始就和实际参数指向的不是一个地址，所以在方法中对形参的改变，并不会影响实际参数。