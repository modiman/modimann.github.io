# 数据结构

## 缓存

## 字典树



# 算法

## 分治

就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题



## 回溯

回溯，计算机算法，回溯法也称试探法，它的基本思想是：从问题的某一种状态（初始状态）出发，搜索从这种状态出发所能达到的所有“状态”，当一条路走到“尽头”的时候（不能再前进），再后退一步或若干步，从另一种可能“状态”出发，继续搜索，直到所有的“路径”（状态）都试探过。这种不断“前进”、不断“回溯”寻找解的方法，就称作“回溯法”。

**找出图中所有路径**

```java
class Solution {
    List<List<Integer>> ans = new ArrayList<List<Integer>>();
    Deque<Integer> stack = new ArrayDeque<Integer>();

    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
        stack.offerLast(0);
        dfs(graph, 0, graph.length - 1);
        return ans;
    }

    public void dfs(int[][] graph, int x, int n) {
        if (x == n) {
            ans.add(new ArrayList<Integer>(stack));
            return;
        }
        for (int y : graph[x]) {
            stack.offerLast(y);
            dfs(graph, y, n);
            stack.pollLast();
        }
    }
}

```



## 迭代

迭代是重复反馈过程的活动，其目的通常是为了逼近所需目标或结果。每一次对过程的重复称为一次“迭代”，而每一次迭代得到的结果会作为下一次迭代的初始值。

求斐波那契数

```java
int fab(int n)
{ 
    if (n<3){return 1;}
	else
		{int first = 1,second = 1,temp = 0;
	for (int i =0;i<n-2;i++)
		{	temp = first + second;
			first = second;
			second = temp;}
	return temp;
}
```





## 6-23 滑动窗口

# [438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

难度中等923收藏分享切换为英文接收动态反馈

给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **异位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

**异位词** 指由相同字母重排列形成的字符串（包括相同的字符串）。

 

**示例 1:**

```
输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。
```

 **示例 2:**

```
输入: s = "abab", p = "ab"
输出: [0,1,2]
解释:
起始索引等于 0 的子串是 "ab", 它是 "ab" 的异位词。
起始索引等于 1 的子串是 "ba", 它是 "ab" 的异位词。
起始索引等于 2 的子串是 "ab", 它是 "ab" 的异位词。
```

方法一：滑动窗口
思路

根据题目要求，我们需要在字符串 ss 寻找字符串 pp 的异位词。因为字符串 pp 的异位词的长度一定与字符串 pp 的长度相同，所以我们可以在字符串 ss 中构造一个长度为与字符串 pp 的长度相同的滑动窗口，并在滑动中维护窗口中每种字母的数量；当窗口中每种字母的数量与字符串 pp 中每种字母的数量相同时，则说明当前窗口为字符串 pp 的异位词。

算法

在算法的实现中，我们可以使用数组来存储字符串 pp 和滑动窗口中每种字母的数量。

细节

当字符串 ss 的长度小于字符串 pp 的长度时，字符串 ss 中一定不存在字符串 pp 的异位词。但是因为字符串 ss 中无法构造长度与字符串 pp 的长度相同的窗口，所以这种情况需要单独处理。

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        if (s.length()<p.length()) return new ArrayList();
        List<Integer> res = new ArrayList();

        int[] pLetterCount = new int[26];
        int[] windowLetterCount = new int[26];

        for(int i=0;i<p.length();i++){
            pLetterCount[p.charAt(i)-'a'] ++ ;
            windowLetterCount[s.charAt(i)-'a']++;

        }
        if(Arrays.equals(pLetterCount,windowLetterCount)) res.add(0);

        for(int i=1;i<=s.length()-p.length();i++){
            windowLetterCount[s.charAt(i+p.length()-1)-'a']++;
            windowLetterCount[s.charAt(i-1)-'a']--;
    
            if(Arrays.equals(pLetterCount,windowLetterCount)) res.add(i);

        }
        return res;
    }
}
```

# 递归处理链表
2. 两数相加
给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

 

示例 1：


输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
示例 2：

输入：l1 = [0], l2 = [0]
输出：[0]
示例 3：

输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]


提示：

每个链表中的节点数在范围 [1, 100] 内
0 <= Node.val <= 9
题目数据保证列表表示的数字不含前导零

思路 

原地相加，将对应位置相加得到的结点存在l1，最后返回l1
**边界条件**
1. l1和l2都是链表的尾结点，那么只需要判断当前是否存在进位
 * 


# [522. 最长特殊序列 II](https://leetcode.cn/problems/longest-uncommon-subsequence-ii/)

难度中等119

给定字符串列表 `strs` ，返回其中 **最长的特殊序列** 。如果最长特殊序列不存在，返回 `-1` 。

**特殊序列** 定义如下：该序列为某字符串 **独有的子序列（即不能是其他字符串的子序列）**。

 `s` 的 **子序列**可以通过删去字符串 `s` 中的某些字符实现。

- 例如，`"abc"` 是 `"aebdc"` 的子序列，因为您可以删除`"aebdc"`中的下划线字符来得到 `"abc"` 。`"aebdc"`的子序列还包括`"aebdc"`、 `"aeb"` 和 "" (空字符串)。

 

**示例 1：**

```
输入: strs = ["aba","cdc","eae"]
输出: 3
```

**示例 2:**

```
输入: strs = ["aaa","aaa","aa"]
输出: -1
```



思路

一个性质

如果一个子字符串是特殊序列，那么它的任意父字符串都是特殊序列。

换句话说，如果一个字符串拥有一个特殊序列子字符串，那么它本身就是一个特殊序列。

因此问题转化为求字符串数组中最长的特殊序列元素。

使用枚举法

1. 给字符串数组按字符串长度排序，长度递减（可以使用Array。sort配合lambda表达式）
2. 从左往右遍历数组，返回第一个特殊序列的长度

代码

```java
class Solution {
    public int findLUSlength(String[] strs) {

        Arrays.sort(strs, (s1, s2) -> s2.length() - s1.length());
        int res = -1;
        for (int i=0;i<strs.length;i++){
            boolean flag = false;
            for (int j =0;j<strs.length;j++){
                if (j!=i && isSubString(strs[i],strs[j])){
                   flag = true;
                }
            }
            if(!flag) return strs[i].length();
        }
  
        return res;

    }

    public boolean isSubString(String subString,String supString){
        int len = subString.length();
        int pSub =  0,pSup = 0;
        while (pSub<subString.length()&&pSup<supString.length()){
            if(subString.charAt(pSub++)!=supString.charAt(pSup++)) pSub--;
        }
        if (pSub==len) return true;
        return false;
    }
}
```

# [241. 为运算表达式设计优先级](https://leetcode.cn/problems/different-ways-to-add-parentheses/)

难度中等702

给你一个由数字和运算符组成的字符串 `expression` ，按不同优先级组合数字和运算符，计算并返回所有可能组合的结果。你可以 **按任意顺序** 返回答案。

生成的测试用例满足其对应输出值符合 32 位整数范围，不同结果的数量不超过 `104` 。

 

**示例 1：**

```
输入：expression = "2-1-1"
输出：[0,2]
解释：
((2-1)-1) = 0 
(2-(1-1)) = 2
```

**示例 2：**

```
输入：expression = "2*3-4*5"
输出：[-34,-14,-10,-10,10]
解释：
(2*(3-(4*5))) = -34 
((2*3)-(4*5)) = -14 
((2*(3-4))*5) = -10 
(2*((3-4)*5)) = -10 
(((2*3)-4)*5) = 10
```

 

**提示：**

- `1 <= expression.length <= 20`
- `expression` 由数字和算符 `'+'`、`'-'` 和 `'*'` 组成。
- 输入表达式中的所有整数值在范围 `[0, 99]`

思路：递归问题

**定义**：

n：字符串中运算数的数量

f(n):n个运算数对应的结果的数量

g(x,n-x)：将n拆分为x和n-x前后两部分，拆分得到的组合对应的结果的数量

则有状态方程

```
f(1) = 1
f(2) = 1
f(3) = g(1,2) + g(2,1)
f(4) = g(1,3) + g(2,2) + g(3,1)
f(5) = g(1,4) + g(2,3) + g(3,2) + g (4,1)
```

这样将问题转化为两个子问题：

将expression拆分成两部分，最终结果为两部分答案的排列组合

其中

```
g(x,y) = f(x) * f(y)
```

**举例**

`"2*3-4*5"`

共有四个运算数，三个运算符

可能的组合有

| 2     | 3-4*5 |
| ----- | ----- |
| 2*3   | 4*5   |
| 2*3-4 | 5     |

这样求两部分各自的结果，再排列组合即可，当某部分操作数大于2时可以继续拆分，这样就形成了一个递归问题。

上述问题有三种组合，组合1(2,3-4*5)两部分对应的结果分别为【2】【-5，-17】，两部分对应的运算符为\*,这样组合1对应的最终结果为【-10，-34】,对于其他两个组合进行同样的操作

代码

代码需要3部分

1. 字符处理函数：将字符串拆分成运算数与运算符
2. 字符运算函数：对于给定的两个运算数及其运算符，返回运算结果
3. 递归函数：递归求出结果并返回

python代码如下

```python
class Solution:
    def diffWaysToCompute(self, expression: str) -> List[int]:
        nums,ops = self.processExpress(expression)
        return self.getRes(nums,ops)
    def processExpress(self,s):
        operaors = []
        nums = []
        allOps = ['+','-','*']
        num = ''
        for i in range(len(s)):
            if s[i] not in allOps:
                num += s[i]
            else:
                nums.append(int(num))
                num = ''
                operaors.append(s[i])
        if len(num)>0:nums.append(int(num))

        return nums,operaors
    def operationNum(self,a,b,c):
        if c=='+':return a+b
        if c=='-':return a-b
        return a*b
    def getRes(self,nums , ops):
        res = []
        if(len(nums)==1): return nums
        elif(len(nums)==2):return [self.operationNum(nums[0],nums[1],ops[0])]
        for i in range(1,len(nums)):
            res1 = self.getRes(nums[0:i],ops[0:i-1])
            res2 = self.getRes(nums[i:],ops[i:])
            for a in res1:
                for b in res2:
                    res += [self.operationNum(a,b,ops[i-1])]
        return res

```

# [208. 实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/)

难度中等1231

**[Trie](https://baike.baidu.com/item/字典树/9825209?fr=aladdin)**（发音类似 "try"）或者说 **前缀树** 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。

请你实现 Trie 类：

- `Trie()` 初始化前缀树对象。
- `void insert(String word)` 向前缀树中插入字符串 `word` 。
- `boolean search(String word)` 如果字符串 `word` 在前缀树中，返回 `true`（即，在检索之前已经插入）；否则，返回 `false` 。
- `boolean startsWith(String prefix)` 如果之前已经插入的字符串 `word` 的前缀之一为 `prefix` ，返回 `true` ；否则，返回 `false` 。

 

**示例：**

```
输入
["Trie", "insert", "search", "search", "startsWith", "insert", "search"]
[[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]
输出
[null, null, true, false, true, null, true]

解释
Trie trie = new Trie();
trie.insert("apple");
trie.search("apple");   // 返回 True
trie.search("app");     // 返回 False
trie.startsWith("app"); // 返回 True
trie.insert("app");
trie.search("app");     // 返回 True
```

 

**提示：**

- `1 <= word.length, prefix.length <= 2000`
- `word` 和 `prefix` 仅由小写英文字母组成
- `insert`、`search` 和 `startsWith` 调用次数 **总计** 不超过 `3 * 104` 次

思路

字典树由字典数结点构成

定义字典树结点

思考二叉树结点的数据结构，有两要素：本身的val、孩子结点

```java
TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
}
```

上述两个要素字典树的结点也需要具备，另外，还需要额外存放该节点是否为叶结点。类比二叉树，由于只有左右两个结点，只需定义left,right两个结点即可，而字典树的结点一般有多个，比如小写字符有26个，就需要定义一个长度为26的字典树结点数组。

* 标识该节点是否为叶子结点
* 用一个结点数组存放结点的子节点

**特殊的是，结点的值可以根据结点数组是否为空来推算，比如小写字母字典树，当root的结点数组索引为0的位置不为空时，证明字母a存在于字典树中**

```java
    class TrieNode{
        boolean end; //该节点是否为叶子结点
        TrieNode [] children = new TrieNode[26];  //每个节点默认有26个孩子结点，对应26个字母,数组长度由潜在的字符种类确定
    }
```

**另一个特殊之处是字典树的根节点本身不存放值**

```java
package com.example.book.leetcode;

/**
 * @author: modige
 * @date: 2022/7/14 22:26
 * @description:
 */
class Trie {
    TrieNode root;
    //字典树结点
    class TrieNode{
        boolean end; //该节点是否为叶子结点
        TrieNode [] children = new TrieNode[26];  //每个节点默认有26个孩子结点，对应26个字母
    }

    public Trie() {
        root = new TrieNode();
            }

    public void insert(String word) {
        TrieNode p = root;
        for(int i=0;i<word.length();i++){
            int index = word.charAt(i) - 'a';
            if(p.children[index]==null){

                p.children[index] = new TrieNode();
            }
            p = p.children[index];
        }
        p.end = true;//插入所有字母后将最后一个结点表示为叶子结点

    }

    public boolean search(String word) {
        TrieNode p = root;
        for (char c:word.toCharArray()){
            //逐字符到字典树中查找，中间有没找到的字符返回false
            int index = c - 'a';
            if(p.children[index]==null) return false;
            p = p.children[index];
        }

        return p.end;//如果遍历到的最后一个结点是叶子结点，返回true

    }

    public boolean startsWith(String prefix) {
        TrieNode p = root;
        for (char c:prefix.toCharArray()){
            //逐字符到字典树中查找，中间有没找到的字符返回false
            int index = c - 'a';
            if(p.children[index]==null) return false;
            p = p.children[index];
        }

        return true;//如果遍历到的最后一个结点是叶子结点，返回true

    }
}

/**
 * Your Trie object will be instantiated and called as such:
 * Trie obj = new Trie();
 * obj.insert(word);
 * boolean param_2 = obj.search(word);
 * boolean param_3 = obj.startsWith(prefix);
 */
```

深度优先

给出4个1-10的数字，通过加减乘除，得到数字为24就算胜利。

```java
import java.util.*;
 
 
public class Solution {
    /**
     * 
     * @param arr int整型一维数组 
     * @return bool布尔型
     */
    boolean flag = false;
    public boolean Game24Points (int[] arr) {
        // write code here
        dfs(arr, 1, arr[0]);
        return flag;
    }
    public void dfs(int[] arr, int start,int res){
            if(start >= arr.length){
                if(res == 24) flag = true;
                return;
            }
            dfs(arr, start+1, res+arr[start]);
            dfs(arr, start+1, res-arr[start]);
            dfs(arr, start+1, res*arr[start]);
            dfs(arr, start+1, res/arr[start]);
        }
}

```

# 

## java ACM模式

1. 输入多组用例

   ```java
   import java.util.Scanner;
   Scanner sc = new Scanner(System.in);
   while(sc.hasNextLine()){
   
   }
   ```

2. 保留小数

   ```java
   System.out.printf("%.2f",res);
   ```

   



# 快排

```java
//快排的思路是交换，首先选择一个中间数（一般是数组的第一个元素）每趟遍历结束之后，比中间数小的移到左边，大的移到右边
//递归调用，以中间数为界，将数组分为两段，对两段数组继续使用快排算法
//两个模块，核心是交换模块，交换完成后返回中间数的索引，另一个则是递归模块，调用交换模块完成排序

public class QuickSort{

	public void quickSort(int []arr,int startIndex,int endIndex){
        if(startIndex>=endIndex) return;
        int index = swapNum(arr,startIndex,index);
        quickSort(arr,startIndex, endIndex);
        quickSort(arr,index,endIndex);
	
    }
    public int swapNum(int [] arr,int startIndex,int endIndex){
		int cur = startIndex;
        int left = startIndex,right=endIndex;
        while(left<right){
            while(right>left && arr[right]>arr[cur]) right--;
			while(left<right&&arr[left]<=arr[cur]) left++;
            if(left<right){
                int temp = arr[left];
            	arr[left] = arr[right];
            	arr[right] = temp;
            }
            
        }
        arr[startIndex] = arr[right];
        arr[right] = arr[cur];
        return right;
    }

}

```

```java
import java.util.Scanner;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        while(sc.hasNext()){
			 
        }
		
    		
    }
    public List<Integer> test(int [],int k,int x){
        
    }
    
}
```

# 手撕设计模式

## 生产者消费者

### 生产者

```java
package com.example.book.thread;

import java.util.Random;
import java.util.concurrent.ArrayBlockingQueue;

/**
 * @author: modige
 * @date: 2022/9/6 14:10
 * @description:手写生产者-消费者之生产者
 */
public class Producer implements Runnable {
    private ArrayBlockingQueue<Integer> queue ;//阻塞队列充当缓冲区
    public Producer(ArrayBlockingQueue<Integer> queue){
        this.queue = queue;
    }

    @Override
    public void run() {
        Random random = new Random();
        while (true){
            try {
                Thread.sleep(100);
                if(queue.size()==10) System.out.println("full");
                int item = random.nextInt(100);
                queue.put(item);
                System.out.println("producer:" + Thread.currentThread().getName() + " produce:" + item+";the size of the queue:" + queue.size());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

```

### 消费者

```java
package com.example.book.thread;

import java.util.concurrent.ArrayBlockingQueue;

/**
 * @author: modige
 * @date: 2022/9/6 14:14
 * @description:生产者-消费者模型之消费者
 */
public class Consumer implements Runnable{
    private ArrayBlockingQueue<Integer> queue;//缓冲区
    public Consumer(ArrayBlockingQueue<Integer>queue){
        this.queue = queue;
    }
    @Override
    public void run(){
        while (true){
            try {
                Thread.sleep(100);
                if(queue.size()==0) System.out.println("empty");
                Integer item = queue.take();
                System.out.println("take");

            }
            catch (InterruptedException e){
                e.printStackTrace();
            }
        }
    }
}

```

## 手写单例模式

### 懒汉 线程不安全

```java
public class Singleton{
	private static Singleton instance;
    private Singleton(){}//构造函数可以是私有化的，单例模式就是一个很好的证明
    public Static Singleton getInstance(){
		if(Instance==null) {
			instance = new Singleton();
        }
        return Instance;
    }
}
```

### 懒汉 线程安全

唯一区别就是添加synchronize关键字

```java
public class Singleton{
	private static Singleton instance;
    private Singleton(){}
    public static synchronized Singleton getInstance(){
        if(instance == null) 
            instance = new Singleton();
        return instance;
    }
}
```

### 饿汉

```java
public class Singleton{
    private static Singleton instance = new Singleton();
    private Singleton(){}
    public static getInstace(){
		return instance;
    }
}
```

# 手撕代码

## 手撕代码

**回溯、分治、迭代**

- 1、[最长回文子串]()(**LeetCode 5**)
- 2、接雨水(**LeetCode 42**)
- 3、最小栈(**LeetCode 155**)
- 4、判断是否[平衡二叉树]()(LeetCode 110)
- 5、**数组实现队列**
- 6、合并两个有序数组(LeetCode 88)
- 7、根据字符出现频率[排序]()(Lee,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,, tCode 451)
- 8、[跳台阶]()(剑指 Offer 10- II. 青蛙[跳台阶]()问题)
- 9、[判断链表中是否有环]()并返回环的入口(剑指 Offer II 022. [链表中环的入口节点]())
- 10、给定两个数组,在第二个数组中,找出比第一个数组每个位置大的数。
- 11、判断给出的字符串是否是合法的[括号序列]()(LeetCode 20)
- 12、买卖一次股票，最大利润(LeetCode 121)
- 13、**手写LRU**
- 14、数组中出现次数为1的数；
- 15、[反转字符串]()(LeetCode 344)
- 16、**手写快排**
- 17、实现创建单[链表]()，单[链表]()反转
- 18、实现类似ArrayList的自动扩容数组，get(i)、初始化方法、insert(I,elem)
- 19、无序数组查找一个数
- 20、[合并区间]()(**LeetCode 56**)
