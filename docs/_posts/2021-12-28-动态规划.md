# [剑指 Offer II 119. 最长连续序列](https://leetcode-cn.com/problems/WhsWhI/)

难度中等13

给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

 

**示例 1：**

```
输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
```

**示例 2：**

```
输入：nums = [0,3,7,2,5,8,4,6,0,1]
输出：9
```

 

**提示：**

- `0 <= nums.length <= 104`
- `-109 <= nums[i] <= 109`

 

**进阶：**可以设计并实现时间复杂度为 `O(n)` 的解决方案吗？

## 思路

利用HashMap ,查找时间复杂度为0（1），n个输入总时间复杂度=0（n）

hashmap中，key存放数组元素nums[i],value存放包含该元素的最长序列长度

程序流程

对于数组nums中的每个元素，执行

1. 判断nums[i]是否存在于hashmap中，若存在，说明该数字已经处理过，无需操作；若不存在，继续

2. 初始化map.put(nums[i],1)

3. 判断是否存在比nums[i]小1的元素，若存在，使用merge方法将两段长度相加，并更新map

4. 判断是否存在比numsp[i]大1的元素。若存在，使用merge方法将两段长度相加，并更新map

   

## 代码

```java
class Solution {
    public int longestConsecutive(int[] nums) {
        if(nums==null ||nums.length==0) return 0;
        int max = 1;
        HashMap<Integer,Integer> map = new HashMap();
        for(int i=0;i<nums.length;i++){
            if(!map.containsKey(nums[i])){
                map.put(nums[i],1);
                if(map.containsKey(nums[i]-1)){
                    max = Math.max(max,merge(map,nums[i]-1,nums[i]));
                }
                if(map.containsKey(nums[i]+1)){
                    max = Math.max(max,merge(map,nums[i],nums[i]+1));
                }
            }
        }
        return max;
    }
    //更新hashmap
    public int merge(HashMap<Integer,Integer> map,int less,int more){
        int left = less - map.get(less) + 1;
        int right = more + map.get(more) - 1;
        int len = right - left + 1;
        map.put(left,len);
        map.put(right,len);
        return len;
    }
}
```



# [剑指 Offer II 089. 房屋偷盗](https://leetcode.cn/problems/Gu0c2T/)

难度中等22收藏分享切换为英文接收动态反馈

一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响小偷偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组 `nums` ，请计算 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

 

**示例 1：**

```
输入：nums = [1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

**示例 2：**

```
输入：nums = [2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

## 思路 动态规划

重新定义一个数组res，res[i]用来存放当数组为i时的最大金额

| num         | 当前最大金额 | 当前res数组     | 解释                                        |
| ----------- | ------------ | --------------- | ------------------------------------------- |
| [2]         | 2            | [2]             | 只有一个元素，答案只能是2                   |
| [2,7]       | 7            | [2,7]           | 新来了个7，偷7不偷2                         |
| [2,7,9]     | 2+9=11       | [2,7,11]        | 偷2,9,不偷7                                 |
| [2,7,9,3]   | 3+7=10       | [2,7,11,10]     | 偷3,7                                       |
| [2,7,9,3,1] | 1+11=12      | [2,7,11,10，12] | 这里+11是因为不选择3可以选择3以前的最佳结果 |

**res[i] = max(res[i]+res[i-2],res[i-1])**

[2,7,9,3,1]



对于数组[2,7,9,3,1]，按数组长度遍历

i=1,最大金额为2

i=2,最大金额为7

i=3，最大金额为2+9 = 11

i=4,最大金额为7+3 = 10 

i=5,最大金额为1+11



## 代码

```java
class Solution {
    public int rob(int[] nums) {
        if(nums.length==1) return nums[0];
        int max = 0;
        int[] res = new int[nums.length];
        res[0] = nums[0];
        if (nums.length==2) return nums[0]>nums[1]?nums[0]:nums[1];
        res[1] = nums[0]>nums[1]?nums[0]:nums[1];
        for(int i =2;i<nums.length;i++){
            res[i] = nums[i] + res[i-2]>res[i-1]?  nums[i] + res[i-2]:res[i-1];
        }
        return res[nums.length-1];  
    }
  
}
```

# [剑指 Offer II 091. 粉刷房子](https://leetcode.cn/problems/JEj789/)

难度中等96收藏分享切换为英文接收动态反馈

假如有一排房子，共 `n` 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。

当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 `n x 3` 的正整数矩阵 `costs` 来表示的。

例如，`costs[0][0]` 表示第 0 号房子粉刷成红色的成本花费；`costs[1][2]` 表示第 1 号房子粉刷成绿色的花费，以此类推。

请计算出粉刷完所有房子最少的花费成本。

 

**示例 1：**

```
输入: costs = [[17,2,17],[16,16,5],[14,3,19]]
输出: 10
解释: 将 0 号房子粉刷成蓝色，1 号房子粉刷成绿色，2 号房子粉刷成蓝色。
     最少花费: 2 + 5 + 3 = 10。
```

**示例 2：**

```
输入: costs = [[7,6,2]]
输出: 2
```

## 思路

更新当前数组，

数组第一行不变、

**从第二行开始，当前列的值=上一行中与当前列不同列的值+当前列的值**

这样能保证每一行的最小值就是当数组只到这一行时的最佳结果

举例 "

[[7,17,16],[3,10,1],[6,12,18],[12,18,17],[15,18,16],[17,4,1],[13,8,8],[5,14,5],[1,11,1],[5,10,8],[18,11,15],[6,13,10],[17,7,2],[15,12,10],[9,3,19],[2,3,11]]";

```
7 17 16
19 17 8       19=3+16  17 = 10 +7  8 = 1 +7
14 20 35  
32 32 31  
46 49 48  
65 50 47  
60 55 58  
60 72 60  
61 71 61  
66 71 69  
87 77 81  
83 94 87  
104 90 85  
100 97 100  
106 103 116  
105 109 114  
105
```

## 代码

```java
class Solution {
    public int minCost(int[][] costs) {
        for(int i=1;i<costs.length;i++){
            for(int j=0;j<3;j++){
                costs[i][j] = getMin(j,costs[i-1]) + costs[i][j];

            }
        }
        return getMin(9,costs[costs.length-1]);
    

    }
    public int getMin(int a,int []nums){
        int min = Integer.MAX_VALUE;
        for(int i=0;i<nums.length;i++){
            if(i!=a&&nums[i]<min) min = nums[i];
        }
        
        return min;
    }
    
}	
```



# [1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)

难度中等1030

给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ，返回 `0` 。

一个字符串的 **子序列** 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

- 例如，`"ace"` 是 `"abcde"` 的子序列，但 `"aec"` 不是 `"abcde"` 的子序列。

两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。

 

**示例 1：**

```
输入：text1 = "abcde", text2 = "ace" 
输出：3  
解释：最长公共子序列是 "ace" ，它的长度为 3 。
```

**示例 2：**

```
输入：text1 = "abc", text2 = "abc"
输出：3
解释：最长公共子序列是 "abc" ，它的长度为 3 。
```

**示例 3：**

```
输入：text1 = "abc", text2 = "def"
输出：0
解释：两个字符串没有公共子序列，返回 0 。
```

 

**提示：**

- `1 <= text1.length, text2.length <= 1000`
- `text1` 和 `text2` 仅由小写英文字符组成。

1. 

## 思路

**二维动态规划**

设`text1`长度为`m`，`text2`长度为`n`,声明一个（m+1）*（n+1）的二维数组dp

dp\[i]\[j]表示text1[0~i]与text2[o~j]的最大公共子序列长度

1. 首先初始化两个边界，数组第一行以及第一列的元素全为0，因为字符串长度为0时没有公共子序列
2. 之后对数组进行赋值时，有一个前提，那就是这个元素的上、左、左上三个地方（如果存在）一定已经已经初始化过了
3. 逐行逐列赋值，对于(i,j),有三种情况
4. 

## 代码

```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int m = text1.length(), n = text2.length();
        int[][] dp = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            char c1 = text1.charAt(i - 1);
            for (int j = 1; j <= n; j++) {
                char c2 = text2.charAt(j - 1);
                if (c1 == c2) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[m][n];
    }

}
```

# DFS

## 矩阵路径

#### [剑指 Offer 12. 矩阵中的路径](https://leetcode.cn/problems/ju-zhen-zhong-de-lu-jing-lcof/)

难度中等664

给定一个 `m x n` 二维字符网格 `board` 和一个字符串单词 `word` 。如果 `word` 存在于网格中，返回 `true` ；否则，返回 `false` 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

 

例如，在下面的 3×4 的矩阵中包含单词 "ABCCED"（单词中的字母已标出）。

![img](https://assets.leetcode.com/uploads/2020/11/04/word2.jpg)

 

**示例 1：**

```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true
```

**示例 2：**

```
输入：board = [["a","b"],["c","d"]], word = "abcd"
输出：false
```

 

**提示：**

- `m == board.length`
- `n = board[i].length`
- `1 <= m, n <= 6`
- `1 <= word.length <= 15`
- `board `和` word `仅由大小写英文字母组成

**基本思路**：

从矩阵中的每个与word首字母相同的点开始遍历，如果能找到一条路径则返回true，都找不到则返回false

问题转换为从某个点开始是否存在路径

**关键点**：

1. 标记已经访问过的点，防止重复走步
2. 直接返回false的条件
   * 当前字母与word字母不同
   * word字母遍历结束
   * 

```java
class Solution {
    public boolean exist(char[][] board, String word) {
        char[] words = word.toCharArray();
        for(int i = 0; i < board.length; i++) {
            for(int j = 0; j < board[0].length; j++) {
                if(dfs(board, words, i, j, 0)) return true;
            }
        }
        return false;
    }
    boolean dfs(char[][] board, char[] word, int i, int j, int k) {
        //超出数组边界或元素不同，直接返回false
        if(i >= board.length || i < 0 || j >= board[0].length || j < 0 || board[i][j] != word[k]) return false;
        //word最后一个单词遍历结束，证明路径存在
        
        if(k == word.length - 1) return true;
        //访问过的数组元素标记下来，防止重复走步
        board[i][j] = '\0';
        //如果前后左右有一个能走的路径，就顺着走下去
        //这个递归真正结束的条件是 k==word.length-1,也就是访问完word
        boolean res = dfs(board, word, i + 1, j, k + 1) || dfs(board, word, i - 1, j, k + 1) || 
                      dfs(board, word, i, j + 1, k + 1) || dfs(board, word, i , j - 1, k + 1);
        //把数组元素恢复，不影响别的起点继续查找路径
        board[i][j] = word[k];
        return res;
    }
}
```

